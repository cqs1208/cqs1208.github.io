<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="golang">
<meta property="og:type" content="article">
<meta property="og:title" content="go GC">
<meta property="og:url" content="http://example.com/2020/08/14/Go/2020-08-14%20go%20GC/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="golang">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc01.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc02.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc03.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc04.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc05.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc06.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc07.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc08.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc42.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc43.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc44.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc45.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc46.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc09.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc10.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc11.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc12.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc13.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc14.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc15.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc16.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc17.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc18.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc19.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc20.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc21.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc22.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc23.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc24.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc25.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc26.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc27.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc28.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc29.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc30.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc31.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc32.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc33.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc34.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc35.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc36.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc37.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc38.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc39.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc40.png">
<meta property="og:image" content="http://example.com/images/go/gc/gc_gc41.png">
<meta property="article:published_time" content="2020-08-14T04:47:44.000Z">
<meta property="article:modified_time" content="2020-08-14T01:54:22.121Z">
<meta property="article:author" content="QingSong">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/go/gc/gc_gc01.png">

<link rel="canonical" href="http://example.com/2020/08/14/Go/2020-08-14%20go%20GC/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>go GC | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">点滴积累 豁达处之</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/14/Go/2020-08-14%20go%20GC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar/avatar.png">
      <meta itemprop="name" content="QingSong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go GC
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-14 12:47:44 / Modified: 09:54:22" itemprop="dateCreated datePublished" datetime="2020-08-14T12:47:44+08:00">2020-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
                </span>
            </span>

          
            <div class="post-description">golang</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>go GC</p>
<a id="more"></a> 

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>简单地说，<strong>垃圾回收(GC)是在后台运行一个守护线程，它的作用是在监控各个对象的状态，识别并且丢弃不再使用的对象来释放和重用资源。</strong></p>
<h2 id="Go的垃圾回收"><a href="#Go的垃圾回收" class="headerlink" title="Go的垃圾回收"></a>Go的垃圾回收</h2><p>当前Golang使用的垃圾回收机制是<strong>三色标记发</strong>配合<strong>写屏障</strong>和<strong>辅助GC</strong>，三色标记法是<strong>标记-清除法</strong>的一种增强版本。</p>
<h2 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>理解<strong>三色标记法</strong>的关键是理解对象的<strong>三色抽象</strong>以及<strong>波面（wavefront）推进</strong>这两个概念。三色抽象只是一种描述追踪式回收器的方法，在实践中并没有实际含义，它的重要作用在于从逻辑上严密推导标记清理这种垃圾回收方法的正确性。也就是说，当我们谈及三色标记法时，通常指标记清扫的垃圾回收。</p>
<p>从垃圾回收器的视角来看，三色抽象规定了三种不同类型的对象，并用不同的颜色相称：</p>
<ul>
<li>白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。</li>
<li>灰色对象（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。</li>
<li>黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。</li>
</ul>
<p>这样三种不变性所定义的回收过程其实是一个<strong>波面</strong>不断前进的过程，这个波面同时也是黑色对象和白色对象的边界，灰色对象就是这个波面。</p>
<p>当垃圾回收开始时，只有白色对象。随着标记过程开始进行时，灰色对象开始出现（着色），这时候波面便开始扩大。当一个对象的所有子节点均完成扫描时，会被着色为黑色。当整个堆遍历完成时，只剩下黑色和白色对象，这时的黑色对象为可达对象，即存活；而白色对象为不可达对象，即死亡。这个过程可以视为以灰色对象为波面，将黑色对象和白色对象分离，使波面不断向前推进，直到所有可达的灰色对象都变为黑色对象为止的过程。如下图所示：</p>
<p><img src="/images/go/gc/gc_gc01.png" alt="gc_gc01"></p>
<p>图中展示了根对象、可达对象、不可达对象，黑、灰、白对象以及波面之间的关系。</p>
<h3 id="三色标记详解"><a href="#三色标记详解" class="headerlink" title="三色标记详解"></a>三色标记详解</h3><p>三色标记法 实际上就是通过三个阶段的标记来确定清楚的对象都有哪些. 我们来看一下具体的过程.</p>
<p><strong>第一步</strong> , 就是只要是新创建的对象,默认的颜色都是标记为“白色”.</p>
<p><img src="/images/go/gc/gc_gc02.png" alt="gc_gc02"></p>
<p>这里面需要注意的是, 所谓“程序”, 则是一些对象的跟节点集合.</p>
<p><img src="/images/go/gc/gc_gc03.png" alt="gc_gc03"></p>
<p>所以上图,可以转换如下的方式来表示.</p>
<p><strong>第二步</strong>, 每次GC回收开始, 然后从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合。</p>
<p><img src="/images/go/gc/gc_gc04.png" alt="gc_gc04"></p>
<p><strong>第三步</strong>, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合</p>
<p><img src="/images/go/gc/gc_gc05.png" alt="gc_gc05"></p>
<p><strong>第四步</strong>, 重复<strong>第三步</strong>, 直到灰色中无任何对象.</p>
<p><img src="/images/go/gc/gc_gc06.png" alt="gc_gc06"></p>
<p><img src="/images/go/gc/gc_gc07.png" alt="gc_gc07"></p>
<p><strong>第五步</strong>: 回收所有的白色标记表的对象. 也就是回收垃圾.</p>
<p><img src="/images/go/gc/gc_gc08.png" alt="gc_gc08"></p>
<p>以上便是<code>三色并发标记法</code></p>
<h3 id="没有STW的三色标记法"><a href="#没有STW的三色标记法" class="headerlink" title="没有STW的三色标记法"></a>没有STW的三色标记法</h3><p>我们还是基于上述的三色并发标记法来说, 他是一定要依赖STW的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性。我们举一个场景.</p>
<p>如果三色标记法, 标记过程不使用STW将会发生什么事情?</p>
<p><img src="/images/go/gc/gc_gc42.png" alt="gc_gc42"></p>
<p><img src="/images/go/gc/gc_gc43.png" alt="gc_gc43"></p>
<p><img src="/images/go/gc/gc_gc44.png" alt="gc_gc44"></p>
<p><img src="/images/go/gc/gc_gc45.png" alt="gc_gc45"></p>
<p><img src="/images/go/gc/gc_gc46.png" alt="gc_gc46"></p>
<p>可以看出，有两个问题, 在三色标记法中,是不希望被发生的</p>
<ul>
<li>条件1: 一个白色对象被黑色对象引用**(白色被挂在黑色下)**</li>
<li>条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏**(灰色同时丢了该白色)**</li>
</ul>
<p>当以上两个条件同时满足时, 就会出现对象丢失现象!</p>
<p>只要能够避免其中任何一个条件，则不会出现对象丢失的情况，因为：</p>
<ul>
<li>如果条件 1 被避免，则所有白色对象均被灰色对象引用，没有白色对象会被遗漏；</li>
<li>如果条件 2 被避免，即便白色对象的指针被写入到黑色对象中，但从灰色对象出发，总存在一条没有访问过的路径，从而找到到达白色对象的路径，白色对象最终不会被遗漏。</li>
</ul>
<h2 id="写屏障、混合写屏障"><a href="#写屏障、混合写屏障" class="headerlink" title="写屏障、混合写屏障"></a>写屏障、混合写屏障</h2><h3 id="“强-弱”-三色不变式"><a href="#“强-弱”-三色不变式" class="headerlink" title="“强-弱” 三色不变式"></a>“强-弱” 三色不变式</h3><p>我们不妨将三色不变性所定义的波面根据这两个条件进行削弱：</p>
<ul>
<li>当满足原有的三色不变性定义（或上面的两个条件都不满足时）的情况称为<strong>强三色不变性（strong tricolor invariant）</strong></li>
</ul>
<p><img src="/images/go/gc/gc_gc09.png" alt="gc_gc09"></p>
<ul>
<li>当赋值器令黑色对象引用白色对象时（满足条件 1 时）的情况称为<strong>弱三色不变性（weak tricolor invariant）</strong></li>
</ul>
<p><img src="/images/go/gc/gc_gc10.png" alt="gc_gc10"></p>
<p>为了遵循上述的两个方式,Golang团队初步得到了如下具体的两种屏障方式“插入屏障”, “删除屏障”.</p>
<h3 id="插入屏障"><a href="#插入屏障" class="headerlink" title="插入屏障"></a>插入屏障</h3><p><code>具体操作</code>: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)</p>
<p><code>满足</code>: <strong>强三色不变式</strong>. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)</p>
<p>场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.添加下游对象(nil, B)   <span class="comment">//A 之前没有下游， 新添加一个下游对象B， B被标记为灰色</span></span><br><span class="line">A.添加下游对象(C, B)     <span class="comment">//A 将下游对象C 更换为B，  B被标记为灰色</span></span><br></pre></td></tr></table></figure>

<p> 这段伪码逻辑就是写屏障,. 我们知道,黑色对象的内存槽有两种位置, <code>栈</code>和<code>堆</code>. 栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以“插入屏障”机制,在<strong>栈空间的对象操作中不使用</strong>. 而仅仅使用在堆空间对象的操作中.</p>
<p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p>
<p><img src="/images/go/gc/gc_gc11.png" alt="gc_gc11"></p>
<p><img src="/images/go/gc/gc_gc12.png" alt="gc_gc12"></p>
<p><img src="/images/go/gc/gc_gc13.png" alt="gc_gc13"></p>
<p><img src="/images/go/gc/gc_gc14.png" alt="gc_gc14"></p>
<p><img src="/images/go/gc/gc_gc15.png" alt="gc_gc15"></p>
<p><img src="/images/go/gc/gc_gc16.png" alt="gc_gc16"></p>
<p> 但是如果栈不添加,当全部三色标记扫描之后,栈上有可能依然存在白色对象被引用的情况. 所以要对栈重新进行三色标记扫描, 但这次为了对象不丢失, 要对本次标记扫描启动STW暂停. 直到栈空间的三色标记结束.</p>
<p><img src="/images/go/gc/gc_gc17.png" alt="gc_gc17"></p>
<p><img src="/images/go/gc/gc_gc18.png" alt="gc_gc18"></p>
<p><img src="/images/go/gc/gc_gc19.png" alt="gc_gc19"></p>
<p>最后将栈和堆空间 扫描剩余的全部 白色节点清除.</p>
<p><img src="/images/go/gc/gc_gc20.png" alt="gc_gc20"></p>
<h3 id="删除屏障"><a href="#删除屏障" class="headerlink" title="删除屏障"></a>删除屏障</h3><p><code>具体操作</code>: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</p>
<p><code>满足</code>: <strong>弱三色不变式</strong>. (保护灰色对象到白色对象的路径不会断)</p>
<p>场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.添加下游对象(B, nil)   <span class="comment">//A对象，删除B对象的引用。  B被A删除，被标记为灰(如果B之前为白)</span></span><br><span class="line">A.添加下游对象(B, C)         <span class="comment">//A对象，更换下游B变成C。   B被A删除，被标记为灰(如果B之前为白)</span></span><br></pre></td></tr></table></figure>

<p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p>
<p><img src="/images/go/gc/gc_gc21.png" alt="gc_gc21"></p>
<p><img src="/images/go/gc/gc_gc22.png" alt="gc_gc22"></p>
<p><img src="/images/go/gc/gc_gc23.png" alt="gc_gc23"></p>
<p><img src="/images/go/gc/gc_gc24.png" alt="gc_gc24"></p>
<p><img src="/images/go/gc/gc_gc25.png" alt="gc_gc25"></p>
<p><img src="/images/go/gc/gc_gc26.png" alt="gc_gc26"></p>
<p><img src="/images/go/gc/gc_gc27.png" alt="gc_gc27"></p>
<p>这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p>
<h3 id="Go-V1-8的混合写屏障"><a href="#Go-V1-8的混合写屏障" class="headerlink" title="Go V1.8的混合写屏障"></a>Go V1.8的混合写屏障</h3><p>插入写屏障和删除写屏障的短板：</p>
<ul>
<li>插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；</li>
<li>删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。</li>
</ul>
<p>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。</p>
<h4 id="混合写屏障规则"><a href="#混合写屏障规则" class="headerlink" title="混合写屏障规则"></a>混合写屏障规则</h4><p><code>具体操作</code>:</p>
<p>1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，</p>
<p>2、GC期间，任何在栈上创建的新对象，均为黑色。</p>
<p>3、被删除的对象标记为灰色。</p>
<p>4、被添加的对象标记为灰色。</p>
<p><code>满足</code>: 变形的<strong>弱三色不变式</strong>.</p>
<p><strong>注：</strong>这里我们注意， 屏障技术是不在栈上应用的，因为要保证栈的运行效率。</p>
<h4 id="混合写屏障的具体场景"><a href="#混合写屏障的具体场景" class="headerlink" title="混合写屏障的具体场景"></a>混合写屏障的具体场景</h4><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p>
<blockquote>
<p>注意混合写屏障是Gc的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。</p>
</blockquote>
<p>GC开始：扫描栈区，将可达对象全部标记为黑</p>
<p><img src="/images/go/gc/gc_gc28.png" alt="gc_gc28"></p>
<p><img src="/images/go/gc/gc_gc29.png" alt="gc_gc29"></p>
<h5 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h5><p> 对象被一个堆对象删除引用，成为栈对象的下游</p>
<p>伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前提：堆对象4-&gt;对象7 = 对象7；  //对象7 被 对象4引用</span></span><br><span class="line">栈对象<span class="number">1</span>-&gt;对象<span class="number">7</span> = 堆对象<span class="number">7</span>；  <span class="comment">//将堆对象7 挂在 栈对象1 下游</span></span><br><span class="line">堆对象<span class="number">4</span>-&gt;对象<span class="number">7</span> = <span class="keyword">null</span>；    <span class="comment">//对象4 删除引用 对象7</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/go/gc/gc_gc30.png" alt="gc_gc30"></p>
<p><img src="/images/go/gc/gc_gc31.png" alt="gc_gc31"></p>
<h5 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h5><p> 对象被一个栈对象删除引用，成为另一个栈对象的下游</p>
<p>伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 栈对象<span class="number">9</span>；</span><br><span class="line">对象<span class="number">8</span>-&gt;对象<span class="number">3</span> = 对象<span class="number">3</span>；      <span class="comment">//将栈对象3 挂在 栈对象9 下游</span></span><br><span class="line">对象<span class="number">2</span>-&gt;对象<span class="number">3</span> = <span class="keyword">null</span>；      <span class="comment">//对象2 删除引用 对象3</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/go/gc/gc_gc32.png" alt="gc_gc32"></p>
<p><img src="/images/go/gc/gc_gc33.png" alt="gc_gc33"></p>
<p><img src="/images/go/gc/gc_gc34.png" alt="gc_gc34"></p>
<h5 id="场景3"><a href="#场景3" class="headerlink" title="场景3"></a>场景3</h5><p>对象被一个堆对象删除引用，成为另一个堆对象的下游</p>
<p>伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">堆对象<span class="number">10</span>-&gt;对象<span class="number">7</span> = 堆对象<span class="number">7</span>；       <span class="comment">//将堆对象7 挂在 堆对象10 下游</span></span><br><span class="line">堆对象<span class="number">4</span>-&gt;对象<span class="number">7</span> = <span class="keyword">null</span>；         <span class="comment">//对象4 删除引用 对象7</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/go/gc/gc_gc35.png" alt="gc_gc35"></p>
<p><img src="/images/go/gc/gc_gc36.png" alt="gc_gc36"></p>
<p><img src="/images/go/gc/gc_gc37.png" alt="gc_gc37"></p>
<h5 id="场景4"><a href="#场景4" class="headerlink" title="场景4"></a>场景4</h5><p>对象从一个栈对象删除引用，成为另一个堆对象的下游</p>
<p>伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">堆对象<span class="number">10</span>-&gt;对象<span class="number">7</span> = 堆对象<span class="number">7</span>；       <span class="comment">//将堆对象7 挂在 堆对象10 下游</span></span><br><span class="line">堆对象<span class="number">4</span>-&gt;对象<span class="number">7</span> = <span class="keyword">null</span>；         <span class="comment">//对象4 删除引用 对象7</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/go/gc/gc_gc38.png" alt="gc_gc38"></p>
<p><img src="/images/go/gc/gc_gc39.png" alt="gc_gc39"></p>
<p><img src="/images/go/gc/gc_gc40.png" alt="gc_gc40"></p>
<p> Golang中的混合写屏障满足<code>弱三色不变式</code>，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。</p>
<h2 id="对象回收流程"><a href="#对象回收流程" class="headerlink" title="对象回收流程"></a>对象回收流程</h2><h3 id="根对象"><a href="#根对象" class="headerlink" title="根对象"></a>根对象</h3><p>在GC的标记阶段首先需要标记的就是”根对象”, 从根对象开始可到达的所有对象都会被认为是存活的.<br>根对象包含了全局变量, 各个G的栈上的变量等, GC会先扫描根对象然后再扫描根对象可到达的所有对象.<br>扫描根对象包含了一系列的工作</p>
<ul>
<li>Fixed Roots: 特殊的扫描工作<ul>
<li>fixedRootFinalizers: 扫描析构器队列</li>
<li>fixedRootFreeGStacks: 释放已中止的G的栈</li>
</ul>
</li>
<li>Flush Cache Roots: 释放mcache中的所有span, 要求STW</li>
<li>Data Roots: 扫描可读写的全局变量</li>
<li>BSS Roots: 扫描只读的全局变量</li>
<li>Span Roots: 扫描各个span中特殊对象(析构器列表)</li>
<li>Stack Roots: 扫描各个G的栈</li>
</ul>
<p>标记阶段(Mark)会做其中的”Fixed Roots”, “Data Roots”, “BSS Roots”, “Span Roots”, “Stack Roots”.<br>完成标记阶段(Mark Termination)会做其中的”Fixed Roots”, “Flush Cache Roots”.</p>
<h3 id="标记队列"><a href="#标记队列" class="headerlink" title="标记队列"></a>标记队列</h3><p>GC的标记阶段会使用”标记队列”来确定所有可从根对象到达的对象都已标记, 上面提到的”灰色”的对象就是在标记队列中的对象.<br>举例来说, 如果当前有[A, B, C]这三个根对象, 那么扫描根对象时就会把它们放到标记队列:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">work queue: [A, B, C]</span><br></pre></td></tr></table></figure>

<p>后台标记任务从标记队列中取出A, 如果A引用了D, 则把D放入标记队列:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">work queue: [B, C, D]</span><br></pre></td></tr></table></figure>

<p>后台标记任务从标记队列取出B, 如果B也引用了D, 这时因为D在gcmarkBits中对应的bit已经是1所以会跳过:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">work queue: [C, D]</span><br></pre></td></tr></table></figure>

<p>如果并行运行的go代码分配了一个对象E, 对象E会被立刻标记, 但不会进入标记队列(因为确定E没有引用其他对象).<br>然后并行运行的go代码把对象F设置给对象E的成员, 写屏障会标记对象F然后把对象F加到运行队列:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">work queue: [C, D, F]</span><br></pre></td></tr></table></figure>

<p>后台标记任务从标记队列取出C, 如果C没有引用其他对象, 则不需要处理:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">work queue: [D, F]</span><br></pre></td></tr></table></figure>

<p>后台标记任务从标记队列取出D, 如果D引用了X, 则把X放入标记队列:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">work queue: [F, X]</span><br></pre></td></tr></table></figure>

<p>后台标记任务从标记队列取出F, 如果F没有引用其他对象, 则不需要处理.<br>后台标记任务从标记队列取出X, 如果X没有引用其他对象, 则不需要处理.<br>最后标记队列为空, 标记完成, 存活的对象有[A, B, C, D, E, F, X].</p>
<p>当前1.9版本的 Go 以 STW 为界限，可以将 GC 划分为五个阶段：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>说明</th>
<th>赋值器状态</th>
</tr>
</thead>
<tbody><tr>
<td>SweepTermination</td>
<td>清扫终止阶段，为下一个阶段的并发标记做准备工作，启动写屏障</td>
<td>STW</td>
</tr>
<tr>
<td>Mark</td>
<td>扫描标记阶段，与赋值器并发执行，写屏障开启</td>
<td>并发</td>
</tr>
<tr>
<td>MarkTermination</td>
<td>标记终止阶段，保证一个周期内标记任务完成，停止写屏障</td>
<td>STW</td>
</tr>
<tr>
<td>GCoff</td>
<td>内存清扫阶段，将需要回收的内存归还到堆中，写屏障关闭</td>
<td>并发</td>
</tr>
<tr>
<td>GCoff</td>
<td>内存归还阶段，将过多的内存归还给操作系统，写屏障关闭</td>
<td>并发</td>
</tr>
</tbody></table>
<p>完整的GC流程图示：</p>
<p><img src="/images/go/gc/gc_gc41.png" alt="gc_gc41"></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="gcStart"><a href="#gcStart" class="headerlink" title="gcStart"></a>gcStart</h4><p>go触发gc会从<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1190">gcStart</a>函数开始:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">gcStart</span><span class="params">(mode gcMode, trigger gcTrigger)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 判断当前G是否可抢占, 不可抢占时不触发GC</span></span><br><span class="line">	mp := acquirem()</span><br><span class="line">	<span class="keyword">if</span> gp := getg(); gp == mp.g0 || mp.locks &gt; <span class="number">1</span> || mp.preemptoff != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		releasem(mp)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	releasem(mp)</span><br><span class="line">	mp = nil</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并行清扫上一轮GC未清扫的span</span></span><br><span class="line">	<span class="keyword">for</span> trigger.test() &amp;&amp; gosweepone() != ^uintptr(<span class="number">0</span>) &#123;</span><br><span class="line">		sweep.nbgsweep++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 上锁, 然后重新检查gcTrigger的条件是否成立, 不成立时不触发GC</span></span><br><span class="line">	<span class="comment">// transition.</span></span><br><span class="line">	semacquire(&amp;work.startSema)</span><br><span class="line">	<span class="comment">// Re-check transition condition under transition lock.</span></span><br><span class="line">	<span class="keyword">if</span> !trigger.test() &#123;</span><br><span class="line">		semrelease(&amp;work.startSema)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录是否强制触发, gcTriggerCycle是runtime.GC用的</span></span><br><span class="line">	work.userForced = trigger.kind == gcTriggerAlways || trigger.kind == gcTriggerCycle</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断是否指定了禁止并行GC的参数</span></span><br><span class="line">	<span class="comment">// start multiple STW GCs.</span></span><br><span class="line">	<span class="keyword">if</span> mode == gcBackgroundMode &#123;</span><br><span class="line">		<span class="keyword">if</span> debug.gcstoptheworld == <span class="number">1</span> &#123;</span><br><span class="line">			mode = gcForceMode</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> debug.gcstoptheworld == <span class="number">2</span> &#123;</span><br><span class="line">			mode = gcForceBlockMode</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ok, we&#x27;re doing it!  Stop everybody else</span></span><br><span class="line">	semacquire(&amp;worldsema)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 跟踪处理</span></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGCStart()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动后台扫描任务(G)</span></span><br><span class="line">	<span class="keyword">if</span> mode == gcBackgroundMode &#123;</span><br><span class="line">		gcBgMarkStartWorkers()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置标记相关的状态</span></span><br><span class="line">	gcResetMarkState()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置参数</span></span><br><span class="line">	work.stwprocs, work.maxprocs = gcprocs(), gomaxprocs</span><br><span class="line">	work.heap0 = atomic.Load64(&amp;memstats.heap_live)</span><br><span class="line">	work.pauseNS = <span class="number">0</span></span><br><span class="line">	work.mode = mode</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录开始时间</span></span><br><span class="line">	now := nanotime()</span><br><span class="line">	work.tSweepTerm = now</span><br><span class="line">	work.pauseStart = now</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 停止所有运行中的G, 并禁止它们运行</span></span><br><span class="line">	systemstack(stopTheWorldWithSema)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// !!!!!!!!!!!!!!!!</span></span><br><span class="line">	<span class="comment">// 世界已停止(STW)...</span></span><br><span class="line">	<span class="comment">// !!!!!!!!!!!!!!!!</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 清扫上一轮GC未清扫的span, 确保上一轮GC已完成</span></span><br><span class="line">	<span class="comment">// Finish sweep before we start concurrent scan.</span></span><br><span class="line">	systemstack(func() &#123;</span><br><span class="line">		finishsweep_m()</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 清扫sched.sudogcache和sched.deferpool</span></span><br><span class="line">	clearpools()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 增加GC计数</span></span><br><span class="line">	work.cycles++</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 判断是否并行GC模式</span></span><br><span class="line">	<span class="keyword">if</span> mode == gcBackgroundMode &#123; <span class="comment">// Do as much work concurrently as possible</span></span><br><span class="line">		<span class="comment">// 标记新一轮GC已开始</span></span><br><span class="line">		gcController.startCycle()</span><br><span class="line">		work.heapGoal = memstats.next_gc</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置全局变量中的GC状态为_GCmark</span></span><br><span class="line">		<span class="comment">// 然后启用写屏障</span></span><br><span class="line">		setGCPhase(_GCmark)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 重置后台标记任务的计数</span></span><br><span class="line">		gcBgMarkPrepare() <span class="comment">// Must happen before assist enable.</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 计算扫描根对象的任务数量</span></span><br><span class="line">		gcMarkRootPrepare()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 标记所有tiny alloc等待合并的对象</span></span><br><span class="line">		gcMarkTinyAllocs()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 启用辅助GC</span></span><br><span class="line">		atomic.Store(&amp;gcBlackenEnabled, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 记录标记开始的时间</span></span><br><span class="line">		<span class="comment">// Assists and workers can start the moment we start</span></span><br><span class="line">		<span class="comment">// the world.</span></span><br><span class="line">		gcController.markStartTime = now</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 重新启动世界</span></span><br><span class="line">		<span class="comment">// 前面创建的后台标记任务会开始工作, 所有后台标记任务都完成工作后, 进入完成标记阶段</span></span><br><span class="line">		<span class="comment">// Concurrent mark.</span></span><br><span class="line">		systemstack(startTheWorldWithSema)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// !!!!!!!!!!!!!!!</span></span><br><span class="line">		<span class="comment">// 世界已重新启动...</span></span><br><span class="line">		<span class="comment">// !!!!!!!!!!!!!!!</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 记录停止了多久, 和标记阶段开始的时间</span></span><br><span class="line">		now = nanotime()</span><br><span class="line">		work.pauseNS += now - work.pauseStart</span><br><span class="line">		work.tMark = now</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 不是并行GC模式</span></span><br><span class="line">		<span class="comment">// 记录完成标记阶段开始的时间</span></span><br><span class="line">		t := nanotime()</span><br><span class="line">		work.tMark, work.tMarkTerm = t, t</span><br><span class="line">		work.heapGoal = work.heap0</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 跳过标记阶段, 执行完成标记阶段</span></span><br><span class="line">		<span class="comment">// 所有标记工作都会在世界已停止的状态执行</span></span><br><span class="line">		<span class="comment">// (标记阶段会设置work.markrootDone=true, 如果跳过则它的值是false, 完成标记阶段会执行所有工作)</span></span><br><span class="line">		<span class="comment">// 完成标记阶段会重新启动世界</span></span><br><span class="line">		<span class="comment">// Perform mark termination. This will restart the world.</span></span><br><span class="line">		gcMarkTermination(memstats.triggerRatio)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	semrelease(&amp;work.startSema)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gcBgMarkStartWorkers"><a href="#gcBgMarkStartWorkers" class="headerlink" title="gcBgMarkStartWorkers"></a>gcBgMarkStartWorkers</h4><p>接下来一个个分析gcStart调用的函数, 建议配合上面的”回收对象的流程”中的图理解.</p>
<p>gcBgMarkStartWorkers函数用于启动后台标记任务, 先分别对每个P启动一个:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">gcBgMarkStartWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> _, p := range &amp;allp &#123;</span><br><span class="line">		<span class="keyword">if</span> p == nil || p.status == _Pdead &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果已启动则不重复启动</span></span><br><span class="line">		<span class="keyword">if</span> p.gcBgMarkWorker == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="function">go <span class="title">gcBgMarkWorker</span><span class="params">(p)</span></span></span><br><span class="line"><span class="function">			<span class="comment">// 启动后等待该任务通知信号量bgMarkReady再继续</span></span></span><br><span class="line"><span class="function">			<span class="title">notetsleepg</span><span class="params">(&amp;work.bgMarkReady, <span class="number">-1</span>)</span></span></span><br><span class="line"><span class="function">			<span class="title">noteclear</span><span class="params">(&amp;work.bgMarkReady)</span></span></span><br><span class="line"><span class="function">		&#125;</span></span><br><span class="line"><span class="function">	&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="stopTheWorldWithSema"><a href="#stopTheWorldWithSema" class="headerlink" title="stopTheWorldWithSema"></a>stopTheWorldWithSema</h4><p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L987">stopTheWorldWithSema</a>函数会停止整个世界, 这个函数必须在g0中运行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">stopTheWorldWithSema</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line">	<span class="keyword">if</span> _g_.m.locks &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">throw</span>(<span class="string">&quot;stopTheWorld: holding locks&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 需要停止的P数量</span></span><br><span class="line">	sched.stopwait = gomaxprocs</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置gc等待标记, 调度时看见此标记会进入等待</span></span><br><span class="line">	atomic.Store(&amp;sched.gcwaiting, <span class="number">1</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 抢占所有运行中的G</span></span><br><span class="line">	preemptall()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 停止当前的P</span></span><br><span class="line">	<span class="comment">// stop current P</span></span><br><span class="line">	_g_.m.p.ptr().status = _Pgcstop <span class="comment">// Pgcstop is only diagnostic.</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 减少需要停止的P数量(当前的P算一个)</span></span><br><span class="line">	sched.stopwait--</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 抢占所有在Psyscall状态的P, 防止它们重新参与调度</span></span><br><span class="line">	<span class="comment">// try to retake all P&#x27;s in Psyscall status</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(gomaxprocs); i++ &#123;</span><br><span class="line">		p := allp[i]</span><br><span class="line">		s := p.status</span><br><span class="line">		<span class="keyword">if</span> s == _Psyscall &amp;&amp; atomic.Cas(&amp;p.status, s, _Pgcstop) &#123;</span><br><span class="line">			<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">				traceGoSysBlock(p)</span><br><span class="line">				traceProcStop(p)</span><br><span class="line">			&#125;</span><br><span class="line">			p.syscalltick++</span><br><span class="line">			sched.stopwait--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 防止所有空闲的P重新参与调度</span></span><br><span class="line">	<span class="comment">// stop idle P&#x27;s</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		p := pidleget()</span><br><span class="line">		<span class="keyword">if</span> p == nil &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		p.status = _Pgcstop</span><br><span class="line">		sched.stopwait--</span><br><span class="line">	&#125;</span><br><span class="line">	wait := sched.stopwait &gt; <span class="number">0</span></span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果仍有需要停止的P, 则等待它们停止</span></span><br><span class="line">	<span class="comment">// wait for remaining P&#x27;s to stop voluntarily</span></span><br><span class="line">	<span class="keyword">if</span> wait &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// 循环等待 + 抢占所有运行中的G</span></span><br><span class="line">			<span class="comment">// wait for 100us, then try to re-preempt in case of any races</span></span><br><span class="line">			<span class="function"><span class="keyword">if</span> <span class="title">notetsleep</span><span class="params">(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>)</span> </span>&#123;</span><br><span class="line">				noteclear(&amp;sched.stopnote)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			preemptall()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 逻辑正确性检查</span></span><br><span class="line">	<span class="comment">// sanity checks</span></span><br><span class="line">	bad := <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">if</span> sched.stopwait != <span class="number">0</span> &#123;</span><br><span class="line">		bad = <span class="string">&quot;stopTheWorld: not stopped (stopwait != 0)&quot;</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(gomaxprocs); i++ &#123;</span><br><span class="line">			p := allp[i]</span><br><span class="line">			<span class="keyword">if</span> p.status != _Pgcstop &#123;</span><br><span class="line">				bad = <span class="string">&quot;stopTheWorld: not stopped (status != _Pgcstop)&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;freezing) != <span class="number">0</span> &#123;</span><br><span class="line">		lock(&amp;deadlock)</span><br><span class="line">		lock(&amp;deadlock)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> bad != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">throw</span>(bad)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 到这里所有运行中的G都会变为待运行, 并且所有的P都不能被M获取</span></span><br><span class="line">	<span class="comment">// 也就是说所有的go代码(除了当前的)都会停止运行, 并且不能运行新的go代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="finishsweep-m"><a href="#finishsweep-m" class="headerlink" title="finishsweep_m"></a>finishsweep_m</h4><p>finishsweep_m函数会清扫上一轮GC未清扫的span, 确保上一轮GC已完成:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">finishsweep_m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// sweepone会取出一个未sweep的span然后执行sweep</span></span><br><span class="line">	<span class="comment">// 详细将在下面sweep阶段时分析</span></span><br><span class="line">	<span class="function"><span class="keyword">for</span> <span class="title">sweepone</span><span class="params">()</span> !</span>= ^uintptr(<span class="number">0</span>) &#123;</span><br><span class="line">		sweep.npausesweep++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 所有span都sweep完成后, 启动一个新的markbit时代</span></span><br><span class="line">	<span class="comment">// 这个函数是实现span的gcmarkBits和allocBits的分配和复用的关键, 流程如下</span></span><br><span class="line">	<span class="comment">// - span分配gcmarkBits和allocBits</span></span><br><span class="line">	<span class="comment">// - span完成sweep</span></span><br><span class="line">	<span class="comment">//   - 原allocBits不再被使用</span></span><br><span class="line">	<span class="comment">//   - gcmarkBits变为allocBits</span></span><br><span class="line">	<span class="comment">//   - 分配新的gcmarkBits</span></span><br><span class="line">	<span class="comment">// - 开启新的markbit时代</span></span><br><span class="line">	<span class="comment">// - span完成sweep, 同上</span></span><br><span class="line">	<span class="comment">// - 开启新的markbit时代</span></span><br><span class="line">	<span class="comment">//   - 2个时代之前的bitmap将不再被使用, 可以复用这些bitmap</span></span><br><span class="line">	nextMarkBitArenaEpoch()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gcBgMarkPrepare"><a href="#gcBgMarkPrepare" class="headerlink" title="gcBgMarkPrepare"></a>gcBgMarkPrepare</h4><p>gcBgMarkPrepare函数会重置后台标记任务的计数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">gcBgMarkPrepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	work.nproc = ^uint32(<span class="number">0</span>)</span><br><span class="line">	work.nwait = ^uint32(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gcMarkRootPrepare"><a href="#gcMarkRootPrepare" class="headerlink" title="gcMarkRootPrepare"></a>gcMarkRootPrepare</h4><p>函数会计算扫描根对象的任务数量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">gcMarkRootPrepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 释放mcache中的所有span的任务, 只在完成标记阶段(mark termination)中执行</span></span><br><span class="line">	<span class="keyword">if</span> gcphase == _GCmarktermination &#123;</span><br><span class="line">		work.nFlushCacheRoots = <span class="keyword">int</span>(gomaxprocs)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		work.nFlushCacheRoots = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算block数量的函数, rootBlockBytes是256KB</span></span><br><span class="line">	<span class="comment">// Compute how many data and BSS root blocks there are.</span></span><br><span class="line">	nBlocks := func(bytes uintptr) <span class="keyword">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">int</span>((bytes + rootBlockBytes - <span class="number">1</span>) / rootBlockBytes)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	work.nDataRoots = <span class="number">0</span></span><br><span class="line">	work.nBSSRoots = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// data和bss每一轮GC只扫描一次</span></span><br><span class="line">	<span class="comment">// 并行GC中会在后台标记任务中扫描, 完成标记阶段(mark termination)中不扫描</span></span><br><span class="line">	<span class="comment">// 非并行GC会在完成标记阶段(mark termination)中扫描</span></span><br><span class="line">	<span class="comment">// Only scan globals once per cycle; preferably concurrently.</span></span><br><span class="line">	<span class="keyword">if</span> !work.markrootDone &#123;</span><br><span class="line">		<span class="comment">// 计算扫描可读写的全局变量的任务数量</span></span><br><span class="line">		<span class="keyword">for</span> _, datap := <span class="function">range <span class="title">activeModules</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			nDataRoots := nBlocks(datap.edata - datap.data)</span><br><span class="line">			<span class="keyword">if</span> nDataRoots &gt; work.nDataRoots &#123;</span><br><span class="line">				work.nDataRoots = nDataRoots</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 计算扫描只读的全局变量的任务数量</span></span><br><span class="line">		<span class="keyword">for</span> _, datap := <span class="function">range <span class="title">activeModules</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			nBSSRoots := nBlocks(datap.ebss - datap.bss)</span><br><span class="line">			<span class="keyword">if</span> nBSSRoots &gt; work.nBSSRoots &#123;</span><br><span class="line">				work.nBSSRoots = nBSSRoots</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// span中的finalizer和各个G的栈每一轮GC只扫描一次</span></span><br><span class="line">	<span class="comment">// 同上</span></span><br><span class="line">	<span class="keyword">if</span> !work.markrootDone &#123;</span><br><span class="line">		<span class="comment">// 计算扫描span中的finalizer的任务数量</span></span><br><span class="line">		work.nSpanRoots = mheap_.sweepSpans[mheap_.sweepgen/<span class="number">2</span>%<span class="number">2</span>].numBlocks()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 计算扫描各个G的栈的任务数量</span></span><br><span class="line">		work.nStackRoots = <span class="keyword">int</span>(atomic.Loaduintptr(&amp;allglen))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		work.nSpanRoots = <span class="number">0</span></span><br><span class="line">		work.nStackRoots = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> debug.gcrescanstacks &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Scan stacks anyway for debugging.</span></span><br><span class="line">			work.nStackRoots = <span class="keyword">int</span>(atomic.Loaduintptr(&amp;allglen))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算总任务数量</span></span><br><span class="line">	<span class="comment">// 后台标记任务会对markrootNext进行原子递增, 来决定做哪个任务</span></span><br><span class="line">	<span class="comment">// 这种用数值来实现锁自由队列的办法挺聪明的, 尽管google工程师觉得不好(看后面markroot函数的分析)</span></span><br><span class="line">	work.markrootNext = <span class="number">0</span></span><br><span class="line">	work.markrootJobs = uint32(fixedRootCount + work.nFlushCacheRoots + work.nDataRoots + work.nBSSRoots + work.nSpanRoots + work.nStackRoots)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gcMarkTinyAllocs"><a href="#gcMarkTinyAllocs" class="headerlink" title="gcMarkTinyAllocs"></a>gcMarkTinyAllocs</h4><p>函数会标记所有tiny alloc等待合并的对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">gcMarkTinyAllocs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> _, p := range &amp;allp &#123;</span><br><span class="line">		<span class="keyword">if</span> p == nil || p.status == _Pdead &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		c := p.mcache</span><br><span class="line">		<span class="keyword">if</span> c == nil || c.tiny == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 标记各个P中的mcache中的tiny</span></span><br><span class="line">		<span class="comment">// 在上面的mallocgc函数中可以看到tiny是当前等待合并的对象</span></span><br><span class="line">		_, hbits, span, objIndex := heapBitsForObject(c.tiny, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">		gcw := &amp;p.gcw</span><br><span class="line">		<span class="comment">// 标记一个对象存活, 并把它加到标记队列(该对象变为灰色)</span></span><br><span class="line">		greyobject(c.tiny, <span class="number">0</span>, <span class="number">0</span>, hbits, span, gcw, objIndex)</span><br><span class="line">		<span class="comment">// gcBlackenPromptly变量表示当前是否禁止本地队列, 如果已禁止则把标记任务flush到全局队列</span></span><br><span class="line">		<span class="keyword">if</span> gcBlackenPromptly &#123;</span><br><span class="line">			gcw.dispose()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="startTheWorldWithSema"><a href="#startTheWorldWithSema" class="headerlink" title="startTheWorldWithSema"></a>startTheWorldWithSema</h4><p>startTheWorldWithSema函数会重新启动世界:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">startTheWorldWithSema</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 禁止G被抢占</span></span><br><span class="line">	_g_.m.locks++        <span class="comment">// disable preemption because it can be holding p in a local var</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 判断收到的网络事件(fd可读可写或错误)并添加对应的G到待运行队列</span></span><br><span class="line">	gp := netpoll(<span class="keyword">false</span>) <span class="comment">// non-blocking</span></span><br><span class="line">	injectglist(gp)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 判断是否要启动gc helper</span></span><br><span class="line">	add := needaddgcproc()</span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果要求改变gomaxprocs则调整P的数量</span></span><br><span class="line">	<span class="comment">// procresize会返回有可运行任务的P的链表</span></span><br><span class="line">	procs := gomaxprocs</span><br><span class="line">	<span class="keyword">if</span> newprocs != <span class="number">0</span> &#123;</span><br><span class="line">		procs = newprocs</span><br><span class="line">		newprocs = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	p1 := procresize(procs)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取消GC等待标记</span></span><br><span class="line">	sched.gcwaiting = <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果sysmon在等待则唤醒它</span></span><br><span class="line">	<span class="keyword">if</span> sched.sysmonwait != <span class="number">0</span> &#123;</span><br><span class="line">		sched.sysmonwait = <span class="number">0</span></span><br><span class="line">		notewakeup(&amp;sched.sysmonnote)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 唤醒有可运行任务的P</span></span><br><span class="line">	<span class="keyword">for</span> p1 != nil &#123;</span><br><span class="line">		p := p1</span><br><span class="line">		p1 = p1.link.ptr()</span><br><span class="line">		<span class="keyword">if</span> p.m != <span class="number">0</span> &#123;</span><br><span class="line">			mp := p.m.ptr()</span><br><span class="line">			p.m = <span class="number">0</span></span><br><span class="line">			<span class="keyword">if</span> mp.nextp != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">throw</span>(<span class="string">&quot;startTheWorld: inconsistent mp-&gt;nextp&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			mp.nextp.set(p)</span><br><span class="line">			notewakeup(&amp;mp.park)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Start M to run P.  Do not start another M below.</span></span><br><span class="line">			newm(nil, p)</span><br><span class="line">			add = <span class="keyword">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果有空闲的P，并且没有自旋中的M则唤醒或者创建一个M</span></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &#123;</span><br><span class="line">		wakep()</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 启动gc helper</span></span><br><span class="line">	<span class="keyword">if</span> add &#123;</span><br><span class="line">		newm(mhelpgc, nil)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 允许G被抢占</span></span><br><span class="line">	_g_.m.locks--</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果当前G要求被抢占则重新尝试</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.locks == <span class="number">0</span> &amp;&amp; _g_.preempt &#123; <span class="comment">// restore the preemption request in case we&#x27;ve cleared it in newstack</span></span><br><span class="line">		_g_.stackguard0 = stackPreempt</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gcBgMarkWorker"><a href="#gcBgMarkWorker" class="headerlink" title="gcBgMarkWorker"></a>gcBgMarkWorker</h4><p>重启世界后各个M会重新开始调度, 调度时会优先使用上面提到的findRunnableGCWorker函数查找任务, 之后就有大约25%的P运行后台标记任务.<br>后台标记任务的函数是gcBgMarkWorker</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">gcBgMarkWorker</span><span class="params">(_p_ *p)</span> </span>&#123;</span><br><span class="line">	gp := getg()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 用于休眠后重新获取P的构造体</span></span><br><span class="line">	type parkInfo struct &#123;</span><br><span class="line">		m      muintptr <span class="comment">// Release this m on park.</span></span><br><span class="line">		attach puintptr <span class="comment">// If non-nil, attach to this p on park.</span></span><br><span class="line">	&#125;</span><br><span class="line">	gp.m.preemptoff = <span class="string">&quot;GC worker init&quot;</span></span><br><span class="line">	park := <span class="keyword">new</span>(parkInfo)</span><br><span class="line">	gp.m.preemptoff = <span class="string">&quot;&quot;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置当前的M并禁止抢占</span></span><br><span class="line">	park.m.set(acquirem())</span><br><span class="line">	<span class="comment">// 设置当前的P(需要关联到的P)</span></span><br><span class="line">	park.attach.set(_p_)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 通知gcBgMarkStartWorkers可以继续处理</span></span><br><span class="line">	notewakeup(&amp;work.bgMarkReady)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 让当前G进入休眠</span></span><br><span class="line">		gopark(func(g *g, parkp unsafe.Pointer) bool &#123;</span><br><span class="line">			park := (*parkInfo)(parkp)</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 重新允许抢占</span></span><br><span class="line">			releasem(park.m.ptr())</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 设置关联的P</span></span><br><span class="line">			<span class="comment">// 把当前的G设到P的gcBgMarkWorker成员, 下次findRunnableGCWorker会使用</span></span><br><span class="line">			<span class="comment">// 设置失败时不休眠</span></span><br><span class="line">			<span class="keyword">if</span> park.attach != <span class="number">0</span> &#123;</span><br><span class="line">				p := park.attach.ptr()</span><br><span class="line">				park.attach.set(nil)</span><br><span class="line">				<span class="keyword">if</span> !p.gcBgMarkWorker.cas(<span class="number">0</span>, guintptr(unsafe.Pointer(g))) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">		&#125;, unsafe.Pointer(park), <span class="string">&quot;GC worker (idle)&quot;</span>, traceEvGoBlock, <span class="number">0</span>)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 检查P的gcBgMarkWorker是否和当前的G一致, 不一致时结束当前的任务</span></span><br><span class="line">		<span class="keyword">if</span> _p_.gcBgMarkWorker.ptr() != gp &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 禁止G被抢占</span></span><br><span class="line">		park.m.set(acquirem())</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> gcBlackenEnabled == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span>(<span class="string">&quot;gcBgMarkWorker: blackening not enabled&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 记录开始时间</span></span><br><span class="line">		startTime := nanotime()</span><br><span class="line">		</span><br><span class="line">		decnwait := atomic.Xadd(&amp;work.nwait, -<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> decnwait == work.nproc &#123;</span><br><span class="line">			println(<span class="string">&quot;runtime: work.nwait=&quot;</span>, decnwait, <span class="string">&quot;work.nproc=&quot;</span>, work.nproc)</span><br><span class="line">			<span class="keyword">throw</span>(<span class="string">&quot;work.nwait was &gt; work.nproc&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 切换到g0运行</span></span><br><span class="line">		systemstack(func() &#123;</span><br><span class="line">			<span class="comment">// 设置G的状态为等待中这样它的栈可以被扫描(两个后台标记任务可以互相扫描对方的栈)</span></span><br><span class="line">			casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 判断后台标记任务的模式</span></span><br><span class="line">			<span class="keyword">switch</span> _p_.gcMarkWorkerMode &#123;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">throw</span>(<span class="string">&quot;gcBgMarkWorker: unexpected gcMarkWorkerMode&quot;</span>)</span><br><span class="line">			<span class="keyword">case</span> gcMarkWorkerDedicatedMode:</span><br><span class="line">				<span class="comment">// 这个模式下P应该专心执行标记</span></span><br><span class="line">				<span class="comment">// 执行标记, 直到被抢占, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G</span></span><br><span class="line">				gcDrain(&amp;_p_.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">				<span class="comment">// 被抢占时把本地运行队列中的所有G都踢到全局运行队列</span></span><br><span class="line">				<span class="keyword">if</span> gp.preempt &#123;</span><br><span class="line">					lock(&amp;sched.lock)</span><br><span class="line">					<span class="keyword">for</span> &#123;</span><br><span class="line">						gp, _ := runqget(_p_)</span><br><span class="line">						<span class="keyword">if</span> gp == nil &#123;</span><br><span class="line">							<span class="keyword">break</span></span><br><span class="line">						&#125;</span><br><span class="line">						globrunqput(gp)</span><br><span class="line">					&#125;</span><br><span class="line">					unlock(&amp;sched.lock)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 继续执行标记, 直到无更多任务, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G</span></span><br><span class="line">				<span class="comment">// Go back to draining, this time</span></span><br><span class="line">				<span class="comment">// without preemption.</span></span><br><span class="line">				gcDrain(&amp;_p_.gcw, gcDrainNoBlock|gcDrainFlushBgCredit)</span><br><span class="line">			<span class="keyword">case</span> gcMarkWorkerFractionalMode:</span><br><span class="line">				<span class="comment">// 这个模式下P应该适当执行标记</span></span><br><span class="line">				<span class="comment">// 执行标记, 直到被抢占, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G</span></span><br><span class="line">				gcDrain(&amp;_p_.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">			<span class="keyword">case</span> gcMarkWorkerIdleMode:</span><br><span class="line">				<span class="comment">// 这个模式下P只在空闲时执行标记</span></span><br><span class="line">				<span class="comment">// 执行标记, 直到被抢占或者达到一定的量, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G</span></span><br><span class="line">				gcDrain(&amp;_p_.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 恢复G的状态到运行中</span></span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">		&#125;)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果标记了禁止本地标记队列则flush到全局标记队列</span></span><br><span class="line">		<span class="keyword">if</span> gcBlackenPromptly &#123;</span><br><span class="line">			_p_.gcw.dispose()</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 累加所用时间</span></span><br><span class="line">		duration := nanotime() - startTime</span><br><span class="line">		<span class="keyword">switch</span> _p_.gcMarkWorkerMode &#123;</span><br><span class="line">		<span class="keyword">case</span> gcMarkWorkerDedicatedMode:</span><br><span class="line">			atomic.Xaddint64(&amp;gcController.dedicatedMarkTime, duration)</span><br><span class="line">			atomic.Xaddint64(&amp;gcController.dedicatedMarkWorkersNeeded, <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">case</span> gcMarkWorkerFractionalMode:</span><br><span class="line">			atomic.Xaddint64(&amp;gcController.fractionalMarkTime, duration)</span><br><span class="line">			atomic.Xaddint64(&amp;gcController.fractionalMarkWorkersNeeded, <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">case</span> gcMarkWorkerIdleMode:</span><br><span class="line">			atomic.Xaddint64(&amp;gcController.idleMarkTime, duration)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		incnwait := atomic.Xadd(&amp;work.nwait, +<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> incnwait &gt; work.nproc &#123;</span><br><span class="line">			println(<span class="string">&quot;runtime: p.gcMarkWorkerMode=&quot;</span>, _p_.gcMarkWorkerMode,</span><br><span class="line">				<span class="string">&quot;work.nwait=&quot;</span>, incnwait, <span class="string">&quot;work.nproc=&quot;</span>, work.nproc)</span><br><span class="line">			<span class="keyword">throw</span>(<span class="string">&quot;work.nwait &gt; work.nproc&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 判断是否所有后台标记任务都完成, 并且没有更多的任务</span></span><br><span class="line">		<span class="keyword">if</span> incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(nil) &#123;</span><br><span class="line">			<span class="comment">// 取消和P的关联</span></span><br><span class="line">			_p_.gcBgMarkWorker.set(nil)</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 允许G被抢占</span></span><br><span class="line">			releasem(park.m.ptr())</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 准备进入完成标记阶段</span></span><br><span class="line">			gcMarkDone()</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 休眠之前会重新关联P</span></span><br><span class="line">			<span class="comment">// 因为上面允许被抢占, 到这里的时候可能就会变成其他P</span></span><br><span class="line">			<span class="comment">// 如果重新关联P失败则这个任务会结束</span></span><br><span class="line">			park.m.set(acquirem())</span><br><span class="line">			park.attach.set(_p_)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gcDrain"><a href="#gcDrain" class="headerlink" title="gcDrain"></a>gcDrain</h4><p>函数用于执行标记:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">gcDrain</span><span class="params">(gcw *gcWork, flags gcDrainFlags)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> !writeBarrier.needed &#123;</span><br><span class="line">		<span class="keyword">throw</span>(<span class="string">&quot;gcDrain phase incorrect&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	gp := getg().m.curg</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 看到抢占标志时是否要返回</span></span><br><span class="line">	preemptible := flags&amp;gcDrainUntilPreempt != <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 没有任务时是否要等待任务</span></span><br><span class="line">	blocking := flags&amp;(gcDrainUntilPreempt|gcDrainIdle|gcDrainNoBlock) == <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 是否计算后台的扫描量来减少辅助GC和唤醒等待中的G</span></span><br><span class="line">	flushBgCredit := flags&amp;gcDrainFlushBgCredit != <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 是否只执行一定量的工作</span></span><br><span class="line">	idle := flags&amp;gcDrainIdle != <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 记录初始的已扫描数量</span></span><br><span class="line">	initScanWork := gcw.scanWork</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 扫描idleCheckThreshold(100000)个对象以后检查是否要返回</span></span><br><span class="line">	idleCheck := initScanWork + idleCheckThreshold</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果根对象未扫描完, 则先扫描根对象</span></span><br><span class="line">	<span class="comment">// Drain root marking jobs.</span></span><br><span class="line">	<span class="keyword">if</span> work.markrootNext &lt; work.markrootJobs &#123;</span><br><span class="line">		<span class="comment">// 如果标记了preemptible, 循环直到被抢占</span></span><br><span class="line">		<span class="keyword">for</span> !(preemptible &amp;&amp; gp.preempt) &#123;</span><br><span class="line">			<span class="comment">// 从根对象扫描队列取出一个值(原子递增)</span></span><br><span class="line">			job := atomic.Xadd(&amp;work.markrootNext, +<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> job &gt;= work.markrootJobs &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 执行根对象扫描工作</span></span><br><span class="line">			markroot(gcw, job)</span><br><span class="line">			<span class="comment">// 如果是idle模式并且有其他工作, 则返回</span></span><br><span class="line">			<span class="keyword">if</span> idle &amp;&amp; pollWork() &#123;</span><br><span class="line">				goto done</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 根对象已经在标记队列中, 消费标记队列</span></span><br><span class="line">	<span class="comment">// 如果标记了preemptible, 循环直到被抢占</span></span><br><span class="line">	<span class="comment">// Drain heap marking jobs.</span></span><br><span class="line">	<span class="keyword">for</span> !(preemptible &amp;&amp; gp.preempt) &#123;</span><br><span class="line">		<span class="comment">// 如果全局标记队列为空, 把本地标记队列的一部分工作分过去</span></span><br><span class="line">		<span class="comment">// (如果wbuf2不为空则移动wbuf2过去, 否则移动wbuf1的一半过去)</span></span><br><span class="line">		<span class="keyword">if</span> work.full == <span class="number">0</span> &#123;</span><br><span class="line">			gcw.balance()</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 从本地标记队列中获取对象, 获取不到则从全局标记队列获取</span></span><br><span class="line">		<span class="keyword">var</span> b uintptr</span><br><span class="line">		<span class="keyword">if</span> blocking &#123;</span><br><span class="line">			<span class="comment">// 阻塞获取</span></span><br><span class="line">			b = gcw.get()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 非阻塞获取</span></span><br><span class="line">			b = gcw.tryGetFast()</span><br><span class="line">			<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">				b = gcw.tryGet()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 获取不到对象, 标记队列已为空, 跳出循环</span></span><br><span class="line">		<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// work barrier reached or tryGet failed.</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 扫描获取到的对象</span></span><br><span class="line">		scanobject(b, gcw)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果已经扫描了一定数量的对象(gcCreditSlack的值是2000)</span></span><br><span class="line">		<span class="keyword">if</span> gcw.scanWork &gt;= gcCreditSlack &#123;</span><br><span class="line">			<span class="comment">// 把扫描的对象数量添加到全局</span></span><br><span class="line">			atomic.Xaddint64(&amp;gcController.scanWork, gcw.scanWork)</span><br><span class="line">			<span class="comment">// 减少辅助GC的工作量和唤醒等待中的G</span></span><br><span class="line">			<span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">				gcFlushBgCredit(gcw.scanWork - initScanWork)</span><br><span class="line">				initScanWork = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">			idleCheck -= gcw.scanWork</span><br><span class="line">			gcw.scanWork = <span class="number">0</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 如果是idle模式且达到了检查的扫描量, 则检查是否有其他任务(G), 如果有则跳出循环</span></span><br><span class="line">			<span class="keyword">if</span> idle &amp;&amp; idleCheck &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				idleCheck += idleCheckThreshold</span><br><span class="line">				<span class="function"><span class="keyword">if</span> <span class="title">pollWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">done:</span><br><span class="line">	<span class="comment">// 把扫描的对象数量添加到全局</span></span><br><span class="line">	<span class="comment">// Flush remaining scan work credit.</span></span><br><span class="line">	<span class="keyword">if</span> gcw.scanWork &gt; <span class="number">0</span> &#123;</span><br><span class="line">		atomic.Xaddint64(&amp;gcController.scanWork, gcw.scanWork)</span><br><span class="line">		<span class="comment">// 减少辅助GC的工作量和唤醒等待中的G</span></span><br><span class="line">		<span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">			gcFlushBgCredit(gcw.scanWork - initScanWork)</span><br><span class="line">		&#125;</span><br><span class="line">		gcw.scanWork = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="markroot"><a href="#markroot" class="headerlink" title="markroot"></a>markroot</h4><p>markroot 函数用于执行根对象扫描工作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">markroot</span><span class="params">(gcw *gcWork, i uint32)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 判断取出的数值对应哪种任务</span></span><br><span class="line">	<span class="comment">// (google的工程师觉得这种办法可笑)</span></span><br><span class="line">	baseFlushCache := uint32(fixedRootCount)</span><br><span class="line">	baseData := baseFlushCache + uint32(work.nFlushCacheRoots)</span><br><span class="line">	baseBSS := baseData + uint32(work.nDataRoots)</span><br><span class="line">	baseSpans := baseBSS + uint32(work.nBSSRoots)</span><br><span class="line">	baseStacks := baseSpans + uint32(work.nSpanRoots)</span><br><span class="line">	end := baseStacks + uint32(work.nStackRoots)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="comment">// 释放mcache中的所有span, 要求STW</span></span><br><span class="line">	<span class="keyword">case</span> baseFlushCache &lt;= i &amp;&amp; i &lt; baseData:</span><br><span class="line">		flushmcache(<span class="keyword">int</span>(i - baseFlushCache))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 扫描可读写的全局变量</span></span><br><span class="line">	<span class="comment">// 这里只会扫描i对应的block, 扫描时传入包含哪里有指针的bitmap数据</span></span><br><span class="line">	<span class="keyword">case</span> baseData &lt;= i &amp;&amp; i &lt; baseBSS:</span><br><span class="line">		<span class="keyword">for</span> _, datap := <span class="function">range <span class="title">activeModules</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			markrootBlock(datap.data, datap.edata-datap.data, datap.gcdatamask.bytedata, gcw, <span class="keyword">int</span>(i-baseData))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 扫描只读的全局变量</span></span><br><span class="line">	<span class="comment">// 这里只会扫描i对应的block, 扫描时传入包含哪里有指针的bitmap数据</span></span><br><span class="line">	<span class="keyword">case</span> baseBSS &lt;= i &amp;&amp; i &lt; baseSpans:</span><br><span class="line">		<span class="keyword">for</span> _, datap := <span class="function">range <span class="title">activeModules</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			markrootBlock(datap.bss, datap.ebss-datap.bss, datap.gcbssmask.bytedata, gcw, <span class="keyword">int</span>(i-baseBSS))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 扫描析构器队列</span></span><br><span class="line">	<span class="keyword">case</span> i == fixedRootFinalizers:</span><br><span class="line">		<span class="keyword">if</span> work.markrootDone &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> fb := allfin; fb != nil; fb = fb.alllink &#123;</span><br><span class="line">			cnt := uintptr(atomic.Load(&amp;fb.cnt))</span><br><span class="line">			scanblock(uintptr(unsafe.Pointer(&amp;fb.fin[<span class="number">0</span>])), cnt*unsafe.Sizeof(fb.fin[<span class="number">0</span>]), &amp;finptrmask[<span class="number">0</span>], gcw)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放已中止的G的栈</span></span><br><span class="line">	<span class="keyword">case</span> i == fixedRootFreeGStacks:</span><br><span class="line">		<span class="keyword">if</span> !work.markrootDone &#123;</span><br><span class="line">			systemstack(markrootFreeGStacks)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 扫描各个span中特殊对象(析构器列表)</span></span><br><span class="line">	<span class="keyword">case</span> baseSpans &lt;= i &amp;&amp; i &lt; baseStacks:</span><br><span class="line">		<span class="comment">// mark MSpan.specials</span></span><br><span class="line">		markrootSpans(gcw, <span class="keyword">int</span>(i-baseSpans))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 扫描各个G的栈</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// 获取需要扫描的G</span></span><br><span class="line">		<span class="keyword">var</span> gp *g</span><br><span class="line">		<span class="keyword">if</span> baseStacks &lt;= i &amp;&amp; i &lt; end &#123;</span><br><span class="line">			gp = allgs[i-baseStacks]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span>(<span class="string">&quot;markroot: bad index&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 记录等待开始的时间</span></span><br><span class="line">		<span class="keyword">if</span> (status == _Gwaiting || status == _Gsyscall) &amp;&amp; gp.waitsince == <span class="number">0</span> &#123;</span><br><span class="line">			gp.waitsince = work.tstart</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 切换到g0运行(有可能会扫到自己的栈)</span></span><br><span class="line">		systemstack(func() &#123;</span><br><span class="line">			<span class="comment">// 判断扫描的栈是否自己的</span></span><br><span class="line">			userG := getg().m.curg</span><br><span class="line">			selfScan := gp == userG &amp;&amp; readgstatus(userG) == _Grunning</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 如果正在扫描自己的栈则切换状态到等待中防止死锁</span></span><br><span class="line">			<span class="keyword">if</span> selfScan &#123;</span><br><span class="line">				casgstatus(userG, _Grunning, _Gwaiting)</span><br><span class="line">				userG.waitreason = <span class="string">&quot;garbage collection scan&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 扫描G的栈</span></span><br><span class="line">			scang(gp, gcw)</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 如果正在扫描自己的栈则把状态切换回运行中</span></span><br><span class="line">			<span class="keyword">if</span> selfScan &#123;</span><br><span class="line">				casgstatus(userG, _Gwaiting, _Grunning)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="scang"><a href="#scang" class="headerlink" title="scang"></a>scang</h4><p>scang函数负责扫描G的栈:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">scang</span><span class="params">(gp *g, gcw *gcWork)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 标记扫描未完成</span></span><br><span class="line">	gp.gcscandone = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> yieldDelay = <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">	<span class="keyword">var</span> nextYield int64</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环直到扫描完成</span></span><br><span class="line">loop:</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; !gp.gcscandone; i++ &#123;</span><br><span class="line">		<span class="comment">// 判断G的当前状态</span></span><br><span class="line">		<span class="keyword">switch</span> s := readgstatus(gp); s &#123;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			dumpgstatus(gp)</span><br><span class="line">			<span class="keyword">throw</span>(<span class="string">&quot;stopg: invalid status&quot;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// G已中止, 不需要扫描它</span></span><br><span class="line">		<span class="keyword">case</span> _Gdead:</span><br><span class="line">			<span class="comment">// No stack.</span></span><br><span class="line">			gp.gcscandone = <span class="keyword">true</span></span><br><span class="line">			<span class="keyword">break</span> loop</span><br><span class="line"></span><br><span class="line">		<span class="comment">// G的栈正在扩展, 下一轮重试</span></span><br><span class="line">		<span class="keyword">case</span> _Gcopystack:</span><br><span class="line">		<span class="comment">// Stack being switched. Go around again.</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// G不是运行中, 首先需要防止它运行</span></span><br><span class="line">		<span class="keyword">case</span> _Grunnable, _Gsyscall, _Gwaiting:</span><br><span class="line">			<span class="function"><span class="keyword">if</span> <span class="title">castogscanstatus</span><span class="params">(gp, s, s|_Gscan)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// 原子切换状态成功时扫描它的栈</span></span><br><span class="line">				<span class="keyword">if</span> !gp.gcscandone &#123;</span><br><span class="line">					scanstack(gp, gcw)</span><br><span class="line">					gp.gcscandone = <span class="keyword">true</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 恢复G的状态, 并跳出循环</span></span><br><span class="line">				restartg(gp)</span><br><span class="line">				<span class="keyword">break</span> loop</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// G正在扫描它自己, 等待扫描完毕</span></span><br><span class="line">		<span class="keyword">case</span> _Gscanwaiting:</span><br><span class="line">		<span class="comment">// newstack is doing a scan for us right now. Wait.</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// G正在运行</span></span><br><span class="line">		<span class="keyword">case</span> _Grunning:</span><br><span class="line">			<span class="comment">// 如果已经有抢占请求, 则抢占成功时会帮我们处理</span></span><br><span class="line">			<span class="keyword">if</span> gp.preemptscan &amp;&amp; gp.preempt &amp;&amp; gp.stackguard0 == stackPreempt &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 抢占G, 抢占成功时G会扫描它自己</span></span><br><span class="line">			<span class="comment">// Ask for preemption and self scan.</span></span><br><span class="line">			<span class="function"><span class="keyword">if</span> <span class="title">castogscanstatus</span><span class="params">(gp, _Grunning, _Gscanrunning)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> !gp.gcscandone &#123;</span><br><span class="line">					gp.preemptscan = <span class="keyword">true</span></span><br><span class="line">					gp.preempt = <span class="keyword">true</span></span><br><span class="line">					gp.stackguard0 = stackPreempt</span><br><span class="line">				&#125;</span><br><span class="line">				casfrom_Gscanstatus(gp, _Gscanrunning, _Grunning)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第一轮休眠10毫秒, 第二轮休眠5毫秒</span></span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">			nextYield = nanotime() + yieldDelay</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">if</span> <span class="title">nanotime</span><span class="params">()</span> &lt; nextYield </span>&#123;</span><br><span class="line">			procyield(<span class="number">10</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			osyield()</span><br><span class="line">			nextYield = nanotime() + yieldDelay/<span class="number">2</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 扫描完成, 取消抢占扫描的请求</span></span><br><span class="line">	gp.preemptscan = <span class="keyword">false</span> <span class="comment">// cancel scan request if no longer needed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gcMarkDone"><a href="#gcMarkDone" class="headerlink" title="gcMarkDone"></a>gcMarkDone</h4><p>在所有后台标记任务都把标记队列消费完毕时, 会执行gcMarkDone函数准备进入完成标记阶段(mark termination):<br>在并行GC中gcMarkDone会被执行两次, 第一次会禁止本地标记队列然后重新开始后台标记任务, 第二次会进入完成标记阶段(mark termination)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">gcMarkDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">top:</span><br><span class="line">	semacquire(&amp;work.markDoneSema)</span><br><span class="line">	<span class="keyword">if</span> !(gcphase == _GCmark &amp;&amp; work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(nil)) &#123;</span><br><span class="line">		semrelease(&amp;work.markDoneSema)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 暂时禁止启动新的后台标记任务</span></span><br><span class="line">	atomic.Xaddint64(&amp;gcController.dedicatedMarkWorkersNeeded, -<span class="number">0xffffffff</span>)</span><br><span class="line">	atomic.Xaddint64(&amp;gcController.fractionalMarkWorkersNeeded, -<span class="number">0xffffffff</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断本地标记队列是否已禁用</span></span><br><span class="line">	<span class="keyword">if</span> !gcBlackenPromptly &#123;</span><br><span class="line">		<span class="comment">// 本地标记队列是否未禁用, 禁用然后重新开始后台标记任务</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 禁用本地标记队列</span></span><br><span class="line">		gcBlackenPromptly = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">		atomic.Xadd(&amp;work.nwait, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		semrelease(&amp;work.markDoneSema)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 把所有本地标记队列中的对象都推到全局标记队列</span></span><br><span class="line">		systemstack(func() &#123;</span><br><span class="line">			forEachP(func(_p_ *p) &#123;</span><br><span class="line">				_p_.gcw.dispose()</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 除错用</span></span><br><span class="line">		gcMarkRootCheck()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 允许启动新的后台标记任务</span></span><br><span class="line">		atomic.Xaddint64(&amp;gcController.dedicatedMarkWorkersNeeded, <span class="number">0xffffffff</span>)</span><br><span class="line">		atomic.Xaddint64(&amp;gcController.fractionalMarkWorkersNeeded, <span class="number">0xffffffff</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果确定没有更多的任务则可以直接跳到函数顶部</span></span><br><span class="line">		<span class="comment">// 这样就当作是第二次调用了</span></span><br><span class="line">		incnwait := atomic.Xadd(&amp;work.nwait, +<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(nil) &#123;</span><br><span class="line">			goto top</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 记录完成标记阶段开始的时间和STW开始的时间</span></span><br><span class="line">		now := nanotime()</span><br><span class="line">		work.tMarkTerm = now</span><br><span class="line">		work.pauseStart = now</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 禁止G被抢占</span></span><br><span class="line">		getg().m.preemptoff = <span class="string">&quot;gcing&quot;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 停止所有运行中的G, 并禁止它们运行</span></span><br><span class="line">		systemstack(stopTheWorldWithSema)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// !!!!!!!!!!!!!!!!</span></span><br><span class="line">		<span class="comment">// 世界已停止(STW)...</span></span><br><span class="line">		<span class="comment">// !!!!!!!!!!!!!!!!</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 标记对根对象的扫描已完成, 会影响gcMarkRootPrepare中的处理</span></span><br><span class="line">		work.markrootDone = <span class="keyword">true</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 禁止辅助GC和后台标记任务的运行</span></span><br><span class="line">		atomic.Store(&amp;gcBlackenEnabled, <span class="number">0</span>)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 唤醒所有因为辅助GC而休眠的G</span></span><br><span class="line">		gcWakeAllAssists()</span><br><span class="line">		semrelease(&amp;work.markDoneSema)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 计算下一次触发gc需要的heap大小</span></span><br><span class="line">		nextTriggerRatio := gcController.endCycle()</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 进入完成标记阶段, 会重新启动世界</span></span><br><span class="line">		gcMarkTermination(nextTriggerRatio)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gcMarkTermination"><a href="#gcMarkTermination" class="headerlink" title="gcMarkTermination"></a>gcMarkTermination</h4><p>gcMarkTermination函数会进入完成标记阶段:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">gcMarkTermination</span><span class="params">(nextTriggerRatio float64)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// World is stopped.</span></span><br><span class="line">	<span class="comment">// Start marktermination which includes enabling the write barrier.</span></span><br><span class="line">	<span class="comment">// 禁止辅助GC和后台标记任务的运行</span></span><br><span class="line">	atomic.Store(&amp;gcBlackenEnabled, <span class="number">0</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 重新允许本地标记队列(下次GC使用)</span></span><br><span class="line">	gcBlackenPromptly = <span class="keyword">false</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置当前GC阶段到完成标记阶段, 并启用写屏障</span></span><br><span class="line">	setGCPhase(_GCmarktermination)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录开始时间</span></span><br><span class="line">	work.heap1 = memstats.heap_live</span><br><span class="line">	startTime := nanotime()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 禁止G被抢占</span></span><br><span class="line">	mp := acquirem()</span><br><span class="line">	mp.preemptoff = <span class="string">&quot;gcing&quot;</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line">	_g_.m.traceback = <span class="number">2</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置G的状态为等待中这样它的栈可以被扫描</span></span><br><span class="line">	gp := _g_.m.curg</span><br><span class="line">	casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">	gp.waitreason = <span class="string">&quot;garbage collection&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 切换到g0运行</span></span><br><span class="line">	systemstack(func() &#123;</span><br><span class="line">		<span class="comment">// 开始STW中的标记</span></span><br><span class="line">		gcMark(startTime)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 必须立刻返回, 因为外面的G的栈有可能被移动, 不能在这之后访问外面的变量</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新切换到g0运行</span></span><br><span class="line">	systemstack(func() &#123;</span><br><span class="line">		work.heap2 = work.bytesMarked</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果启用了checkmark则执行检查, 检查是否所有可到达的对象都有标记</span></span><br><span class="line">		<span class="keyword">if</span> debug.gccheckmark &gt; <span class="number">0</span> &#123;</span><br><span class="line">			gcResetMarkState()</span><br><span class="line">			initCheckmarks()</span><br><span class="line">			gcMark(startTime)</span><br><span class="line">			clearCheckmarks()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置当前GC阶段到关闭, 并禁用写屏障</span></span><br><span class="line">		<span class="comment">// marking is complete so we can turn the write barrier off</span></span><br><span class="line">		setGCPhase(_GCoff)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 唤醒后台清扫任务, 将在STW结束后开始运行</span></span><br><span class="line">		gcSweep(work.mode)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 除错用</span></span><br><span class="line">		<span class="keyword">if</span> debug.gctrace &gt; <span class="number">1</span> &#123;</span><br><span class="line">			startTime = nanotime()</span><br><span class="line">			gcResetMarkState()</span><br><span class="line">			finishsweep_m()</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Still in STW but gcphase is _GCoff, reset to _GCmarktermination</span></span><br><span class="line">			<span class="comment">// At this point all objects will be found during the gcMark which</span></span><br><span class="line">			<span class="comment">// does a complete STW mark and object scan.</span></span><br><span class="line">			setGCPhase(_GCmarktermination)</span><br><span class="line">			gcMark(startTime)</span><br><span class="line">			setGCPhase(_GCoff) <span class="comment">// marking is done, turn off wb.</span></span><br><span class="line">			gcSweep(work.mode)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置G的状态为运行中</span></span><br><span class="line">	_g_.m.traceback = <span class="number">0</span></span><br><span class="line">	casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 跟踪处理</span></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGCDone()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// all done</span></span><br><span class="line">	mp.preemptoff = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">		<span class="keyword">throw</span>(<span class="string">&quot;gc done but gcphase != _GCoff&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新下一次触发gc需要的heap大小(gc_trigger)</span></span><br><span class="line">	gcSetTriggerRatio(nextTriggerRatio)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新用时记录</span></span><br><span class="line">	<span class="comment">// Update timing memstats</span></span><br><span class="line">	now := nanotime()</span><br><span class="line">	sec, nsec, _ := time_now()</span><br><span class="line">	unixNow := sec*<span class="number">1e9</span> + int64(nsec)</span><br><span class="line">	work.pauseNS += now - work.pauseStart</span><br><span class="line">	work.tEnd = now</span><br><span class="line">	atomic.Store64(&amp;memstats.last_gc_unix, uint64(unixNow)) <span class="comment">// must be Unix time to make sense to user</span></span><br><span class="line">	atomic.Store64(&amp;memstats.last_gc_nanotime, uint64(now)) <span class="comment">// monotonic time for us</span></span><br><span class="line">	memstats.pause_ns[memstats.numgc%uint32(len(memstats.pause_ns))] = uint64(work.pauseNS)</span><br><span class="line">	memstats.pause_end[memstats.numgc%uint32(len(memstats.pause_end))] = uint64(unixNow)</span><br><span class="line">	memstats.pause_total_ns += uint64(work.pauseNS)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新所用cpu记录</span></span><br><span class="line">	sweepTermCpu := int64(work.stwprocs) * (work.tMark - work.tSweepTerm)</span><br><span class="line">	markCpu := gcController.assistTime + gcController.dedicatedMarkTime + gcController.fractionalMarkTime</span><br><span class="line">	markTermCpu := int64(work.stwprocs) * (work.tEnd - work.tMarkTerm)</span><br><span class="line">	cycleCpu := sweepTermCpu + markCpu + markTermCpu</span><br><span class="line">	work.totaltime += cycleCpu</span><br><span class="line"></span><br><span class="line">	totalCpu := sched.totaltime + (now-sched.procresizetime)*int64(gomaxprocs)</span><br><span class="line">	memstats.gc_cpu_fraction = float64(work.totaltime) / float64(totalCpu)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置清扫状态</span></span><br><span class="line">	<span class="comment">// Reset sweep state.</span></span><br><span class="line">	sweep.nbgsweep = <span class="number">0</span></span><br><span class="line">	sweep.npausesweep = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 统计强制开始GC的次数</span></span><br><span class="line">	<span class="keyword">if</span> work.userForced &#123;</span><br><span class="line">		memstats.numforcedgc++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 统计执行GC的次数然后唤醒等待清扫的G</span></span><br><span class="line">	lock(&amp;work.sweepWaiters.lock)</span><br><span class="line">	memstats.numgc++</span><br><span class="line">	injectglist(work.sweepWaiters.head.ptr())</span><br><span class="line">	work.sweepWaiters.head = <span class="number">0</span></span><br><span class="line">	unlock(&amp;work.sweepWaiters.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 性能统计用</span></span><br><span class="line">	mProf_NextCycle()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新启动世界</span></span><br><span class="line">	systemstack(startTheWorldWithSema)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// !!!!!!!!!!!!!!!</span></span><br><span class="line">	<span class="comment">// 世界已重新启动...</span></span><br><span class="line">	<span class="comment">// !!!!!!!!!!!!!!!</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 性能统计用</span></span><br><span class="line">	mProf_Flush()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动标记队列使用的缓冲区到自由列表, 使得它们可以被回收</span></span><br><span class="line">	prepareFreeWorkbufs()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放未使用的栈</span></span><br><span class="line">	systemstack(freeStackSpans)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 除错用</span></span><br><span class="line">	<span class="keyword">if</span> debug.gctrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">		util := <span class="keyword">int</span>(memstats.gc_cpu_fraction * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> sbuf [<span class="number">24</span>]<span class="keyword">byte</span></span><br><span class="line">		printlock()</span><br><span class="line">		print(<span class="string">&quot;gc &quot;</span>, memstats.numgc,</span><br><span class="line">			<span class="string">&quot; @&quot;</span>, string(itoaDiv(sbuf[:], uint64(work.tSweepTerm-runtimeInitTime)/<span class="number">1e6</span>, <span class="number">3</span>)), <span class="string">&quot;s &quot;</span>,</span><br><span class="line">			util, <span class="string">&quot;%: &quot;</span>)</span><br><span class="line">		prev := work.tSweepTerm</span><br><span class="line">		<span class="keyword">for</span> i, ns := range []int64&#123;work.tMark, work.tMarkTerm, work.tEnd&#125; &#123;</span><br><span class="line">			<span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">				print(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			print(string(fmtNSAsMS(sbuf[:], uint64(ns-prev))))</span><br><span class="line">			prev = ns</span><br><span class="line">		&#125;</span><br><span class="line">		print(<span class="string">&quot; ms clock, &quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> i, ns := range []int64&#123;sweepTermCpu, gcController.assistTime, gcController.dedicatedMarkTime + gcController.fractionalMarkTime, gcController.idleMarkTime, markTermCpu&#125; &#123;</span><br><span class="line">			<span class="keyword">if</span> i == <span class="number">2</span> || i == <span class="number">3</span> &#123;</span><br><span class="line">				<span class="comment">// Separate mark time components with /.</span></span><br><span class="line">				print(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">				print(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			print(string(fmtNSAsMS(sbuf[:], uint64(ns))))</span><br><span class="line">		&#125;</span><br><span class="line">		print(<span class="string">&quot; ms cpu, &quot;</span>,</span><br><span class="line">			work.heap0&gt;&gt;<span class="number">20</span>, <span class="string">&quot;-&gt;&quot;</span>, work.heap1&gt;&gt;<span class="number">20</span>, <span class="string">&quot;-&gt;&quot;</span>, work.heap2&gt;&gt;<span class="number">20</span>, <span class="string">&quot; MB, &quot;</span>,</span><br><span class="line">			work.heapGoal&gt;&gt;<span class="number">20</span>, <span class="string">&quot; MB goal, &quot;</span>,</span><br><span class="line">			work.maxprocs, <span class="string">&quot; P&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> work.userForced &#123;</span><br><span class="line">			print(<span class="string">&quot; (forced)&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		print(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		printunlock()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	semrelease(&amp;worldsema)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新允许当前的G被抢占</span></span><br><span class="line">	releasem(mp)</span><br><span class="line">	mp = nil</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果是并行GC, 让当前M继续运行(会回到gcBgMarkWorker然后休眠)</span></span><br><span class="line">	<span class="comment">// 如果不是并行GC, 则让当前M开始调度</span></span><br><span class="line">	<span class="keyword">if</span> !concurrentSweep &#123;</span><br><span class="line">		Gosched()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gcSweep"><a href="#gcSweep" class="headerlink" title="gcSweep"></a>gcSweep</h4><p>函数会唤醒后台清扫任务:<br>后台清扫任务会在程序启动时调用的<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L214">gcenable</a>函数中启动.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">gcSweep</span><span class="params">(mode gcMode)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">		<span class="keyword">throw</span>(<span class="string">&quot;gcSweep being done but phase is not GCoff&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 增加sweepgen, 这样sweepSpans中两个队列角色会交换, 所有span都会变为&quot;待清扫&quot;的span</span></span><br><span class="line">	lock(&amp;mheap_.lock)</span><br><span class="line">	mheap_.sweepgen += <span class="number">2</span></span><br><span class="line">	mheap_.sweepdone = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> mheap_.sweepSpans[mheap_.sweepgen/<span class="number">2</span>%<span class="number">2</span>].index != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// We should have drained this list during the last</span></span><br><span class="line">		<span class="comment">// sweep phase. We certainly need to start this phase</span></span><br><span class="line">		<span class="comment">// with an empty swept list.</span></span><br><span class="line">		<span class="keyword">throw</span>(<span class="string">&quot;non-empty swept list&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mheap_.pagesSwept = <span class="number">0</span></span><br><span class="line">	unlock(&amp;mheap_.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果非并行GC则在这里完成所有工作(STW中)</span></span><br><span class="line">	<span class="keyword">if</span> !_ConcurrentSweep || mode == gcForceBlockMode &#123;</span><br><span class="line">		<span class="comment">// Special case synchronous sweep.</span></span><br><span class="line">		<span class="comment">// Record that no proportional sweeping has to happen.</span></span><br><span class="line">		lock(&amp;mheap_.lock)</span><br><span class="line">		mheap_.sweepPagesPerByte = <span class="number">0</span></span><br><span class="line">		unlock(&amp;mheap_.lock)</span><br><span class="line">		<span class="comment">// Sweep all spans eagerly.</span></span><br><span class="line">		<span class="function"><span class="keyword">for</span> <span class="title">sweepone</span><span class="params">()</span> !</span>= ^uintptr(<span class="number">0</span>) &#123;</span><br><span class="line">			sweep.npausesweep++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Free workbufs eagerly.</span></span><br><span class="line">		prepareFreeWorkbufs()</span><br><span class="line">		<span class="function"><span class="keyword">for</span> <span class="title">freeSomeWbufs</span><span class="params">(<span class="keyword">false</span>)</span> </span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		mProf_NextCycle()</span><br><span class="line">		mProf_Flush()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 唤醒后台清扫任务</span></span><br><span class="line">	lock(&amp;sweep.lock)</span><br><span class="line">	<span class="keyword">if</span> sweep.parked &#123;</span><br><span class="line">		sweep.parked = <span class="keyword">false</span></span><br><span class="line">		ready(sweep.g, <span class="number">0</span>, <span class="keyword">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;sweep.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bgsweep"><a href="#bgsweep" class="headerlink" title="bgsweep"></a>bgsweep</h4><p>后台清扫任务的函数是bgsweep</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">bgsweep</span><span class="params">(c chan <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">	sweep.g = getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待唤醒</span></span><br><span class="line">	lock(&amp;sweep.lock)</span><br><span class="line">	sweep.parked = <span class="keyword">true</span></span><br><span class="line">	c &lt;- <span class="number">1</span></span><br><span class="line">	goparkunlock(&amp;sweep.lock, <span class="string">&quot;GC sweep wait&quot;</span>, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环清扫</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 清扫一个span, 然后进入调度(一次只做少量工作)</span></span><br><span class="line">		<span class="function"><span class="keyword">for</span> <span class="title">gosweepone</span><span class="params">()</span> !</span>= ^uintptr(<span class="number">0</span>) &#123;</span><br><span class="line">			sweep.nbgsweep++</span><br><span class="line">			Gosched()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 释放一些未使用的标记队列缓冲区到heap</span></span><br><span class="line">		<span class="function"><span class="keyword">for</span> <span class="title">freeSomeWbufs</span><span class="params">(<span class="keyword">true</span>)</span> </span>&#123;</span><br><span class="line">			Gosched()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果清扫未完成则继续循环</span></span><br><span class="line">		lock(&amp;sweep.lock)</span><br><span class="line">		<span class="keyword">if</span> !gosweepdone() &#123;</span><br><span class="line">			unlock(&amp;sweep.lock)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 否则让后台清扫任务进入休眠, 当前M继续调度</span></span><br><span class="line">		sweep.parked = <span class="keyword">true</span></span><br><span class="line">		goparkunlock(&amp;sweep.lock, <span class="string">&quot;GC sweep wait&quot;</span>, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gosweepone"><a href="#gosweepone" class="headerlink" title="gosweepone"></a>gosweepone</h4><p>函数会从sweepSpans中取出单个span清扫:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function">func <span class="title">gosweepone</span><span class="params">()</span> uintptr </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> ret uintptr</span><br><span class="line">	<span class="comment">// 切换到g0运行</span></span><br><span class="line">	systemstack(func() &#123;</span><br><span class="line">		ret = sweepone()</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sweepone"><a href="#sweepone" class="headerlink" title="sweepone"></a>sweepone</h4><p>sweepone 函数如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">sweepone</span><span class="params">()</span> uintptr </span>&#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line">	sweepRatio := mheap_.sweepPagesPerByte <span class="comment">// For debugging</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 禁止G被抢占</span></span><br><span class="line">	<span class="comment">// increment locks to ensure that the goroutine is not preempted</span></span><br><span class="line">	<span class="comment">// in the middle of sweep thus leaving the span in an inconsistent state for next GC</span></span><br><span class="line">	_g_.m.locks++</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 检查是否已完成清扫</span></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;mheap_.sweepdone) != <span class="number">0</span> &#123;</span><br><span class="line">		_g_.m.locks--</span><br><span class="line">		<span class="keyword">return</span> ^uintptr(<span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 更新同时执行sweep的任务数量</span></span><br><span class="line">	atomic.Xadd(&amp;mheap_.sweepers, +<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	npages := ^uintptr(<span class="number">0</span>)</span><br><span class="line">	sg := mheap_.sweepgen</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 从sweepSpans中取出一个span</span></span><br><span class="line">		s := mheap_.sweepSpans[<span class="number">1</span>-sg/<span class="number">2</span>%<span class="number">2</span>].pop()</span><br><span class="line">		<span class="comment">// 全部清扫完毕时跳出循环</span></span><br><span class="line">		<span class="keyword">if</span> s == nil &#123;</span><br><span class="line">			atomic.Store(&amp;mheap_.sweepdone, <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 其他M已经在清扫这个span时跳过</span></span><br><span class="line">		<span class="keyword">if</span> s.state != mSpanInUse &#123;</span><br><span class="line">			<span class="comment">// This can happen if direct sweeping already</span></span><br><span class="line">			<span class="comment">// swept this span, but in that case the sweep</span></span><br><span class="line">			<span class="comment">// generation should always be up-to-date.</span></span><br><span class="line">			<span class="keyword">if</span> s.sweepgen != sg &#123;</span><br><span class="line">				print(<span class="string">&quot;runtime: bad span s.state=&quot;</span>, s.state, <span class="string">&quot; s.sweepgen=&quot;</span>, s.sweepgen, <span class="string">&quot; sweepgen=&quot;</span>, sg, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">				<span class="keyword">throw</span>(<span class="string">&quot;non in-use span in unswept list&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 原子增加span的sweepgen, 失败表示其他M已经开始清扫这个span, 跳过</span></span><br><span class="line">		<span class="keyword">if</span> s.sweepgen != sg-<span class="number">2</span> || !atomic.Cas(&amp;s.sweepgen, sg-<span class="number">2</span>, sg-<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 清扫这个span, 然后跳出循环</span></span><br><span class="line">		npages = s.npages</span><br><span class="line">		<span class="keyword">if</span> !s.sweep(<span class="keyword">false</span>) &#123;</span><br><span class="line">			<span class="comment">// Span is still in-use, so this returned no</span></span><br><span class="line">			<span class="comment">// pages to the heap and the span needs to</span></span><br><span class="line">			<span class="comment">// move to the swept in-use list.</span></span><br><span class="line">			npages = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新同时执行sweep的任务数量</span></span><br><span class="line">	<span class="comment">// Decrement the number of active sweepers and if this is the</span></span><br><span class="line">	<span class="comment">// last one print trace information.</span></span><br><span class="line">	<span class="keyword">if</span> atomic.Xadd(&amp;mheap_.sweepers, -<span class="number">1</span>) == <span class="number">0</span> &amp;&amp; atomic.Load(&amp;mheap_.sweepdone) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> debug.gcpacertrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">			print(<span class="string">&quot;pacer: sweep done at heap size &quot;</span>, memstats.heap_live&gt;&gt;<span class="number">20</span>, <span class="string">&quot;MB; allocated &quot;</span>, (memstats.heap_live-mheap_.sweepHeapLiveBasis)&gt;&gt;<span class="number">20</span>, <span class="string">&quot;MB during sweep; swept &quot;</span>, mheap_.pagesSwept, <span class="string">&quot; pages at &quot;</span>, sweepRatio, <span class="string">&quot; pages/byte\n&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 允许G被抢占</span></span><br><span class="line">	_g_.m.locks--</span><br><span class="line">	<span class="comment">// 返回清扫的页数</span></span><br><span class="line">	<span class="keyword">return</span> npages</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>span的sweep函数用于清扫单个span:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">func (s *mspan) sweep(preserve bool) bool &#123;</span><br><span class="line">	<span class="comment">// It&#x27;s critical that we enter this function with preemption disabled,</span></span><br><span class="line">	<span class="comment">// GC must not start while we are in the middle of this function.</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line">	<span class="keyword">if</span> _g_.m.locks == <span class="number">0</span> &amp;&amp; _g_.m.mallocing == <span class="number">0</span> &amp;&amp; _g_ != _g_.m.g0 &#123;</span><br><span class="line">		<span class="keyword">throw</span>(<span class="string">&quot;MSpan_Sweep: m is not locked&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	sweepgen := mheap_.sweepgen</span><br><span class="line">	<span class="keyword">if</span> s.state != mSpanInUse || s.sweepgen != sweepgen-<span class="number">1</span> &#123;</span><br><span class="line">		print(<span class="string">&quot;MSpan_Sweep: state=&quot;</span>, s.state, <span class="string">&quot; sweepgen=&quot;</span>, s.sweepgen, <span class="string">&quot; mheap.sweepgen=&quot;</span>, sweepgen, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		<span class="keyword">throw</span>(<span class="string">&quot;MSpan_Sweep: bad span state&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGCSweepSpan(s.npages * _PageSize)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 统计已清理的页数</span></span><br><span class="line">	atomic.Xadd64(&amp;mheap_.pagesSwept, int64(s.npages))</span><br><span class="line"></span><br><span class="line">	spc := s.spanclass</span><br><span class="line">	size := s.elemsize</span><br><span class="line">	res := <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">	c := _g_.m.mcache</span><br><span class="line">	freeToHeap := <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断在special中的析构器, 如果对应的对象已经不再存活则标记对象存活防止回收, 然后把析构器移到运行队列</span></span><br><span class="line">	specialp := &amp;s.specials</span><br><span class="line">	special := *specialp</span><br><span class="line">	<span class="keyword">for</span> special != nil &#123;</span><br><span class="line">		<span class="comment">// A finalizer can be set for an inner byte of an object, find object beginning.</span></span><br><span class="line">		objIndex := uintptr(special.offset) / size</span><br><span class="line">		p := s.base() + objIndex*size</span><br><span class="line">		mbits := s.markBitsForIndex(objIndex)</span><br><span class="line">		<span class="keyword">if</span> !mbits.isMarked() &#123;</span><br><span class="line">			<span class="comment">// This object is not marked and has at least one special record.</span></span><br><span class="line">			<span class="comment">// Pass 1: see if it has at least one finalizer.</span></span><br><span class="line">			hasFin := <span class="keyword">false</span></span><br><span class="line">			endOffset := p - s.base() + size</span><br><span class="line">			<span class="keyword">for</span> tmp := special; tmp != nil &amp;&amp; uintptr(tmp.offset) &lt; endOffset; tmp = tmp.next &#123;</span><br><span class="line">				<span class="keyword">if</span> tmp.kind == _KindSpecialFinalizer &#123;</span><br><span class="line">					<span class="comment">// Stop freeing of object if it has a finalizer.</span></span><br><span class="line">					mbits.setMarkedNonAtomic()</span><br><span class="line">					hasFin = <span class="keyword">true</span></span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Pass 2: queue all finalizers _or_ handle profile record.</span></span><br><span class="line">			<span class="keyword">for</span> special != nil &amp;&amp; uintptr(special.offset) &lt; endOffset &#123;</span><br><span class="line">				<span class="comment">// Find the exact byte for which the special was setup</span></span><br><span class="line">				<span class="comment">// (as opposed to object beginning).</span></span><br><span class="line">				p := s.base() + uintptr(special.offset)</span><br><span class="line">				<span class="keyword">if</span> special.kind == _KindSpecialFinalizer || !hasFin &#123;</span><br><span class="line">					<span class="comment">// Splice out special record.</span></span><br><span class="line">					y := special</span><br><span class="line">					special = special.next</span><br><span class="line">					*specialp = special</span><br><span class="line">					freespecial(y, unsafe.Pointer(p), size)</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// This is profile record, but the object has finalizers (so kept alive).</span></span><br><span class="line">					<span class="comment">// Keep special record.</span></span><br><span class="line">					specialp = &amp;special.next</span><br><span class="line">					special = *specialp</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// object is still live: keep special record</span></span><br><span class="line">			specialp = &amp;special.next</span><br><span class="line">			special = *specialp</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 除错用</span></span><br><span class="line">	<span class="keyword">if</span> debug.allocfreetrace != <span class="number">0</span> || raceenabled || msanenabled &#123;</span><br><span class="line">		<span class="comment">// Find all newly freed objects. This doesn&#x27;t have to</span></span><br><span class="line">		<span class="comment">// efficient; allocfreetrace has massive overhead.</span></span><br><span class="line">		mbits := s.markBitsForBase()</span><br><span class="line">		abits := s.allocBitsForIndex(<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">for</span> i := uintptr(<span class="number">0</span>); i &lt; s.nelems; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> !mbits.isMarked() &amp;&amp; (abits.index &lt; s.freeindex || abits.isMarked()) &#123;</span><br><span class="line">				x := s.base() + i*s.elemsize</span><br><span class="line">				<span class="keyword">if</span> debug.allocfreetrace != <span class="number">0</span> &#123;</span><br><span class="line">					tracefree(unsafe.Pointer(x), size)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">					racefree(unsafe.Pointer(x), size)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">					msanfree(unsafe.Pointer(x), size)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			mbits.advance()</span><br><span class="line">			abits.advance()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算释放的对象数量</span></span><br><span class="line">	<span class="comment">// Count the number of free objects in this span.</span></span><br><span class="line">	nalloc := uint16(s.countAlloc())</span><br><span class="line">	<span class="keyword">if</span> spc.sizeclass() == <span class="number">0</span> &amp;&amp; nalloc == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 如果span的类型是0(大对象)并且其中的对象已经不存活则释放到heap</span></span><br><span class="line">		s.needzero = <span class="number">1</span></span><br><span class="line">		freeToHeap = <span class="keyword">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	nfreed := s.allocCount - nalloc</span><br><span class="line">	<span class="keyword">if</span> nalloc &gt; s.allocCount &#123;</span><br><span class="line">		print(<span class="string">&quot;runtime: nelems=&quot;</span>, s.nelems, <span class="string">&quot; nalloc=&quot;</span>, nalloc, <span class="string">&quot; previous allocCount=&quot;</span>, s.allocCount, <span class="string">&quot; nfreed=&quot;</span>, nfreed, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		<span class="keyword">throw</span>(<span class="string">&quot;sweep increased allocation count&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置新的allocCount</span></span><br><span class="line">	s.allocCount = nalloc</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断span是否无未分配的对象</span></span><br><span class="line">	wasempty := s.nextFreeIndex() == s.nelems</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置freeindex, 下次分配从0开始搜索</span></span><br><span class="line">	s.freeindex = <span class="number">0</span> <span class="comment">// reset allocation index to start of span.</span></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		getg().m.p.ptr().traceReclaimed += uintptr(nfreed) * s.elemsize</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// gcmarkBits变为新的allocBits</span></span><br><span class="line">	<span class="comment">// 然后重新分配一块全部为0的gcmarkBits</span></span><br><span class="line">	<span class="comment">// 下次分配对象时可以根据allocBits得知哪些元素是未分配的</span></span><br><span class="line">	<span class="comment">// gcmarkBits becomes the allocBits.</span></span><br><span class="line">	<span class="comment">// get a fresh cleared gcmarkBits in preparation for next GC</span></span><br><span class="line">	s.allocBits = s.gcmarkBits</span><br><span class="line">	s.gcmarkBits = newMarkBits(s.nelems)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新freeindex开始的allocCache</span></span><br><span class="line">	<span class="comment">// Initialize alloc bits cache.</span></span><br><span class="line">	s.refillAllocCache(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果span中已经无存活的对象则更新sweepgen到最新</span></span><br><span class="line">	<span class="comment">// 下面会把span加到mcentral或者mheap</span></span><br><span class="line">	<span class="comment">// We need to set s.sweepgen = h.sweepgen only when all blocks are swept,</span></span><br><span class="line">	<span class="comment">// because of the potential for a concurrent free/SetFinalizer.</span></span><br><span class="line">	<span class="comment">// But we need to set it before we make the span available for allocation</span></span><br><span class="line">	<span class="comment">// (return it to heap or mcentral), because allocation code assumes that a</span></span><br><span class="line">	<span class="comment">// span is already swept if available for allocation.</span></span><br><span class="line">	<span class="keyword">if</span> freeToHeap || nfreed == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// The span must be in our exclusive ownership until we update sweepgen,</span></span><br><span class="line">		<span class="comment">// check for potential races.</span></span><br><span class="line">		<span class="keyword">if</span> s.state != mSpanInUse || s.sweepgen != sweepgen-<span class="number">1</span> &#123;</span><br><span class="line">			print(<span class="string">&quot;MSpan_Sweep: state=&quot;</span>, s.state, <span class="string">&quot; sweepgen=&quot;</span>, s.sweepgen, <span class="string">&quot; mheap.sweepgen=&quot;</span>, sweepgen, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">			<span class="keyword">throw</span>(<span class="string">&quot;MSpan_Sweep: bad span state after sweep&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		atomic.Store(&amp;s.sweepgen, sweepgen)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> nfreed &gt; <span class="number">0</span> &amp;&amp; spc.sizeclass() != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 把span加到mcentral, res等于是否添加成功</span></span><br><span class="line">		c.local_nsmallfree[spc.sizeclass()] += uintptr(nfreed)</span><br><span class="line">		res = mheap_.central[spc].mcentral.freeSpan(s, preserve, wasempty)</span><br><span class="line">		<span class="comment">// freeSpan会更新sweepgen</span></span><br><span class="line">		<span class="comment">// MCentral_FreeSpan updates sweepgen</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> freeToHeap &#123;</span><br><span class="line">		<span class="comment">// 把span释放到mheap</span></span><br><span class="line">		<span class="comment">// Free large span to heap</span></span><br><span class="line">		<span class="keyword">if</span> debug.efence &gt; <span class="number">0</span> &#123;</span><br><span class="line">			s.limit = <span class="number">0</span> <span class="comment">// prevent mlookup from finding this span</span></span><br><span class="line">			sysFault(unsafe.Pointer(s.base()), size)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			mheap_.freeSpan(s, <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		c.local_nlargefree++</span><br><span class="line">		c.local_largefree += size</span><br><span class="line">		res = <span class="keyword">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果span未加到mcentral或者未释放到mheap, 则表示span仍在使用</span></span><br><span class="line">	<span class="keyword">if</span> !res &#123;</span><br><span class="line">		<span class="comment">// 把仍在使用的span加到sweepSpans的&quot;已清扫&quot;队列中</span></span><br><span class="line">		<span class="comment">// The span has been swept and is still in-use, so put</span></span><br><span class="line">		<span class="comment">// it on the swept in-use list.</span></span><br><span class="line">		mheap_.sweepSpans[sweepgen/<span class="number">2</span>%<span class="number">2</span>].push(s)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。</p>
<p>GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通</p>
<p>GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zkweb/p/7880099.html">参考资料</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/qcrao-Go-Questions/spilt.4.GC-GC.md">参考资料</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/golang/" rel="tag"># golang</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2020/10/26/Wechat/2018-11-08-Wechat-unionid/" rel="next" title="wechat unionid介绍">
      wechat unionid介绍 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">2.</span> <span class="nav-text">Go的垃圾回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0"><span class="nav-number">3.</span> <span class="nav-text">三色标记</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.2.</span> <span class="nav-text">三色标记详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89STW%E7%9A%84%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text">没有STW的三色标记法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E5%B1%8F%E9%9A%9C%E3%80%81%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="nav-number">4.</span> <span class="nav-text">写屏障、混合写屏障</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%80%9C%E5%BC%BA-%E5%BC%B1%E2%80%9D-%E4%B8%89%E8%89%B2%E4%B8%8D%E5%8F%98%E5%BC%8F"><span class="nav-number">4.1.</span> <span class="nav-text">“强-弱” 三色不变式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%B1%8F%E9%9A%9C"><span class="nav-number">4.2.</span> <span class="nav-text">插入屏障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%B1%8F%E9%9A%9C"><span class="nav-number">4.3.</span> <span class="nav-text">删除屏障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-V1-8%E7%9A%84%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="nav-number">4.4.</span> <span class="nav-text">Go V1.8的混合写屏障</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C%E8%A7%84%E5%88%99"><span class="nav-number">4.4.1.</span> <span class="nav-text">混合写屏障规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C%E7%9A%84%E5%85%B7%E4%BD%93%E5%9C%BA%E6%99%AF"><span class="nav-number">4.4.2.</span> <span class="nav-text">混合写屏障的具体场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF1"><span class="nav-number">4.4.2.1.</span> <span class="nav-text">场景1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF2"><span class="nav-number">4.4.2.2.</span> <span class="nav-text">场景2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF3"><span class="nav-number">4.4.2.3.</span> <span class="nav-text">场景3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF4"><span class="nav-number">4.4.2.4.</span> <span class="nav-text">场景4</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">对象回收流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.1.</span> <span class="nav-text">根对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E9%98%9F%E5%88%97"><span class="nav-number">5.2.</span> <span class="nav-text">标记队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">5.3.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#gcStart"><span class="nav-number">5.3.1.</span> <span class="nav-text">gcStart</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gcBgMarkStartWorkers"><span class="nav-number">5.3.2.</span> <span class="nav-text">gcBgMarkStartWorkers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stopTheWorldWithSema"><span class="nav-number">5.3.3.</span> <span class="nav-text">stopTheWorldWithSema</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finishsweep-m"><span class="nav-number">5.3.4.</span> <span class="nav-text">finishsweep_m</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gcBgMarkPrepare"><span class="nav-number">5.3.5.</span> <span class="nav-text">gcBgMarkPrepare</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gcMarkRootPrepare"><span class="nav-number">5.3.6.</span> <span class="nav-text">gcMarkRootPrepare</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gcMarkTinyAllocs"><span class="nav-number">5.3.7.</span> <span class="nav-text">gcMarkTinyAllocs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#startTheWorldWithSema"><span class="nav-number">5.3.8.</span> <span class="nav-text">startTheWorldWithSema</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gcBgMarkWorker"><span class="nav-number">5.3.9.</span> <span class="nav-text">gcBgMarkWorker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gcDrain"><span class="nav-number">5.3.10.</span> <span class="nav-text">gcDrain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#markroot"><span class="nav-number">5.3.11.</span> <span class="nav-text">markroot</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scang"><span class="nav-number">5.3.12.</span> <span class="nav-text">scang</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gcMarkDone"><span class="nav-number">5.3.13.</span> <span class="nav-text">gcMarkDone</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gcMarkTermination"><span class="nav-number">5.3.14.</span> <span class="nav-text">gcMarkTermination</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gcSweep"><span class="nav-number">5.3.15.</span> <span class="nav-text">gcSweep</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bgsweep"><span class="nav-number">5.3.16.</span> <span class="nav-text">bgsweep</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gosweepone"><span class="nav-number">5.3.17.</span> <span class="nav-text">gosweepone</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sweepone"><span class="nav-number">5.3.18.</span> <span class="nav-text">sweepone</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="QingSong"
      src="/images/avatar/avatar.png">
  <p class="site-author-name" itemprop="name">QingSong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">160</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QingSong</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
