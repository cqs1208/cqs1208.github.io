<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="06 redis配置文件详解">
<meta property="og:url" content="http://example.com/2020/10/26/Redis/2019-03-06%206%20redis%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Redis">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-10-26T03:56:48.326Z">
<meta property="article:modified_time" content="2020-08-11T09:28:29.000Z">
<meta property="article:author" content="QingSong">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2020/10/26/Redis/2019-03-06%206%20redis%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>06 redis配置文件详解 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">点滴积累 豁达处之</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/26/Redis/2019-03-06%206%20redis%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar/avatar.png">
      <meta itemprop="name" content="QingSong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          06 redis配置文件详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-26 11:56:48" itemprop="dateCreated datePublished" datetime="2020-10-26T11:56:48+08:00">2020-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-11 17:28:29" itemprop="dateModified" datetime="2020-08-11T17:28:29+08:00">2020-08-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          
            <div class="post-description">Redis</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>进入Redis的安装包，里面的“redis.conf”就是默认的配置文件，启动Redis Server的时候，可以指定加载某个路径下的配置文件“redis-server [path of configuration file]”。 </p>
<a id="more"></a> 

<p>默认的配置文件中，首先约定了存储单位： </p>
<p><em>1k =&gt; 1000 bytes</em></p>
<p><em>1kb =&gt; 1024 bytes</em></p>
<p><em>1m =&gt; 1000000 bytes</em></p>
<p><em>1mb =&gt; 1024\</em>1024 bytes*</p>
<p><em>1g =&gt; 1000000000 bytes</em></p>
<p><em>1gb =&gt; 1024\</em>1024<em>1024 bytes</em></p>
<p>Redis配置中对单位的大小写不敏感，1GB、1Gb和1gB都是相同的。由此也说明，Redis只支持bytes，不支持bit单位。</p>
<p>Redis支持以“includes”的方式引入其他配置文件，比如：</p>
<p>include/path/to/local.conf</p>
<p>include/path/to/other.conf</p>
<p>需要注意的是，假如多个一个配置项在不同配置文件中都有定义，则以最后一行读入的为准，就是说后面的配置项会覆盖前面的配置项。</p>
<h3 id="1-通用配置"><a href="#1-通用配置" class="headerlink" title="1 通用配置"></a>1 通用配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"># redis 配置文件示例</span><br><span class="line"> </span><br><span class="line"># 当你需要为某个配置项指定内存大小的时候，必须要带上单位，</span><br><span class="line"># 通常的格式就是 1k 5gb 4m 等酱紫：</span><br><span class="line">#</span><br><span class="line"># 1k  =&gt; 1000 bytes</span><br><span class="line"># 1kb =&gt; 1024 bytes</span><br><span class="line"># 1m  =&gt; 1000000 bytes</span><br><span class="line"># 1mb =&gt; 1024*1024 bytes</span><br><span class="line"># 1g  =&gt; 1000000000 bytes</span><br><span class="line"># 1gb =&gt; 1024*1024*1024 bytes</span><br><span class="line">#</span><br><span class="line"># 单位是不区分大小写的，你写 1K 5GB 4M 也行</span><br><span class="line"> </span><br><span class="line">################################## INCLUDES ###################################</span><br><span class="line"> </span><br><span class="line"># 假如说你有一个可用于所有的 redis server 的标准配置模板，</span><br><span class="line"># 但针对某些 server 又需要一些个性化的设置，</span><br><span class="line"># 你可以使用 include 来包含一些其他的配置文件，这对你来说是非常有用的。</span><br><span class="line">#</span><br><span class="line"># 但是要注意哦，include 是不能被 config rewrite 命令改写的</span><br><span class="line"># 由于 redis 总是以最后的加工线作为一个配置指令值，所以你最好是把 include 放在这个文件的最前面，</span><br><span class="line"># 以避免在运行时覆盖配置的改变，相反，你就把它放在后面（外国人真啰嗦）。</span><br><span class="line">#</span><br><span class="line"># include /path/to/local.conf</span><br><span class="line"># include /path/to/other.conf</span><br><span class="line"> </span><br><span class="line">################################ 常用 #####################################</span><br><span class="line"> </span><br><span class="line"># 默认情况下 redis 不是作为守护进程运行的，如果你想让它在后台运行，你就把它改成 yes。</span><br><span class="line"># 当redis作为守护进程运行的时候，它会写一个 pid 到 /var/run/redis.pid 文件里面。</span><br><span class="line">daemonize no</span><br><span class="line"> </span><br><span class="line"># 当redis作为守护进程运行的时候，它会把 pid 默认写到 /var/run/redis.pid 文件里面，</span><br><span class="line"># 但是你可以在这里自己制定它的文件位置。</span><br><span class="line">pidfile /<span class="keyword">var</span>/run/redis.pid</span><br><span class="line"> </span><br><span class="line"># 监听端口号，默认为 6379，如果你设为 0 ，redis 将不在 socket 上监听任何客户端连接。</span><br><span class="line">port <span class="number">6379</span></span><br><span class="line"> </span><br><span class="line"># TCP 监听的最大容纳数量</span><br><span class="line">#</span><br><span class="line"># 在高并发的环境下，你需要把这个值调高以避免客户端连接缓慢的问题。</span><br><span class="line"># Linux 内核会一声不响的把这个值缩小成 /proc/sys/net/core/somaxconn 对应的值，</span><br><span class="line"># 所以你要修改这两个值才能达到你的预期。</span><br><span class="line">tcp-backlog <span class="number">511</span></span><br><span class="line"> </span><br><span class="line"># 默认情况下，redis 在 server 上所有有效的网络接口上监听客户端连接。</span><br><span class="line"># 你如果只想让它在一个网络接口上监听，那你就绑定一个IP或者多个IP。</span><br><span class="line">#</span><br><span class="line"># 示例，多个IP用空格隔开:</span><br><span class="line">#</span><br><span class="line"># bind 192.168.1.100 10.0.0.1</span><br><span class="line"># bind 127.0.0.1</span><br><span class="line"> </span><br><span class="line"># 指定 unix socket 的路径。</span><br><span class="line">#</span><br><span class="line"># unixsocket /tmp/redis.sock</span><br><span class="line"># unixsocketperm 755</span><br><span class="line"> </span><br><span class="line"># 指定在一个 client 空闲多少秒之后关闭连接（0 就是不管它）</span><br><span class="line">timeout <span class="number">0</span></span><br><span class="line"> </span><br><span class="line"># TCP连接保活策略，可以通过tcp-keepalive配置项来进行设置，单位为秒，假如设置为60秒，则server端会每60秒# 向连接空闲的客户端发起一次ACK请求，以检查客户端是否已经挂掉，对于无响应的客户端则会关闭其连接。所以关闭# 一个连接最长需要120秒的时间。如果设置为0，则不会进行保活检测。</span><br><span class="line"># 推荐一个合理的值就是60秒</span><br><span class="line">tcp-keepalive <span class="number">0</span></span><br><span class="line"> </span><br><span class="line"># 定义日志级别。</span><br><span class="line"># 可以是下面的这些值：</span><br><span class="line"># debug (适用于开发或测试阶段)</span><br><span class="line"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="line"># notice (适用于生产环境)</span><br><span class="line"># warning (仅仅一些重要的消息被记录)</span><br><span class="line">loglevel notice</span><br><span class="line"> </span><br><span class="line"># 指定日志文件的位置,如果设置为空字符串，则Redis会将日志输出到标准输出。假如在daemon情况下将日志设置为输# 出到标准输出，则日志会被写到/dev/null中</span><br><span class="line">logfile <span class="string">&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"># 要想把日志记录到系统日志，就把它改成 yes，</span><br><span class="line"># 也可以可选择性的更新其他的syslog 参数以达到你的要求</span><br><span class="line"># syslog-enabled no</span><br><span class="line"> </span><br><span class="line"># 设置 syslog 的 identity。</span><br><span class="line"># syslog-ident redis</span><br><span class="line"> </span><br><span class="line"># 设置 syslog 的 facility，必须是 USER 或者是 LOCAL0-LOCAL7 之间的值。</span><br><span class="line"># syslog-facility local0</span><br><span class="line"> </span><br><span class="line"># 设置数据库的数目。</span><br><span class="line"># 默认数据库是 DB 0，你可以在每个连接上使用 select &lt;dbid&gt; 命令选择一个不同的数据库，</span><br><span class="line"># 但是 dbid 必须是一个介于 0 到 databasees - 1 之间的值</span><br><span class="line">databases <span class="number">16</span></span><br></pre></td></tr></table></figure>

<h3 id="2-快照配置"><a href="#2-快照配置" class="headerlink" title="2 快照配置"></a>2 快照配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">################################ 快照 ################################</span><br><span class="line">#</span><br><span class="line"># 存 DB 到磁盘：</span><br><span class="line">#</span><br><span class="line">#   格式：save &lt;间隔时间（秒）&gt; &lt;写入次数&gt;</span><br><span class="line">#</span><br><span class="line">#   根据给定的时间间隔和写入次数将数据保存到磁盘</span><br><span class="line">#</span><br><span class="line">#   下面的例子的意思是：</span><br><span class="line">#   900 秒内如果至少有 1 个 key 的值变化，则保存</span><br><span class="line">#   300 秒内如果至少有 10 个 key 的值变化，则保存</span><br><span class="line">#   60 秒内如果至少有 10000 个 key 的值变化，则保存</span><br><span class="line">#　　</span><br><span class="line">#   注意：你可以注释掉所有的 save 行来停用保存功能。</span><br><span class="line">#   也可以直接一个空字符串来实现停用：</span><br><span class="line">#   save &quot;&quot;</span><br><span class="line"> </span><br><span class="line">save <span class="number">900</span> <span class="number">1</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br><span class="line"> </span><br><span class="line"># 默认情况下，如果 redis 最后一次的后台保存失败，redis 将停止接受写操作，</span><br><span class="line"># 这样以一种强硬的方式让用户知道数据不能正确的持久化到磁盘，</span><br><span class="line"># 否则就会没人注意到灾难的发生。</span><br><span class="line">#</span><br><span class="line"># 如果后台保存进程重新启动工作了，redis 也将自动的允许写操作。</span><br><span class="line">#</span><br><span class="line"># 然而你要是安装了靠谱的监控，你可能不希望 redis 这样做，那你就改成 no 好了。</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"> </span><br><span class="line"># 是否在 dump .rdb 数据库的时候使用 LZF 压缩字符串</span><br><span class="line"># 默认都设为 yes</span><br><span class="line"># 如果你希望保存子进程节省点 cpu ，你就设置它为 no ，</span><br><span class="line"># 不过这个数据集可能就会比较大</span><br><span class="line">rdbcompression yes</span><br><span class="line"> </span><br><span class="line"># 在存储快照后，我们还可以让Redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希# # 望获取到最大的性能提升，可以关闭此功能。</span><br><span class="line">rdbchecksum yes</span><br><span class="line"> </span><br><span class="line"># 设置 dump 的文件位置</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"> </span><br><span class="line"># 工作目录</span><br><span class="line"># 例如上面的 dbfilename 只指定了文件名，</span><br><span class="line"># 但是它会写入到这个目录下。这个配置项一定是个目录，而不能是文件名。</span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure>

<h3 id="3-主从配置"><a href="#3-主从配置" class="headerlink" title="3 主从配置"></a>3 主从配置</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">################################# 主从复制 #################################</span><br><span class="line"> </span><br><span class="line"># 主从复制。使用 slaveof 来让一个 redis 实例成为另一个reids 实例的副本。</span><br><span class="line"># 注意这个只需要在 slave 上配置。</span><br><span class="line">#</span><br><span class="line"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"> </span><br><span class="line"># 如果 master 需要密码认证，就在这里设置</span><br><span class="line"># masterauth &lt;master-password&gt;</span><br><span class="line"> </span><br><span class="line"># 当一个 slave 与 master 失去联系，或者复制正在进行的时候，</span><br><span class="line"># slave 可能会有两种表现：</span><br><span class="line">#</span><br><span class="line"># 1) 如果为 yes ，slave 仍然会应答客户端请求，但返回的数据可能是过时，</span><br><span class="line">#    或者数据可能是空的在第一次同步的时候</span><br><span class="line">#</span><br><span class="line"># 2) 如果为 no ，在你执行除了 info he salveof 之外的其他命令时，</span><br><span class="line">#    slave 都将返回一个 &quot;SYNC with master in progress&quot; 的错误，</span><br><span class="line">#</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"> </span><br><span class="line"># 你可以配置一个 slave 实体是否接受写入操作。</span><br><span class="line"># 通过写入操作来存储一些短暂的数据对于一个 slave 实例来说可能是有用的，</span><br><span class="line"># 因为相对从 master 重新同步数而言，据数据写入到 slave 会更容易被删除。</span><br><span class="line"># 但是如果客户端因为一个错误的配置写入，也可能会导致一些问题。</span><br><span class="line">#</span><br><span class="line"># 从 redis 2.6 版起，默认 slaves 都是只读的。</span><br><span class="line"># 注意：只读的 slaves 没有被设计成在 internet 上暴露给不受信任的客户端。</span><br><span class="line"># 它仅仅是一个针对误用实例的一个保护层。</span><br><span class="line">slave-read-only yes</span><br><span class="line"> </span><br><span class="line"># Slaves 在一个预定义的时间间隔内发送 ping 命令到 server 。</span><br><span class="line"># 你可以改变这个时间间隔。默认为 10 秒。</span><br><span class="line">#</span><br><span class="line"># repl-ping-slave-period 10</span><br><span class="line"> </span><br><span class="line"># 设置主从复制过期时间</span><br><span class="line"># 在主从同步时，可能在这些情况下会有超时发生：</span><br><span class="line">#	（1）以从Redis的角度来看，当有大规模IO传输时。</span><br><span class="line">#	（2）以从Redis的角度来看，当数据传输或PING时，主Redis超时</span><br><span class="line">#	（3）以主Redis的角度来看，在回复从Redis的PING时，从Redis超时</span><br><span class="line"># 用户可以设置上述超时的时限，不过要确保这个时限比repl-ping-slave-period的值要大，否则每次主Redis都会# # 认为从Redis超时</span><br><span class="line">#</span><br><span class="line"># repl-timeout 60</span><br><span class="line"> </span><br><span class="line"># 我们可以控制在主从同步时是否禁用TCP_NODELAY。如果开启TCP_NODELAY，那么主Redis会使用更少的TCP包和更少# 的带宽来向从Redis传输数据。但是这可能会增加一些同步的延迟，大概会达到40毫秒左右。如果关闭了# # # # # # TCP_NODELAY，那么数据同步的延迟时间会降低，但是会消耗更多的带宽。</span><br><span class="line"></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"> </span><br><span class="line"># 设置主从复制容量大小。这个 backlog 是一个用来在 slaves 被断开连接时</span><br><span class="line"># 存放 slave 数据的 buffer，所以当一个 slave 想要重新连接，通常不希望全部重新同步，</span><br><span class="line"># 只是部分同步就够了，仅仅传递 slave 在断开连接时丢失的这部分数据。</span><br><span class="line">#</span><br><span class="line"># 我们还可以设置同步队列长度。队列长度（backlog)是主Redis中的一个缓冲区，在与从Redis断开连接期间，主# # # Redis会用这个缓冲区来缓存应该发给从Redis的数据。这样的话，当从Redis重新连接上之后，就不必重新全量同步# 数据，只需要同步这部分增量数据即可。</span><br><span class="line">#</span><br><span class="line"># repl-backlog-size 1mb</span><br><span class="line"> </span><br><span class="line"># 如果主Redis等了一段时间之后，还是无法连接到从Redis，那么缓冲队列中的数据将被清理掉。我们可以设置主# # # Redis要等待的时间长度。如果设置为0，则表示永远不清理。默认是1个小时。</span><br><span class="line">#</span><br><span class="line"># repl-backlog-ttl 3600</span><br><span class="line"> </span><br><span class="line"># 当 master 不能正常工作的时候，Redis Sentinel 会从 slaves 中选出一个新的 master，</span><br><span class="line"># 这个值越小，就越会被优先选中，但是如果是 0 ， 那是意味着这个 slave 不可能被选中。</span><br><span class="line"></span><br><span class="line"># 我们可以给众多的从Redis设置优先级，在主Redis持续工作不正常的情况，优先级高的从Redis将会升级为主# # # # Redis。而编号越小，优先级越高。比如一个主Redis有三个从Redis，优先级编号分别为10、100、25，那么编号为# # 10的从Redis将会被首先选中升级为主Redis。当优先级被设置为0时，这个从Redis将永远也不会被选中。默认的优# # 先级为100。</span><br><span class="line">#</span><br><span class="line"># 默认优先级为 100。</span><br><span class="line">slave-priority <span class="number">100</span></span><br><span class="line"> </span><br><span class="line"># 假如主Redis发现有超过M个从Redis的连接延时大于N秒，那么主Redis就停止接受外来的写请求。这是因为从Redis# # 一般会每秒钟都向主Redis发出PING，而主Redis会记录每一个从Redis最近一次发来PING的时间点，所以主Redis能# 够了解每一个从Redis的运行情况。</span><br><span class="line">#</span><br><span class="line"># min-slaves-to-write 3</span><br><span class="line"># min-slaves-max-lag 10</span><br><span class="line">#</span><br><span class="line"># 上面这个例子表示，假如有大于等于3个从Redis的连接延迟大于10秒，那么主Redis就不再接受外部的写请求。上述# # 两个配置中有一个被置为0，则这个特性将被关闭。默认情况下min-slaves-to-write为0，而min-slaves-max-lag # 为10。</span><br></pre></td></tr></table></figure>

<h3 id="4-安全配置"><a href="#4-安全配置" class="headerlink" title="4 安全配置"></a>4 安全配置</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">################################## 安全 ###################################</span><br><span class="line"> </span><br><span class="line"># 我们可以要求Redis客户端在向Redis-server发送请求之前，先进行密码验证。由于Redis性能非常高，每秒钟可以 # 完成多达15万次的密码尝试，所以最好设置一个足够复杂的密码，否则很容易被黑客破解。</span><br><span class="line"># </span><br><span class="line"># 设置认证密码</span><br><span class="line"># i</span><br><span class="line"> </span><br><span class="line"># Redis允许我们对Redis指令进行更名，比如将一些比较危险的命令改个名字，避免被误执行。比如可以把CONFIG命 # 令改成一个很复杂的名字，这样可以避免外部的调用，同时还可以满足内部调用的需要：</span><br><span class="line">#</span><br><span class="line"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="line"></span><br><span class="line"># 我们甚至可以禁用掉CONFIG命令，那就是把CONFIG的名字改成一个空字符串：</span><br><span class="line">#</span><br><span class="line"># rename-command CONFIG &quot;&quot;</span><br><span class="line">#</span><br><span class="line"># 但需要注意的是，如果使用AOF方式进行数据持久化，或者需要与从Redis进行通信，那么更改指令的名字可能会引起 # 一些问题。</span><br></pre></td></tr></table></figure>

<h3 id="5-限制配置"><a href="#5-限制配置" class="headerlink" title="5 限制配置"></a>5 限制配置</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">################################### 限制 ####################################</span><br><span class="line"> </span><br><span class="line"># 我们可以设置Redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端。当无法设置进程文件句柄限制 # 时，Redis会设置为当前的文件句柄限制值减去32，因为Redis会为自身内部处理逻辑留一些句柄出来。</span><br><span class="line"># 如果达到了此限制，Redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients # #### # reached”以作回应。</span><br><span class="line">#</span><br><span class="line"># 一旦达到最大限制，redis 将关闭所有的新连接</span><br><span class="line"># 并发送一个‘max number of clients reached’的错误。</span><br><span class="line">#</span><br><span class="line"># maxclients 10000</span><br><span class="line"> </span><br><span class="line"># 如果你设置了这个值，当缓存的数据容量达到这个值， redis 将根据你选择的</span><br><span class="line"># eviction 策略来移除一些 keys。</span><br><span class="line">#</span><br><span class="line"># 如果 redis 不能根据策略移除 keys ，或者是策略被设置为 ‘noeviction’，</span><br><span class="line"># redis 将开始响应错误给命令，如 set，lpush 等等，</span><br><span class="line"># 并继续响应只读的命令，如 get</span><br><span class="line">#</span><br><span class="line"># 我们甚至可以设置Redis可以使用的内存量。一旦到达内存使用上限，Redis将会试图移除内部数据，移除规则可以通 # 过maxmemory-policy来指定。</span><br><span class="line"></span><br><span class="line"># 如果Redis无法根据移除规则来移除内存中的数据，或者我们设置了“不允许移除”，那么Redis则会针对那些需要申请 # 内存的指令返回错误信息，比如SET、LPUSH等。但是对于无内存申请的指令，仍然会正常响应，比如GET等。</span><br><span class="line"># </span><br><span class="line"># 最大使用内存</span><br><span class="line"># maxmemory &lt;bytes&gt;</span><br><span class="line"> </span><br><span class="line"># 最大内存策略，你有 5 个选择。</span><br><span class="line"># </span><br><span class="line"># 需要注意的一点是，如果Redis是主Redis（说明Redis有从Redis），那么在设置内存使用上限时，需要在系统中留 # 出一些内存空间给同步队列缓存，只有在设置的是“不移除”的情况下，才不用考虑这个因素。</span><br><span class="line"></span><br><span class="line"># 对于内存移除规则来说，Redis提供了多达6种的移除规则。他们是：</span><br><span class="line">#（1）volatile-lru：使用LRU算法移除过期集合中的key</span><br><span class="line">#（2）allkeys-lru：使用LRU算法移除key</span><br><span class="line">#（3）volatile-random：在过期集合中移除随机的key</span><br><span class="line">#（4）allkeys-random：移除随机的key</span><br><span class="line">#（5）volatile-ttl：移除那些TTL值最小的key，即那些最近才过期的key。</span><br><span class="line">#（6）noeviction：不进行移除。针对写操作，只是返回错误信息。</span><br><span class="line"># 无论使用上述哪一种移除规则，如果没有合适的key可以移除的话，Redis都会针对写请求返回错误信息。</span><br><span class="line">#</span><br><span class="line"># maxmemory-policy noeviction</span><br><span class="line"> </span><br><span class="line"># LRU算法和最小TTL算法都并非是精确的算法，而是估算值。所以可以设置样本的大小。假如Redis默认会检查三个key # 并选择其中LRU的那个，那么可以改变这个key样本的数量。</span><br><span class="line">#</span><br><span class="line"># maxmemory-samples 5</span><br></pre></td></tr></table></figure>

<h3 id="6-AOF配置"><a href="#6-AOF配置" class="headerlink" title="6 AOF配置"></a>6 AOF配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">############################## APPEND ONLY MODE ###############################</span><br><span class="line"> </span><br><span class="line"># 默认情况下，Redis会异步的将数据持久化到磁盘。这种模式在大部分应用程序中已被验证是很有效的，但是在一些问 # 题发生时，比如断电，则这种机制可能会导致数分钟的写请求丢失。</span><br><span class="line"></span><br><span class="line"># 如上半部分中介绍的，AOF是一种更好的保持数据一致性的方式。即使当服务器断电时，也仅会有1秒钟的写请求丢 # # 失，当Redis进程出现问题且操作系统运行正常时，甚至只会丢失一条写请求。</span><br><span class="line"></span><br><span class="line"># 官方建议，AOF机制和RDB机制可以同时使用，不会有任何冲突。</span><br><span class="line"> </span><br><span class="line">appendonly no</span><br><span class="line"> </span><br><span class="line"># 我们还可以设置AOF文件的名称：</span><br><span class="line"> </span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"> </span><br><span class="line"># fsync()调用，用来告诉操作系统立即将缓存的指令写入磁盘。一些操作系统会“立即”进行，而另外一些操作系统则 # 会“尽快”进行。</span><br><span class="line"></span><br><span class="line"># Redis支持三种不同的模式：</span><br><span class="line"></span><br><span class="line">#（1）no：不调用fsync()。而是让操作系统自行决定sync的时间。这种模式下，Redis的性能会最快。</span><br><span class="line"></span><br><span class="line">#（2）always：在每次写请求后都调用fsync()。这种模式下，Redis会相对较慢，但数据最安全。</span><br><span class="line"></span><br><span class="line">#（3）everysec：每秒钟调用一次fsync()。这是性能和安全的折衷。</span><br><span class="line"></span><br><span class="line"># 默认情况下为everysec。</span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"># appendfsync no</span><br><span class="line"> </span><br><span class="line"># 当fsync方式设置为always或everysec时，如果后台持久化进程需要执行一个很大的磁盘IO操作，那么Redis可能会 # 在fsync()调用时卡住。目前尚未修复这个问题，这是因为即使我们在另一个新的线程中去执行fsync()，也会阻塞住 # 同步写调用。</span><br><span class="line"></span><br><span class="line"># 为了缓解这个问题，我们可以使用下面的配置项，这样的话，当BGSAVE或BGWRITEAOF运行时，fsync()在主进程中的 # 调用会被阻止。这意味着当另一路进程正在对AOF文件进行重构时，Redis的持久化功能就失效了，就好像我们设置 # # 了“appendsync none”一样。如果Redis有时延问题，那么可以将下面的选项设置为yes。否则请保持no，因为这是 # 保证数据完整性的最安全的选择。</span><br><span class="line"> </span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"> </span><br><span class="line"># 我们允许Redis自动重写aof。当aof增长到一定规模时，Redis会隐式调用BGREWRITEAOF来重写log文件，以缩减文 # 件体积。</span><br><span class="line"></span><br><span class="line"># Redis是这样工作的：Redis会记录上次重写时的aof大小。假如Redis自启动至今还没有进行过重写，那么启动时aof # 文件的大小会被作为基准值。这个基准值会和当前的aof大小进行比较。如果当前aof大小超出所设置的增长比例，则 # 会触发重写。另外还需要设置一个最小大小，是为了防止在aof很小时就触发重写。</span><br><span class="line"> </span><br><span class="line">auto-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line">auto-aof-rewrite-min-size <span class="number">64</span>mb</span><br></pre></td></tr></table></figure>

<h3 id="7-LUA脚本配置"><a href="#7-LUA脚本配置" class="headerlink" title="7 LUA脚本配置"></a>7 LUA脚本配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">################################ LUA SCRIPTING  ###############################</span><br><span class="line"> </span><br><span class="line"># ua脚本的最大运行时间是需要被严格限制的，单位是毫秒：</span><br><span class="line">lua-time-limit <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<h3 id="8-集群设置"><a href="#8-集群设置" class="headerlink" title="8 集群设置"></a>8 集群设置</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">################################ REDIS 集群  ###############################</span><br><span class="line">#</span><br><span class="line"># 启用或停用集群</span><br><span class="line"># cluster-enabled yes</span><br><span class="line"> </span><br><span class="line"># 每个集群节点都有一个集群配置文件，该文件是由集群节点来创建和维护的，不能人工参与。每个集群节点需要不同 # 的配置文件，所以需要保证同一个系统下的集群节点没有重名的配置文件，建议以端口号标记配置文件。</span><br><span class="line">#</span><br><span class="line"># cluster-config-file nodes-6379.conf</span><br><span class="line"> </span><br><span class="line"># 当节点超时大于cluster-node-timeout的时候后，就会被认为宕机了，单位为毫秒。</span><br><span class="line">#</span><br><span class="line"># cluster-node-timeout 15000</span><br><span class="line"> </span><br><span class="line"># Redis集群有一种failover（故障转移）机制，即当主Redis宕机之后，会有一个最合适的从Redis充当主Redis。但 # 是，当从Redis的数据“太老”了，与住Redis的标准数据偏差很大，为了保证数据一致性，Redis会放弃failover。判 # 别从Redis的的数据是不是“太老”有两种方法：</span><br><span class="line"></span><br><span class="line">#（1）如果有多个从Redis可以接替主Redis的工作，则它们会交换信息，选取“最佳复制偏移”（接受了原主Redis最多的数据同步）的从Redis作为下一任主Redis。</span><br><span class="line"></span><br><span class="line">#（2）每个从Redis计算与原主Redis最后一次数据同步的时间，当最短的时间间隔大于某个临界点的时候，集群则放弃failover。</span><br><span class="line"></span><br><span class="line"># 方法（2）当中的临界点可以通过配置调节，临界点的计算规则为：</span><br><span class="line"></span><br><span class="line"># (node-timeout * slave-validity-factor)+ repl-ping-slave-period</span><br><span class="line"></span><br><span class="line"># 如node-timeout为30秒，slave-validity-factor为10秒，repl-ping-slave-period为10秒，当与原主Redis最 # 后一次对话的时间间隔超过310秒的时候，集群就会放弃failover。</span><br><span class="line"></span><br><span class="line"># 当slave-validity-factor太大会使一台数据“太老”的从Redis充当主Redis；而slave-validity-factor太小可能 # 会造成找不到合适的从Redis继任。</span><br><span class="line">#</span><br><span class="line"># cluster-slave-validity-factor 10</span><br><span class="line"> </span><br><span class="line"># 考虑一种极端情况，集群有一台主Redis和四台从Redis，从Redis全部挂掉，failover机制有可能造成集群只有主 # # Redis而无从Redis的尴尬境况。为了保证集群的名副其实，可以规定，当从Redis少于某个数量时，拒绝执行 #   # # failover。  </span><br><span class="line">#</span><br><span class="line"># cluster-migration-barrier 1</span><br><span class="line"> </span><br><span class="line"># 默认情况下，当集群检测到某个哈希槽（hash slot）没有被覆盖（没有任何节点为此服务）会停止接受查询服务， # 如果集群部分宕机最终会导致整个集群不可用，当哈希槽重新被全覆盖的时候会自动变为可用。如果希望那些哈希槽 # 被 覆盖的集群节点继续接受查询服务，需要将cluster-require-full-coverage设置为no。</span><br><span class="line"># cluster-require-full-coverage yes</span><br></pre></td></tr></table></figure>

<h3 id="9-慢日志配置"><a href="#9-慢日志配置" class="headerlink" title="9 慢日志配置"></a>9 慢日志配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">################################## SLOW LOG ###################################</span><br><span class="line"> </span><br><span class="line"># Redis慢日志是指一个系统进行日志查询超过了指定的时长。这个时长不包括IO操作，比如与客户端的交互、发送响 # 应内容等，而仅包括实际执行查询命令的时间。</span><br><span class="line"></span><br><span class="line"># 针对慢日志可以设置两个参数，一个是执行时长，单位是微秒，另一个是慢日志的长度。当一个新的命令被写入日志 # 时，最老的一条会从命令日志队列中被移除。单位是微秒，即1000000表示一秒。负数则会禁用慢日志功能，而0则表 # 示强制记录每一个命令。</span><br><span class="line">slowlog-log-slower-than <span class="number">10000</span></span><br><span class="line"> </span><br><span class="line"># 慢日志最大长度，可以随便填写数值，没有上限，但要注意它会消耗内存。可以使用SLOWLOG RESET来重设这个值。</span><br><span class="line">slowlog-max-len <span class="number">128</span></span><br></pre></td></tr></table></figure>

<h3 id="10-事件通知配置"><a href="#10-事件通知配置" class="headerlink" title="10 事件通知配置"></a>10 事件通知配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">############################# Event notification ##############################</span><br><span class="line"> </span><br><span class="line"># Redis可以向客户端通知某些事件的发生。</span><br><span class="line"></span><br><span class="line"># 例如，键空间（keyspace）时间通知如果开启，一个客户端对Database 0中的“foo”键执行了DEL操作，两条信息会 # 通过Pub/Sub发布出去：</span><br><span class="line"></span><br><span class="line"># PUBLISH__keyspace@0__:foo del</span><br><span class="line"># PUBLISH__keyevent@0__:del foo</span><br><span class="line"></span><br><span class="line"># 可以选择需要发送哪种类型的通知，每种类型用一个字母代表：</span><br><span class="line"># K     键空间事件,发布到“__keyspace@&lt;db&gt;__ prefix”频道</span><br><span class="line"># E     键事件, 发布到“ __keyevent@&lt;db&gt;__ prefix”频道</span><br><span class="line"># g     通用事件，比如 DEL,EXPIRE, RENAME, ...等操作都属于</span><br><span class="line"># $     String操作</span><br><span class="line"># l     List操作</span><br><span class="line"># s     Set操作</span><br><span class="line"># h     Hash操作</span><br><span class="line"># z     Sorted set操作</span><br><span class="line"># x     过期操作</span><br><span class="line"># e    驱逐操作（因为内存不足数据被删除）</span><br><span class="line"># A    代表“g$lshzxe”的组合, 所以“AKE”可以代表所有事件</span><br><span class="line"></span><br><span class="line"># notify-keyspace-events配置以上述的字母组合为参数，举例说明：</span><br><span class="line">#（1）notify-keyspace-events Elg</span><br><span class="line"># 当有List操作或通用操作，发布通知到“ __keyevent@&lt;db&gt;__ prefix”频道</span><br><span class="line">#（2）notify-keyspace-events Ex</span><br><span class="line"># 当有键的过期操作时，发布通知到“__keyevent@0__:expired”频道</span><br><span class="line"># 默认情况下，notify-keyspace-events的参数为空字符串，代表关闭通知。</span><br><span class="line">notify-keyspace-events <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="11-高级配置"><a href="#11-高级配置" class="headerlink" title="11 高级配置"></a>11 高级配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">############################### ADVANCED CONFIG ###############################</span><br><span class="line"> </span><br><span class="line"># Hash在条目数量较小的时候会使用一种高效的内存数据结构编码，当超过某个临界点就会采用另一种存储方式，该临 # 界点由下面的两个配置决定：</span><br><span class="line">hash-max-ziplist-entries <span class="number">512</span></span><br><span class="line">hash-max-ziplist-value <span class="number">64</span></span><br><span class="line"> </span><br><span class="line"># 与Hash类似，较小的List会以一种特殊的编码方式来节省空间，只要List不超过下面的上限：</span><br><span class="line">list-max-ziplist-entries <span class="number">512</span></span><br><span class="line">list-max-ziplist-value <span class="number">64</span></span><br><span class="line"> </span><br><span class="line"># Set只有在满足下面的条件时才会采用特殊编码方式：Set中存储的恰好都是十进制的整数，而且长度不超过64位（有 # 符号）。数量上限为：</span><br><span class="line">set-max-intset-entries <span class="number">512</span></span><br><span class="line"> </span><br><span class="line"># 同样，有序集合也会采用特殊编码来节省空间，只要不超过上限：</span><br><span class="line">zset-max-ziplist-entries <span class="number">128</span></span><br><span class="line">zset-max-ziplist-value <span class="number">64</span></span><br><span class="line"> </span><br><span class="line"># RedisHyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大 # # 时，计算基数所需的空间总是固定并且很小的。当HyperLogLog用稀疏式表示法时所用内存超过下面的限制，就会转 # 换成稠密式表示，为了更高的内存利用率，官方建议值为3000。</span><br><span class="line">hll-sparse-max-bytes <span class="number">3000</span></span><br><span class="line"> </span><br><span class="line"># Redis 在每 100 毫秒时使用 1 毫秒的 CPU时间来对 Redis 的 hash 表进行重新 hash 。当使用场景中有非常严 # 格的实时性需要，不能够接受 Redis 时不时的对请求有 2 毫秒的延迟的话，把这项配置为 no 。</span><br><span class="line"></span><br><span class="line"># 如果没有这么严格的实时性要求，可以设置为 yes ，以便能够尽可能快的释放内存。</span><br><span class="line">activerehashing yes</span><br><span class="line"> </span><br><span class="line"># 客户端的输出缓冲区的限制，因为某种原因客户端从服务器读取数据的速度不够快，可用于强制断开连接（一个常见 # 的原因是一个发布 / 订阅客户端消费消息的速度无法赶上生产它们的速度）。</span><br><span class="line"></span><br><span class="line"># 可以三种不同客户端的方式进行设置：</span><br><span class="line">#（1）normal -&gt; 正常客户端</span><br><span class="line">#（2）slave -&gt; slave 和 MONITOR 客户端</span><br><span class="line">#（3）pubsub -&gt; 至少订阅了一个 pubsub channel 或 pattern 的客户端</span><br><span class="line"></span><br><span class="line"># 每个client-output-buffer-limit 语法 :</span><br><span class="line"># client-output-buffer-limit&lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt; 一旦达到硬限制客户端# 会立即断开，或者达到软限制并保持达成的指定秒数（连续）。</span><br><span class="line"></span><br><span class="line"># 例如，如果硬限制为 32 兆字节和软限制为 16 兆字节 /10 秒，如果输出缓冲区的大小达到 32 兆字节，客户端将# 会立即断开，客户端达到 16 兆字节和连续超过了限制 10 秒，也将断开连接。</span><br><span class="line"></span><br><span class="line"># 默认 normal 客户端不做限制，因为他们在一个请求后未要求时（以推的方式）不接收数据，只有异步客户端可能会# 出现请求数据的速度比它可以读取的速度快的场景。</span><br><span class="line"></span><br><span class="line"># 把硬限制和软限制都设置为 0 来禁用该特性</span><br><span class="line"></span><br><span class="line">client-output-buffer-limit normal <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">client-output-buffer-limit slave <span class="number">256</span>mb <span class="number">64</span>mb <span class="number">60</span></span><br><span class="line">client-output-buffer-limit pubsub <span class="number">32</span>mb <span class="number">8</span>mb <span class="number">60</span></span><br><span class="line"> </span><br><span class="line"># Redis会按照一定的频率来执行后台任务，比如关闭超时的客户端，清除过期键等。不是所有的任务都会按照相同的频 # 率来执行，但Redis 依照指定的“ Hz ”值来执行检查任务。</span><br><span class="line">hz <span class="number">10</span></span><br><span class="line"> </span><br><span class="line"># aof rewrite过程中，是否采取增量文件同步策略，默认为“yes”。 rewrite过程中,每32M数据进行一次文件同步， # 这样可以减少aof大文件写入对磁盘的操作次数。</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure>






    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Redis/" rel="tag"># Redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/26/Redis/2019-03-05%205%20redis%E6%8C%81%E4%B9%85%E5%8C%96/" rel="prev" title="05 redis持久化">
      <i class="fa fa-chevron-left"></i> 05 redis持久化
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/26/Redis/2019-03-07%207%20redis%E9%9B%86%E7%BE%A4/" rel="next" title="07 redis集群">
      07 redis集群 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">1.</span> <span class="nav-text">1 通用配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%BF%AB%E7%85%A7%E9%85%8D%E7%BD%AE"><span class="nav-number">2.</span> <span class="nav-text">2 快照配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE"><span class="nav-number">3.</span> <span class="nav-text">3 主从配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">4.</span> <span class="nav-text">4 安全配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E9%99%90%E5%88%B6%E9%85%8D%E7%BD%AE"><span class="nav-number">5.</span> <span class="nav-text">5 限制配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-AOF%E9%85%8D%E7%BD%AE"><span class="nav-number">6.</span> <span class="nav-text">6 AOF配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-LUA%E8%84%9A%E6%9C%AC%E9%85%8D%E7%BD%AE"><span class="nav-number">7.</span> <span class="nav-text">7 LUA脚本配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E9%9B%86%E7%BE%A4%E8%AE%BE%E7%BD%AE"><span class="nav-number">8.</span> <span class="nav-text">8 集群设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E6%85%A2%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE"><span class="nav-number">9.</span> <span class="nav-text">9 慢日志配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5%E9%85%8D%E7%BD%AE"><span class="nav-number">10.</span> <span class="nav-text">10 事件通知配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE"><span class="nav-number">11.</span> <span class="nav-text">11 高级配置</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="QingSong"
      src="/images/avatar/avatar.png">
  <p class="site-author-name" itemprop="name">QingSong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">161</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QingSong</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
