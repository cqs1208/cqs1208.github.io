<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="springboot">
<meta property="og:type" content="article">
<meta property="og:title" content="03 spring 实现自动配置">
<meta property="og:url" content="http://example.com/2020/10/26/SpringBoot/2019-02-03%203%20%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="springboot">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/SpringBoot/SpringBoot_genericConverter.png">
<meta property="og:image" content="http://example.com/images/SpringBoot/SpringBoot_autoConfigurationPackages.png">
<meta property="og:image" content="http://example.com/images/SpringBoot/SpringBoot_enableAutoConfigurationImportSelector.png">
<meta property="article:published_time" content="2020-10-26T03:56:48.385Z">
<meta property="article:modified_time" content="2020-08-11T09:28:29.000Z">
<meta property="article:author" content="QingSong">
<meta property="article:tag" content="Springboot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/SpringBoot/SpringBoot_genericConverter.png">

<link rel="canonical" href="http://example.com/2020/10/26/SpringBoot/2019-02-03%203%20%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>03 spring 实现自动配置 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">点滴积累 豁达处之</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/26/SpringBoot/2019-02-03%203%20%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar/avatar.png">
      <meta itemprop="name" content="QingSong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          03 spring 实现自动配置
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-26 11:56:48" itemprop="dateCreated datePublished" datetime="2020-10-26T11:56:48+08:00">2020-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-11 17:28:29" itemprop="dateModified" datetime="2020-08-11T17:28:29+08:00">2020-08-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Springboot/" itemprop="url" rel="index"><span itemprop="name">Springboot</span></a>
                </span>
            </span>

          
            <div class="post-description">springboot</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Spring中纷繁复杂的配置文件一直让广大开发人员颇有微词，但是随着业务的复杂度越来越高，这也是在所难免的事情。</p>
<a id="more"></a> 

<h1 id="1-Spring-Boot实现自动配置的基础"><a href="#1-Spring-Boot实现自动配置的基础" class="headerlink" title="1.Spring Boot实现自动配置的基础"></a>1.Spring Boot实现自动配置的基础</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><h3 id="问题是什么"><a href="#问题是什么" class="headerlink" title="问题是什么"></a>问题是什么</h3><p>Spring中纷繁复杂的配置文件一直让广大开发人员颇有微词，但是随着业务的复杂度越来越高，这也是在所难免的事情。</p>
<p>哪怕是要创建一个简单的Web应用，需要配置的东西也是一坨坨的，这个过程虽然不复杂但是很繁琐，而且非常容易出错。所以聪明的开发人员想出了很多办法来解决这个问题，比如Maven的Archetype创建，又或者各个公司内部的脚手架小工具。但是这些方案总是有这样那样的问题，比如维护不方便，不好定制等等。</p>
<p>在云计算，弹性计算以及微服务越来越普及的今天，急需要一种自动配置的方式，从而方便地按需部署。所以Spring Boot应用而生，而自动配置作为Spring Boot的闪光点之一，自然非常受人关注。</p>
<p>Spring Boot的自动配置功能，其实从本质上说并没有引入什么新功能，它只是将Spring现存的能力做了一次组合和封装。那么在深入了解Spring Boot的自动配置原理之前，可以先了解一下Spring的这些已知能力，打下良好地基础。</p>
<h2 id="和配置相关的Spring已有能力"><a href="#和配置相关的Spring已有能力" class="headerlink" title="和配置相关的Spring已有能力"></a>和配置相关的Spring已有能力</h2><h3 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h3><p>很多时候，我们开发的Spring应用，需要根据所在环境的不同注册相应的Bean到上下文中。</p>
<p>比如本地开发环境中，数据库连接对象往往指向的是开发数据库；在测试环境中，又会指向测试数据库；而到了线上，指向的自然是生产数据库。</p>
<p>为了满足这个常见需求，Spring 3.1中引入了Profile的概念。比如在下面的代码中，配置类会根据所在环境(Profile)的不同，向上下文中注入对应的Bean实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfiguration</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;DEV&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">devDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;TEST&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">testDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;PROD&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">prodDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，如何声明应用所处的Profile呢？还是有几种选择：</p>
<ol>
<li>配置文件，比如在application.properties中声明<code>spring.profiles.active=DEV</code></li>
<li>启动参数，比如<code>-Dspring.profiles.active=DEV</code></li>
</ol>
<p>这个Profile的概念很直观，但是由于它仅仅是依赖一个字符串的值作出决策，所以不够灵活和强大。因此就有了下面@Conditional注解和Condition接口的诞生。</p>
<h3 id="Conditional以及Condition接口"><a href="#Conditional以及Condition接口" class="headerlink" title="@Conditional以及Condition接口"></a>@Conditional以及Condition接口</h3><p>它们是Spring 4中引入的新功能。</p>
<p>Condition接口和@Conditional接口通常会一起配合使用。</p>
<p>Condition接口的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 决定Condition是否被满足</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadata 类或方法上的元数据注解信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个该接口的实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过一系列计算决定Condition是否被满足，如果满足返回true，反之返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Conditional注解的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Conditional &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该注解接受的默认参数类型是一个Class数组，这些Class都应该实现Condition接口，并且当其中的matches都返回true的时候，对应的Bean才会被注入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends Condition&gt;[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后一般在Java Config类中将它们结合在一起使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当CustomCondition中的matches返回true的时候才会注入CustomClass这个类的实例Bean。</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Conditional(CustomCondition.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomClass <span class="title">customClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此通过将@Conditional注解和Condition接口的能力进行结合，就可以实现根据外界条件来决定一个Bean是不是应该被加载到Spring上下文中。对比一下@Profile注解，可以发现这种方式提供了更高的灵活度。</p>
<p>在@Profile注解中，唯一决定是否加载一个Bean的是一个字符串，即所在环境的标识符例如DEV，TEST，PRODUCTION这类。但是在@Conditional的方案中，决定是否加载的逻辑被抽象到了Condition接口中，这样能够做的判断就非常多了。</p>
<h3 id="ConfigurationProperties以及-EnableConfigurationProperties"><a href="#ConfigurationProperties以及-EnableConfigurationProperties" class="headerlink" title="@ConfigurationProperties以及@EnableConfigurationProperties"></a>@ConfigurationProperties以及@EnableConfigurationProperties</h3><p>要实现自动配置，还有一个比较关键的环节。我们都知道Bean之所以有意义是因为每个Bean中都有自己独特的字段，而很多情况下，Bean中的字段都是可配置的。因此，要实现自动配置，我们首先需要对一些关键字段给予一个默认值，当然也需要提供一个机制让用户能够对这些字段进行覆盖。在Spring Boot中，提供了一个新的机制叫做Configuration Properties(可配置的属性)，它有几个特点：</p>
<ol>
<li>类型安全的配置方式(基于Java类)，基于Spring Conversion API完成类型转换</li>
<li>可以通过配置文件，启动参数等多种方式完成覆盖</li>
<li>和JavaConfig类无缝集成</li>
</ol>
<p>这个机制有两个关键的注解类型，即@ConfigurationProperties和@EnableConfigurationProperties。下面我们就来看看它们的定义以及如何应用：</p>
<h4 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h4><p><strong>@ConfigurationProperties</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConfigurationProperties &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;prefix&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">prefix</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只捡主要的属性介绍，这个注解中比较关键的就是value/prefix属性。这两个属性是一个意思，互相设置了@AliasFor。</p>
<p><strong>@EnableConfigurationProperties</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于支持<span class="doctag">@ConfigurationProperties</span>标注的Beans。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>注解的Bean也可以通过标准方式(比如使用<span class="doctag">@Bean</span>方法)，但是这个注解提供了一个更方便的方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(EnableConfigurationPropertiesImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableConfigurationProperties &#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用方式"><a href="#应用方式" class="headerlink" title="应用方式"></a>应用方式</h4><p>以Spring Web应用中需要的HttpEncodingFilter这个Filter的自动配置为例，看看如何应用这两注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.http.encoding&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_CHARSET = Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Charset charset = DEFAULT_CHARSET;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Boolean force;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个配置类，它设置了前缀spring.http.encoding。因此，这个配置类中的字段都会对应某一个具体的配置KEY，比如charset字段对应的配置KEY为spring.http.encoding.charse; force字段对应的是spring.http.encoding.force。同时可以给每个字段设置一个默认值，比如上述的charset字段就有一个默认值DEFAULT_CHARSET，对应的是UTF-8的字符集。</p>
<p>如果我们不想用默认的UTF-8编码方式，想换成GBK，那么在配置文件(如application.properties中)，可以进行如下覆盖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.http.encoding.charset=GBK1</span><br></pre></td></tr></table></figure>

<p>这里有个地方值得一提，在配置文件中的GBK明明是字符串类型的值，而在对应的配置属性类这个属性是Charset类型的，那么肯定是有一个步骤完成了从字符串到Charset类型的转换工作。完成这个步骤的就是Spring框架中的Conversion API。这里只贴一张相关的图，不进行深入分析，感兴趣的同学可以在配置属性类的setCharset方法上打个断点然后深挖一下。<img src="/images/SpringBoot/SpringBoot_genericConverter.png" alt="genericConverter"></p>
<p>从这张图可以看出，Spring Conversion API中维护了一系列Converters，它实际上是一个从源类型到目标类型的Map对象。从String类型到Charset类型的Converter也被注册到了这个Map对象中。因此，当发现配置文件中的值类型和配置Java类中的字段类型不匹配时，就会去尝试从这个Map中找到相应的Converter，然后进行转换。</p>
<h3 id="自定义注解实现自动配置"><a href="#自定义注解实现自动配置" class="headerlink" title="自定义注解实现自动配置"></a>自定义注解实现自动配置</h3><p>下面我们尝试来创建一个自定义的注解，实现Bean的按需加载。假设我们要创建的注解名为@DatabaseType。</p>
<p>具体的需求是：当启动参数中的dbType=MYSQL的时候，创建一个数据源为MySQL的UserDAO对象；当启动参数中的dbType=ORACLE的时候，创建一个数据源为Oracle的UserDAO对象。</p>
<p>最终配置类的代码可以是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseConfiguration</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@DatabaseType(&quot;MYSQL&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserDAO <span class="title">mysqlUserDAO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MySQLUserDAO();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@DatabaseType(&quot;ORACLE&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserDAO <span class="title">oracleUserDAO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> OracleUserDAO();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以知道，@DatabaseType这个注解能够接受一个字符串作为参数。然后将该参数和启动参数中的dbType值进行比对，如果相等的话，就会进行对应Bean的注入工作。@DatabaseType的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Conditional(DatabaseTypeCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DatabaseType &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中比较重要的是<code>@Conditional(DatabaseTypeCondition.class)</code>，表明它的觉得实际上也是委托给了DatabaseTypeCondition这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseTypeCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里也展示了AnnotatedTypeMetadata这个参数的用法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext conditionContext, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; attributes = metadata.getAnnotationAttributes(DatabaseType.class.getName());</span><br><span class="line">        String type = (String) attributes.get(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        String enabledDBType = System.getProperty(<span class="string">&quot;dbType&quot;</span>, <span class="string">&quot;MYSQL&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (enabledDBType != <span class="keyword">null</span> &amp;&amp; type != <span class="keyword">null</span> &amp;&amp; enabledDBType.equalsIgnoreCase(type));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过matches方法的第二个参数AnnotatedTypeMetadata，可以得到指定注解类型的所有属性，本例中就是@DatabaseType这个注解。然后将注解中的value值和启动参数dbType(不存在时使用MYSQL作为默认值)进行比对，然后返回相应的值来决定是否需要注入Bean。</p>
<p>所以，通过这个例子我们也可以发现。通常而言为了程序的可读性，可以将@Conditional和Condition接口的实现类给封装到一个业务含义更加明确的注解类型中，比如上面的@DatabaseType类型。它的意义就很明确，当类型是MySQL的该如何如何，当类型为Oracle的时候又当如何如何。</p>
<p>在后面深究Spring Boot的自动配置机制时，可以发现它也在@Conditional和Condition接口的基础上，定义了很多相关类型，用于更好地定义自动配置行为。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了Spring中和自动配置相关的两个概念：</p>
<ol>
<li>@Profile</li>
<li>@Conditional以及Condition接口</li>
</ol>
<h1 id="2-Spring-Boot实现自动配置的原理"><a href="#2-Spring-Boot实现自动配置的原理" class="headerlink" title="2.Spring Boot实现自动配置的原理"></a>2.Spring Boot实现自动配置的原理</h1><h2 id="入口注解类-EnableAutoConfiguration"><a href="#入口注解类-EnableAutoConfiguration" class="headerlink" title="入口注解类@EnableAutoConfiguration"></a>入口注解类@EnableAutoConfiguration</h2><p>@SpringBootApplication注解中包含了自动配置的入口注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(EnableAutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个注解的Javadoc内容还是不少，所有就不贴在文章里面了，概括一下：</p>
<ol>
<li>自动配置基于应用的类路径以及你定义了什么Beans</li>
<li>如果使用了@SpringBootApplication注解，那么自动就启用了自动配置</li>
<li>可以通过设置注解的excludeName属性或者通过spring.autoconfigure.exclude配置项来指定不需要自动配置的项目</li>
<li>自动配置的发生时机在用户定义的Beans被注册之后</li>
<li>如果没有和@SpringBootApplication一同使用，最好将@EnableAutoConfiguration注解放在root package的类上，这样就能够搜索到所有子packages中的类了</li>
<li>自动配置类就是普通的Spring @Configuration类，通过SpringFactoriesLoader机制完成加载，实现上通常使用@Conditional(比如@ConditionalOnClass或者@ConditionalOnMissingBean)</li>
</ol>
<h3 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个注解的职责就是引入了另外一个配置类：AutoConfigurationPackages.Registrar。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ImportBeanDefinitionRegistrar用来从导入的Config中保存base package</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">            BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        register(registry, <span class="keyword">new</span> PackageImport(metadata).getPackageName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.&lt;Object&gt;singleton(<span class="keyword">new</span> PackageImport(metadata));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个注解实现的功能已经比较底层了，调试看看上面的register方法什么会被调用<img src="/images/SpringBoot/SpringBoot_autoConfigurationPackages.png" alt="AutoConfigurationPackages"></p>
<p>调用参数中的packageNames数组中仅包含一个值：com.example.demo，也就是项目的root package名。</p>
<p>从调用栈来看的话，调用register方法的时间在容器刷新期间：</p>
<p>refresh -&gt; invokeBeanFactoryPostProcessors -&gt; invokeBeanDefinitionRegistryPostProcessors -&gt; postProcessBeanDefinitionRegistry -&gt; processConfigBeanDefinitions(开始处理配置Bean的定义) -&gt; loadBeanDefinitions -&gt; loadBeanDefinitionsForConfigurationClass(读取配置Class中的Bean定义) -&gt; loadBeanDefinitionsFromRegistrars(这里开始准备进入上面的register方法) -&gt; registerBeanDefinitions(即上述方法)</p>
<p>这个过程已经比较复杂了，目前暂且不深入研究了。它的功能简单说就是将应用的root package给注册到Spring容器中，供后续使用。</p>
<p>相比而言，下面要讨论的几个类型才是实现自动配置的关键。</p>
<h3 id="Import-EnableAutoConfigurationImportSelector-class"><a href="#Import-EnableAutoConfigurationImportSelector-class" class="headerlink" title="@Import(EnableAutoConfigurationImportSelector.class)"></a>@Import(EnableAutoConfigurationImportSelector.class)</h3><p>@EnableAutoConfiguration注解的另外一个作用就是引入了EnableAutoConfigurationImportSelector：</p>
<p>它的类图如下所示：</p>
<p> <img src="/images/SpringBoot/SpringBoot_enableAutoConfigurationImportSelector.png" alt="En"></p>
<p>可以发现它除了实现几个Aware类接口外，最关键的就是实现了DeferredImportSelector(继承自ImportSelector)接口。</p>
<p>所以我们先来看看ImportSelector以及DeferredImportSelector接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于被引入的Configuration类的AnnotationMetadata信息选择并返回需要引入的类名列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口的Javadoc比较长，还是捡重点说明一下：</p>
<ol>
<li>主要功能通过selectImports方法实现，用于筛选需要引入的类名</li>
<li>实现了ImportSelector的类也可以实现一系列Aware接口，这些Aware接口中的相应方法会在selectImports方法之前被调用(这一点通过上面的类图也可以佐证，EnableAutoConfigurationImportSelector确实实现了四个Aware类型的接口)</li>
<li>ImportSelector的实现和通常的@Import在处理方式上是一致的，然而还是可以在所有@Configuration类都被处理后再进行引入筛选(具体看下面即将介绍的DeferredImportSelector)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeferredImportSelector</span> <span class="keyword">extends</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口是一个标记接口，它本身没有定义任何方法。那么这个接口的含义是什么呢：</p>
<ol>
<li>它是ImportSelector接口的一个变体，在所有的@Configuration被处理之后才会执行。在需要筛选的引入类型具备@Conditional注解的时候非常有用</li>
<li>实现类同样也可以实现Ordered接口，来定义多个DeferredImportSelector的优先级别(同样地，EnableAutoConfigurationImportSelector也实现了Ordered接口)</li>
</ol>
<p>明确了这两个接口的意义，下面来看看是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Step1: 得到注解信息</span></span><br><span class="line">        AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">                .loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">        <span class="comment">// Step2: 得到注解中的所有属性信息</span></span><br><span class="line">        AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">        <span class="comment">// Step3: 得到候选配置列表</span></span><br><span class="line">        List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">                attributes);</span><br><span class="line">        <span class="comment">// Step4: 去重</span></span><br><span class="line">        configurations = removeDuplicates(configurations);</span><br><span class="line">        <span class="comment">// Step5: 排序</span></span><br><span class="line">        configurations = sort(configurations, autoConfigurationMetadata);</span><br><span class="line">        <span class="comment">// Step6: 根据注解中的exclude信息去除不需要的</span></span><br><span class="line">        Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">        checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">        <span class="comment">// Step7: 派发事件</span></span><br><span class="line">        fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        <span class="keyword">return</span> configurations.toArray(<span class="keyword">new</span> String[configurations.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，核心就在于上面的步骤3：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">        AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">            getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations,</span><br><span class="line">            <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class="line">                    + <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它将实现委托给了SpringFactoriesLoader的loadFactoryNames方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入的factoryClass：org.springframework.boot.autoconfigure.EnableAutoConfiguration</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String factoryClassName = factoryClass.getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            URL url = urls.nextElement();</span><br><span class="line">            Properties properties = PropertiesLoaderUtils.loadProperties(<span class="keyword">new</span> UrlResource(url));</span><br><span class="line">            String factoryClassNames = properties.getProperty(factoryClassName);</span><br><span class="line">            result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load [&quot;</span> + factoryClass.getName() +</span><br><span class="line">                <span class="string">&quot;] factories from location [&quot;</span> + FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相关常量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">&quot;META-INF/spring.factories&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这段代码的意图很明确，在第一篇文章讨论Spring Boot启动过程的时候就已经接触到了。它会从类路径中拿到所有名为META-INF/spring.factories的配置文件，然后按照factoryClass的名称取到对应的值。那么我们就来找一个META-INF/spring.factories配置文件看看。</p>
<h4 id="META-INF-spring-factories"><a href="#META-INF-spring-factories" class="headerlink" title="META-INF/spring.factories"></a>META-INF/spring.factories</h4><p>比如spring-boot-autoconfigure包：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span><br><span class="line"># 省略了很多12345678910</span><br></pre></td></tr></table></figure>

<p>列举了非常多的自动配置候选项，挑一个AOP相关的AopAutoConfiguration看看究竟：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果设置了spring.aop.auto=false，那么AOP不会被配置</span></span><br><span class="line"><span class="comment">// 需要检测到@EnableAspectJAutoProxy注解存在才会生效</span></span><br><span class="line"><span class="comment">// 默认使用JdkDynamicAutoProxyConfiguration，如果设置了spring.aop.proxy-target-class=true，那么使用CglibAutoProxyConfiguration</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; EnableAspectJAutoProxy.class, Aspect.class, Advice.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;auto&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = false)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;false&quot;, matchIfMissing = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;, matchIfMissing = false)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个自动配置类的作用是判断是否存在配置项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.aop.proxy-target-class&#x3D;true1</span><br></pre></td></tr></table></figure>

<p>如果存在并且值为true的话使用基于CGLIB字节码操作的动态代理方案，否则使用JDK自带的动态代理机制。</p>
<p>在这个配置类中，使用到了两个全新的注解：</p>
<ul>
<li>@ConditionalOnClass</li>
<li>@ConditionalOnProperty</li>
</ul>
<p>从这两个注解的名称，就大概能够猜出它们的功能了：</p>
<p><strong>@ConditionalOnClass</strong></p>
<p>当类路径上存在指定的类时，满足条件。</p>
<p><strong>@ConditionalOnProperty</strong></p>
<p>当配置中存在指定的属性时，满足条件。</p>
<p>其实除了这两个注解之外，还有几个类似的，它们都在org.springframework.boot.autoconfigure.condition这个包下，在具体介绍实现之前，下面先来看看Spring Boot对于@Conditional的扩展。=</p>
<h2 id="Spring-Boot对于-Conditional的扩展"><a href="#Spring-Boot对于-Conditional的扩展" class="headerlink" title="Spring Boot对于@Conditional的扩展"></a>Spring Boot对于@Conditional的扩展</h2><p>Spring Boot提供了一个实现了Condition接口的抽象类SpringBootCondition。</p>
<p>这个类的主要作用是打印一些用于诊断的日志，告诉用户哪些类型被自动配置了。</p>
<p>它实现Condition接口的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">        AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">    String classOrMethodName = getClassOrMethodName(metadata);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ConditionOutcome outcome = getMatchOutcome(context, metadata);</span><br><span class="line">        logOutcome(classOrMethodName, outcome);</span><br><span class="line">        recordEvaluation(context, classOrMethodName, outcome);</span><br><span class="line">        <span class="keyword">return</span> outcome.isMatch();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoClassDefFoundError ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">&quot;Could not evaluate condition on &quot;</span> + classOrMethodName + <span class="string">&quot; due to &quot;</span></span><br><span class="line">                        + ex.getMessage() + <span class="string">&quot; not &quot;</span></span><br><span class="line">                        + <span class="string">&quot;found. Make sure your own configuration does not rely on &quot;</span></span><br><span class="line">                        + <span class="string">&quot;that class. This can also happen if you are &quot;</span></span><br><span class="line">                        + <span class="string">&quot;@ComponentScanning a springframework package (e.g. if you &quot;</span></span><br><span class="line">                        + <span class="string">&quot;put a @ComponentScan in the default package by mistake)&quot;</span>,</span><br><span class="line">                ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">&quot;Error processing condition on &quot;</span> + getName(metadata), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine the outcome of the match along with suitable log output.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context the condition context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata the annotation metadata</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the condition outcome</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ConditionOutcome <span class="title">getMatchOutcome</span><span class="params">(ConditionContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">        AnnotatedTypeMetadata metadata)</span></span>;</span><br></pre></td></tr></table></figure>

<p>SpringBootCondition已经提供了基本的实现，将内部的匹配细节定义成抽象方法getMatchOutcome，交给其子类去完成。</p>
<p>另外，还提供了两个可能会被子类使用到的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果指定的conditions中有任意一个匹配，那么就返回true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context the context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata the annotation meta-data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conditions conditions to test</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if any condition matches.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">anyMatches</span><span class="params">(ConditionContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">        AnnotatedTypeMetadata metadata, Condition... conditions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Condition condition : conditions) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matches(context, metadata, condition)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查指定的condition是否匹配</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context the context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata the annotation meta-data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> condition condition to test</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the condition matches.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">        AnnotatedTypeMetadata metadata, Condition condition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition <span class="keyword">instanceof</span> SpringBootCondition) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((SpringBootCondition) condition).getMatchOutcome(context, metadata)</span><br><span class="line">                .isMatch();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> condition.matches(context, metadata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="org-springframework-boot-autoconfigure-condition包"><a href="#org-springframework-boot-autoconfigure-condition包" class="headerlink" title="org.springframework.boot.autoconfigure.condition包"></a>org.springframework.boot.autoconfigure.condition包</h3><p>除了上面已经遇到的@ConditionalOnClass和@ConditionalOnProperty，这个包中还定义了很多条件实现类，下面简单列举几个：</p>
<h4 id="ConditionalOnExpression-基于SpEL的条件判断"><a href="#ConditionalOnExpression-基于SpEL的条件判断" class="headerlink" title="@ConditionalOnExpression - 基于SpEL的条件判断"></a>@ConditionalOnExpression - 基于SpEL的条件判断</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configuration annotation for a conditional element that depends on the value of a SpEL</span></span><br><span class="line"><span class="comment"> * expression.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional(OnExpressionCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnExpression &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The SpEL expression to evaluate. Expression should return &#123;<span class="doctag">@code</span> true&#125; if the</span></span><br><span class="line"><span class="comment">     * condition passes or &#123;<span class="doctag">@code</span> false&#125; if it fails.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the SpEL expression</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;<span class="keyword">true</span>&quot;</span>;<span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>

<p>然后相应的实现类是OnExpressionCondition，它继承自SpringBootCondition。</p>
<h4 id="ConditionalOnMissingClass-基于类不存在与classpath的条件判断"><a href="#ConditionalOnMissingClass-基于类不存在与classpath的条件判断" class="headerlink" title="@ConditionalOnMissingClass - 基于类不存在与classpath的条件判断"></a>@ConditionalOnMissingClass - 基于类不存在与classpath的条件判断</h4><p>这一个条件实现正好和@ConditionalOnClass条件相反。</p>
<hr>
<p>下面列举所有由Spring Boot提供的条件注解：</p>
<ul>
<li>@ConditionalOnBean</li>
<li>@ConditionalOnClass</li>
<li>@ConditionalOnCloudPlatform</li>
<li>@ConditionalOnExpression</li>
<li>@ConditionalOnJava</li>
<li>@ConditionalOnJndi</li>
<li>@ConditionalOnMissingBean</li>
<li>@ConditionalOnMissingClass</li>
<li>@ConditionalOnNotWebApplication</li>
<li>@ConditionalOnProperty</li>
<li>@ConditionalOnResource</li>
<li>@ConditionalOnSingleCandidate</li>
<li>@ConditionalOnWebApplication</li>
</ul>
<p>一般的模式，就是一个条件注解对应一个继承自SpringBootCondition的具体实现类。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Springboot/" rel="tag"># Springboot</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/26/SpringBoot/2019-02-02%202%20%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%AE%9A%E5%88%B6%E5%8C%96/" rel="prev" title="02 springboot启动过程定制">
      <i class="fa fa-chevron-left"></i> 02 springboot启动过程定制
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/26/SpringBoot/2019-02-04%204%20ApplicationContext/" rel="next" title="04 springboot ApplicationContext">
      04 springboot ApplicationContext <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Spring-Boot%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">1.Spring Boot实现自动配置的基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%AD%90"><span class="nav-number">1.1.</span> <span class="nav-text">引子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.1.</span> <span class="nav-text">问题是什么</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%92%8C%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E7%9A%84Spring%E5%B7%B2%E6%9C%89%E8%83%BD%E5%8A%9B"><span class="nav-number">1.2.</span> <span class="nav-text">和配置相关的Spring已有能力</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Profile"><span class="nav-number">1.2.1.</span> <span class="nav-text">@Profile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Conditional%E4%BB%A5%E5%8F%8ACondition%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.2.</span> <span class="nav-text">@Conditional以及Condition接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConfigurationProperties%E4%BB%A5%E5%8F%8A-EnableConfigurationProperties"><span class="nav-number">1.2.3.</span> <span class="nav-text">@ConfigurationProperties以及@EnableConfigurationProperties</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">定义方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">应用方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">1.2.4.</span> <span class="nav-text">自定义注解实现自动配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Spring-Boot%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">2.Spring Boot实现自动配置的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A5%E5%8F%A3%E6%B3%A8%E8%A7%A3%E7%B1%BB-EnableAutoConfiguration"><span class="nav-number">2.1.</span> <span class="nav-text">入口注解类@EnableAutoConfiguration</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AutoConfigurationPackage"><span class="nav-number">2.1.1.</span> <span class="nav-text">@AutoConfigurationPackage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Import-EnableAutoConfigurationImportSelector-class"><span class="nav-number">2.1.2.</span> <span class="nav-text">@Import(EnableAutoConfigurationImportSelector.class)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#META-INF-spring-factories"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">META-INF&#x2F;spring.factories</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Boot%E5%AF%B9%E4%BA%8E-Conditional%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">2.2.</span> <span class="nav-text">Spring Boot对于@Conditional的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#org-springframework-boot-autoconfigure-condition%E5%8C%85"><span class="nav-number">2.2.1.</span> <span class="nav-text">org.springframework.boot.autoconfigure.condition包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ConditionalOnExpression-%E5%9F%BA%E4%BA%8ESpEL%E7%9A%84%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">@ConditionalOnExpression - 基于SpEL的条件判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConditionalOnMissingClass-%E5%9F%BA%E4%BA%8E%E7%B1%BB%E4%B8%8D%E5%AD%98%E5%9C%A8%E4%B8%8Eclasspath%E7%9A%84%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">@ConditionalOnMissingClass - 基于类不存在与classpath的条件判断</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="QingSong"
      src="/images/avatar/avatar.png">
  <p class="site-author-name" itemprop="name">QingSong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">160</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QingSong</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
