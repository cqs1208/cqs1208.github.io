<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="LeetCode">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode算法-栈与队列">
<meta property="og:url" content="http://example.com/2022/09/13/LeetCode/2022-09-13%20leetcode%E7%AE%97%E6%B3%95-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="LeetCode">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_170.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_171.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_172.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_173.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_174.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_175.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_175.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_176.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_177.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_178.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_179.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_180.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_181.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_182.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_183.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_184.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_185.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_186.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_187.png">
<meta property="article:published_time" content="2022-09-13T02:54:50.454Z">
<meta property="article:modified_time" content="2022-09-23T09:30:40.807Z">
<meta property="article:author" content="QingSong">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/Leetcode/Leetcode_170.png">

<link rel="canonical" href="http://example.com/2022/09/13/LeetCode/2022-09-13%20leetcode%E7%AE%97%E6%B3%95-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>leetcode算法-栈与队列 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">点滴积累 豁达处之</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/13/LeetCode/2022-09-13%20leetcode%E7%AE%97%E6%B3%95-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar/avatar.png">
      <meta itemprop="name" content="QingSong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leetcode算法-栈与队列
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-13 10:54:50" itemprop="dateCreated datePublished" datetime="2022-09-13T10:54:50+08:00">2022-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-23 17:30:40" itemprop="dateModified" datetime="2022-09-23T17:30:40+08:00">2022-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          
            <div class="post-description">LeetCode</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p> leetcode算法</p>
<a id="more"></a> 

<h2 id="如何理解栈"><a href="#如何理解栈" class="headerlink" title="如何理解栈"></a>如何理解栈</h2><p>比如我们在放盘子的时候都是从下往上一个个放，拿的时候是从上往下一个个的那，不能从中间抽，这种其实就是一个典型的栈型数据结构。后进先出即Last In First Out （LIFO）。</p>
<h2 id="栈如何实现"><a href="#栈如何实现" class="headerlink" title="栈如何实现"></a>栈如何实现</h2><p>其实它是一个限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。<br><strong>栈其实就是一个特殊的链表或者数组。</strong><br>既然栈也是一个线性表，那么我们肯定会想到数组和链表，而且栈还有这么多限制，那为什么我们还要使用这个数据结构呢？不如直接使用数组和链表来的更直接么？数组和链表暴露太多的接口，实现上更灵活了，有些技术理解不到位的人员就可能出错。所以在某些特定场景下最好是选择栈这个数据结构。</p>
<h2 id="LeetCode-232-用栈实现队列"><a href="#LeetCode-232-用栈实现队列" class="headerlink" title="(LeetCode-232) 用栈实现队列"></a>(LeetCode-232) <strong>用栈实现队列</strong></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>
<p>实现 MyQueue 类：</p>
<ul>
<li>void push(int x) 将元素 x 推到队列的末尾</li>
<li>int pop() 从队列的开头移除并返回元素</li>
<li>int peek() 返回队列开头的元素</li>
<li>boolean empty() 如果队列为空，返回 true ；否则，返回 false</li>
</ul>
<p>说明：</p>
<ul>
<li>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, 1, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue &#x3D; new MyQueue();</span><br><span class="line">myQueue.push(1); &#x2F;&#x2F; queue is: [1]</span><br><span class="line">myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)</span><br><span class="line">myQueue.peek(); &#x2F;&#x2F; return 1</span><br><span class="line">myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]</span><br><span class="line">myQueue.empty(); &#x2F;&#x2F; return false</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>1 &lt;= x &lt;= 9</li>
<li>最多调用 100 次 push、pop、peek 和 empty</li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class MyQueue &#123;</span><br><span class="line"></span><br><span class="line">    private static Stack&lt;Integer&gt; inStack;</span><br><span class="line">    private static Stack&lt;Integer&gt; outStack;</span><br><span class="line"></span><br><span class="line">    public MyQueue()&#123;</span><br><span class="line">        inStack &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">        outStack &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(int x)&#123;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int pop()&#123;</span><br><span class="line">        if(outStack.isEmpty())&#123;</span><br><span class="line">            in2Out();</span><br><span class="line">        &#125;</span><br><span class="line">        return outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int peek()&#123;</span><br><span class="line">        if(outStack.isEmpty())&#123;</span><br><span class="line">            in2Out();</span><br><span class="line">        &#125;</span><br><span class="line">        return outStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void in2Out()&#123;</span><br><span class="line">        while (!inStack.isEmpty())&#123;</span><br><span class="line">            outStack.push(inStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        if(inStack.isEmpty() &amp;&amp; outStack.isEmpty())&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-394-字符串解码"><a href="#LeetCode-394-字符串解码" class="headerlink" title="(LeetCode-394) 字符串解码"></a>(LeetCode-394) <strong>字符串解码</strong></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;3[a]2[bc]&quot;</span><br><span class="line">输出：&quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;3[a2[c]]&quot;</span><br><span class="line">输出：&quot;accaccacc&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;2[abc]3[cd]ef&quot;</span><br><span class="line">输出：&quot;abcabccdcdcdef&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc3[cd]xyz&quot;</span><br><span class="line">输出：&quot;abccdcdcdxyz&quot;</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>1 &lt;= s.length &lt;= 30</li>
<li>s 由小写英文字母、数字和方括号 ‘[]’ 组成</li>
<li>s 保证是一个 有效 的输入。</li>
<li>s 中所有整数的取值范围为 [1, 300] </li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>方法一：栈操作<br>思路和算法</p>
<p>本题中可能出现括号嵌套的情况，比如 2[a2[bc]]，这种情况下我们可以先转化成 2[abcbc]，在转化成 abcbcabcbc。我们可以把字母、数字和括号看成是独立的 TOKEN，并用栈来维护这些 TOKEN。具体的做法是，遍历这个栈：</p>
<ul>
<li>如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈</li>
<li>如果当前的字符为字母或者左括号，直接进栈</li>
<li>如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字（此时栈顶一定是数字，想想为什么？），就是这个字符串应该出现的次数，我们根据这个次数和字符串构造出新的字符串并进栈 </li>
</ul>
<p>重复如上操作，最终将栈中的元素按照从栈底到栈顶的顺序拼接起来，就得到了答案。注意：这里可以用不定长数组来模拟栈操作，方便从栈底向栈顶遍历</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class DecodeString &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s &#x3D; &quot;3[a2[c]]&quot;;</span><br><span class="line">        System.out.println(decodeString( s));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static int ptr &#x3D; 0;</span><br><span class="line">    public static String decodeString(String s) &#123;</span><br><span class="line">        LinkedList&lt;String&gt; stk &#x3D; new LinkedList&lt;String&gt;();</span><br><span class="line">        ptr &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        while (ptr &lt; s.length()) &#123;</span><br><span class="line">            char cur &#x3D; s.charAt(ptr);</span><br><span class="line">            if (Character.isDigit(cur)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 获取一个数字并进栈</span><br><span class="line">                String digits &#x3D; getDigits(s);</span><br><span class="line">                stk.addLast(digits);</span><br><span class="line">            &#125; else if (Character.isLetter(cur) || cur &#x3D;&#x3D; &#39;[&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; 获取一个字母并进栈</span><br><span class="line">                stk.addLast(String.valueOf(s.charAt(ptr++)));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ++ptr;</span><br><span class="line">                LinkedList&lt;String&gt; sub &#x3D; new LinkedList&lt;String&gt;();</span><br><span class="line">                while (!&quot;[&quot;.equals(stk.peekLast())) &#123;</span><br><span class="line">                    sub.addLast(stk.removeLast());</span><br><span class="line">                &#125;</span><br><span class="line">                Collections.reverse(sub);</span><br><span class="line">                &#x2F;&#x2F; 左括号出栈</span><br><span class="line">                stk.removeLast();</span><br><span class="line">                &#x2F;&#x2F; 此时栈顶为当前 sub 对应的字符串应该出现的次数</span><br><span class="line">                int repTime &#x3D; Integer.parseInt(stk.removeLast());</span><br><span class="line">                StringBuffer t &#x3D; new StringBuffer();</span><br><span class="line">                String o &#x3D; getString(sub);</span><br><span class="line">                &#x2F;&#x2F; 构造字符串</span><br><span class="line">                while (repTime-- &gt; 0) &#123;</span><br><span class="line">                    t.append(o);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 将构造好的字符串入栈</span><br><span class="line">                stk.addLast(t.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return getString(stk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getDigits(String s) &#123;</span><br><span class="line">        StringBuffer ret &#x3D; new StringBuffer();</span><br><span class="line">        while (Character.isDigit(s.charAt(ptr))) &#123;</span><br><span class="line">            ret.append(s.charAt(ptr++));</span><br><span class="line">        &#125;</span><br><span class="line">        return ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getString(LinkedList&lt;String&gt; v) &#123;</span><br><span class="line">        StringBuffer ret &#x3D; new StringBuffer();</span><br><span class="line">        for (String s : v) &#123;</span><br><span class="line">            ret.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-739-每日温度"><a href="#LeetCode-739-每日温度" class="headerlink" title="**(LeetCode-739) **每日温度"></a>**(LeetCode-739) **每日温度</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures &#x3D; [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures &#x3D; [30,40,50,60]</span><br><span class="line">输出: [1,1,1,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures &#x3D; [30,60,90]</span><br><span class="line">输出: [1,1,0]</span><br></pre></td></tr></table></figure>

<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="方法二：单调栈"><a href="#方法二：单调栈" class="headerlink" title="方法二：单调栈"></a>方法二：单调栈</h4><p>可以维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。</p>
<p>正向遍历温度列表。对于温度列表中的每个元素 temperatures[i]，如果栈为空，则直接将 i 进栈，如果栈不为空，则比较栈顶元素 prevIndex 对应的温度 temperatures[prevIndex] 和当前温度 temperatures[i]，如果 temperatures[i] &gt; temperatures[prevIndex]，则将 prevIndex 移除，并将 prevIndex 对应的等待天数赋为 i - prevIndex，重复上述操作直到栈为空或者栈顶元素对应的温度小于等于当前温度，然后将 i 进栈。</p>
<p>为什么可以在弹栈的时候更新 ans[prevIndex] 呢？因为在这种情况下，即将进栈的 i 对应的 temperatures[i] 一定是 temperatures[prevIndex] 右边第一个比它大的元素，试想如果 prevIndex 和 i 有比它大的元素，假设下标为 j，那么 prevIndex 一定会在下标 j 的那一轮被弹掉。</p>
<p>由于单调栈满足从栈底到栈顶元素对应的温度递减，因此每次有元素进栈时，会将温度更低的元素全部移除，并更新出栈元素对应的等待天数，这样可以确保等待天数一定是最小的。</p>
<p>以下用一个具体的例子帮助读者理解单调栈。对于温度列表 [73,74,75,71,69,72,76,73][73,74,75,71,69,72,76,73]，单调栈 stack 的初始状态为空，答案ans 的初始状态是 [0,0,0,0,0,0,0,0][0,0,0,0,0,0,0,0]，按照以下步骤更新单调栈和答案，其中单调栈内的元素都是下标，括号内的数字表示下标在温度列表中对应的温度。</p>
<ul>
<li><p>当i=0 时，单调栈为空，因此将 0 进栈。</p>
<ul>
<li>stack=[0(73)]</li>
<li>ans=[0,0,0,0,0,0,0,0]</li>
</ul>
</li>
<li><p>当i=1 时，由于 74 大于 73，因此移除栈顶元素 0，赋值 ans[0]:=1−0，将 1 进栈。</p>
<ul>
<li>stack=[1(74)]</li>
<li>ans=[1,0,0,0,0,0,0,0]</li>
</ul>
</li>
<li><p>当 i=2 时，由于 75 大于 74，因此移除栈顶元素 1，赋值 ans[1]:=2−1，将 2 进栈。</p>
<ul>
<li>stack=[2(75)]</li>
<li>ans=[1,1,0,0,0,0,0,0]</li>
</ul>
</li>
<li><p>当 i=3 时，由于 71 小于 75，因此将 3 进栈。</p>
<ul>
<li>stack=[2(75),3(71)]</li>
<li>ans=[1,1,0,0,0,0,0,0]</li>
</ul>
</li>
<li><p>当 i=4 时，由于 69 小于 71，因此将 4 进栈。</p>
<ul>
<li>stack=[2(75),3(71),4(69)]</li>
<li>ans=[1,1,0,0,0,0,0,0]</li>
</ul>
</li>
<li><p>当 i=5 时，由于72 大于 69 和 71，因此依次移除栈顶元素 4 和 3，赋值 ans[4]:=5−4 和 ans[3]:=5−3，将 5 进栈。</p>
<ul>
<li>stack=[2(75),5(72)]</li>
<li>ans=[1,1,0,2,1,0,0,0]</li>
</ul>
</li>
<li><p>当i=6 时，由于 76 大于 72 和 75，因此依次移除栈顶元素 5 和 2，赋值 ans[5]:=6−5 和 ans[2]:=6−2，将 66 进栈。</p>
<ul>
<li>stack=[6(76)]</li>
<li>ans=[1,1,4,2,1,1,0,0]</li>
</ul>
</li>
<li><p>当i=7 时，由于 73 小于 76，因此将 7 进栈。</p>
<ul>
<li>stack=[6(76),7(73)]</li>
<li>ans=[1,1,4,2,1,1,0,0]</li>
</ul>
</li>
</ul>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class DailyTemperatures &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums &#x3D; &#123;73,74,75,71,69,72,76,73&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(new DailyTemperatures().dailyTemperatures(nums)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*用倒序遍历数组来求解*&#x2F;</span><br><span class="line">    public int[] dailyTemperatures(int[] temperatures) &#123;</span><br><span class="line">        int length &#x3D; temperatures.length;</span><br><span class="line">        int[] ret &#x3D; new int[length];</span><br><span class="line"></span><br><span class="line">        &#x2F;*从右向左遍历，数组最后一个元素无需处理*&#x2F;</span><br><span class="line">        for (int i &#x3D; length - 2; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            &#x2F;*backIdx表示从当前元素开始往后寻找获得需要的结果，</span><br><span class="line">            backIdx&#x3D;backIdx+ret[backIdx]是为了利用已经有的结果进行跳跃*&#x2F;</span><br><span class="line">            for (int backIdx &#x3D; i + 1; backIdx &lt; length; backIdx&#x3D;backIdx+ret[backIdx]) &#123;</span><br><span class="line">                if (temperatures[backIdx] &gt; temperatures[i]) &#123;</span><br><span class="line">                    ret[i] &#x3D; backIdx - i;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else if (ret[backIdx] &#x3D;&#x3D; 0) &#123;&#x2F;*遇到0表示后面不会有更大的值，那当然当前值就应该也为0*&#x2F;</span><br><span class="line">                    ret[i] &#x3D; 0;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 栈</span><br><span class="line">    public int[] dailyTemperatures1(int[] temperatures) &#123;</span><br><span class="line">        int[] ret &#x3D; new int[temperatures.length];</span><br><span class="line">        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        for(int i &#x3D; 0; i &lt; temperatures.length; i++)&#123;</span><br><span class="line">            while (!stack.isEmpty() &amp;&amp; temperatures[stack.peek()] &lt; temperatures[i])&#123;</span><br><span class="line">                int index &#x3D; stack.pop();</span><br><span class="line">                ret[index] &#x3D;  i - index;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-84-柱状图中最大的矩形"><a href="#LeetCode-84-柱状图中最大的矩形" class="headerlink" title="**(LeetCode-84) **柱状图中最大的矩形"></a>**(LeetCode-84) **柱状图中最大的矩形</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><strong>示例 1:</strong></p>
<p><img src="/images/Leetcode/Leetcode_170.png" alt="Leetcode_170"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：heights &#x3D; [2,1,5,6,2,3]</span><br><span class="line">输出：10</span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 10</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/images/Leetcode/Leetcode_171.png" alt="Leetcode_171"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： heights &#x3D; [2,4]</span><br><span class="line">输出： 4</span><br></pre></td></tr></table></figure>

<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><h4 id="方法一：单调栈"><a href="#方法一：单调栈" class="headerlink" title="方法一：单调栈"></a>方法一：单调栈</h4><p>思路</p>
<p>我们归纳一下枚举「高」的方法：</p>
<ul>
<li>首先我们枚举某一根柱子 ii 作为高 h=heights[i]；</li>
<li>随后我们需要进行向左右两边扩展，使得扩展到的柱子的高度均不小于 h。换句话说，我们需要找到左右两侧最近的高度小于 h 的柱子，这样这两根柱子之间（不包括其本身）的所有柱子高度均不小于 h，并且就是 i 能够扩展到的最远范围。</li>
</ul>
<p>理解单调栈</p>
<p>我们用一个具体的例子 [6, 7, 5, 2, 4, 5, 9, 3][6,7,5,2,4,5,9,3] 来帮助读者理解单调栈。我们需要求出每一根柱子的左侧且最近的小于其高度的柱子。初始时的栈为空。</p>
<ul>
<li><p>我们枚举 6，因为栈为空，所以 6 左侧的柱子是「哨兵」，位置为 -1。随后我们将 6 入栈。</p>
<ul>
<li>栈：<code>[6(0)]</code>。（这里括号内的数字表示柱子在原数组中的位置）</li>
</ul>
</li>
<li><p>我们枚举 7，由于 6&lt;7，因此不会移除栈顶元素，所以 7 左侧的柱子是 6，位置为 0。随后我们将 7 入栈。</p>
<ul>
<li>栈：<code>[6(0), 7(1)]</code></li>
</ul>
</li>
<li><p>我们枚举 5，由于 7≥5，因此移除栈顶元素 7。同样地，6≥5，再移除栈顶元素 6。此时栈为空，所以 5 左侧的柱子是「哨兵」，位置为−1。随后我们将 5 入栈。</p>
<ul>
<li>栈：<code>[5(2)]</code></li>
</ul>
</li>
<li><p>接下来的枚举过程也大同小异。我们枚举 2，移除栈顶元素 5，得到 2 左侧的柱子是「哨兵」，位置为 −1。将 2 入栈。</p>
<ul>
<li>栈：<code>[2(3)]</code></li>
</ul>
</li>
<li><p>我们枚举 4，5 和 9，都不会移除任何栈顶元素，得到它们左侧的柱子分别是 2，4 和 5，位置分别为 3，4 和 5。将它们入栈。</p>
<ul>
<li>栈：<code>[2(3), 4(4), 5(5), 9(6)]</code></li>
</ul>
</li>
<li><p>我们枚举 3，依次移除栈顶元素 9，5 和 4，得到 3 左侧的柱子是 2，位置为 3。将 3 入栈。</p>
<ul>
<li>栈：<code>[2(3), 3(7)]</code></li>
</ul>
</li>
</ul>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class LargestRectangleArea &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums &#x3D; &#123;2,1,5,6,2,3&#125;;</span><br><span class="line">        System.out.println(new LargestRectangleArea().largestRectangleArea(nums));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*基于单调栈的实现*&#x2F;</span><br><span class="line">    public int largestRectangleArea(int[] heights) &#123;</span><br><span class="line">        int len &#x3D; heights.length;</span><br><span class="line">        if (len &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (len &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return heights[0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int result &#x3D; 0;</span><br><span class="line">        Deque&lt;Integer&gt; stack &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">        &#x2F;*遍历数组*&#x2F;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">            while (!stack.isEmpty() &amp;&amp; heights[i] &lt; heights[stack.peekLast()]) &#123;</span><br><span class="line">                &#x2F;*当前需要计算面积的元素的下标*&#x2F;</span><br><span class="line">                int curIndex &#x3D; stack.pollLast();</span><br><span class="line">                &#x2F;*获得当前元素的值，也就是矩形的高*&#x2F;</span><br><span class="line">                int curHeight &#x3D; heights[curIndex];</span><br><span class="line">                &#x2F;*计算矩形的宽*&#x2F;</span><br><span class="line">                int curWidth;</span><br><span class="line">                if (stack.isEmpty()) &#123;</span><br><span class="line">                    &#x2F;*栈为空，表示目前遍历过所有元素都比当前的i要大，i是最小的一个，</span><br><span class="line">                    宽度就可以直接取i的值*&#x2F;</span><br><span class="line">                    curWidth &#x3D; i;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    curWidth &#x3D; i - stack.peekLast() - 1;</span><br><span class="line">                &#125;</span><br><span class="line">                result &#x3D; Math.max(result, curHeight * curWidth);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;*处理目前还在栈中的元素*&#x2F;</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            int curHeight &#x3D; heights[stack.pollLast()];</span><br><span class="line">            int curWidth;</span><br><span class="line">            if (stack.isEmpty()) &#123;</span><br><span class="line">                curWidth &#x3D; len;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                curWidth &#x3D; len - stack.peekLast() - 1;</span><br><span class="line">            &#125;</span><br><span class="line">            result &#x3D; Math.max(result, curHeight * curWidth);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-224-基本计算器"><a href="#LeetCode-224-基本计算器" class="headerlink" title="**(LeetCode-224) **基本计算器"></a>**(LeetCode-224) **基本计算器</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>
<p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1 + 1&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot; 2-1 + 2 &quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure>

<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>方法一：括号展开 + 栈<br>由于字符串除了数字与括号外，只有加号和减号两种运算符。因此，如果展开表达式中所有的括号，则得到的新表达式中，数字本身不会发生变化，只是每个数字前面的符号会发生变化。</p>
<p>因此，我们考虑使用一个取值为{−1,+1} 的整数 sign 代表「当前」的符号。根据括号表达式的性质，它的取值：</p>
<ul>
<li>与字符串中当前位置的运算符有关；</li>
<li>如果当前位置处于一系列括号之内，则也与这些括号前面的运算符有关：每当遇到一个以 -− 号开头的括号，则意味着此后的符号都要被「翻转」。</li>
</ul>
<p>考虑到第二点，我们需要维护一个栈  ops，其中栈顶元素记录了当前位置所处的每个括号所「共同形成」的符号。例如，对于字符串 1+2+(3-(4+5))：</p>
<ul>
<li>扫描到 1+2 时，由于当前位置没有被任何括号所包含，则栈顶元素为初始值 +1；</li>
<li>扫描到 1+2+(3 时，当前位置被一个括号所包含，该括号前面的符号为 + 号，因此栈顶元素依然 +1；</li>
<li>扫描到 1+2+(3-(4 时，当前位置被两个括号所包含，分别对应着 + 号和 − 号，由于 + 号和 − 号合并的结果为 -− 号，因此栈顶元素变为 −1。</li>
</ul>
<p>在得到栈 ops 之后， sign 的取值就能够确定了：如果当前遇到了 + 号，则更新 sign←ops.top()；如果遇到了遇到了 -− 号，则更新 sign←−ops.top()。</p>
<p>然后，每当遇到 ( 时，都要将当前的 sign 取值压入栈中；每当遇到 ) 时，都从栈中弹出一个元素。这样，我们能够在扫描字符串的时候，即时地更新 ops 中的元素。</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class Calculate &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str &#x3D; &quot;222 - 32 + ( 9 - ( 4 + 5))&quot;;</span><br><span class="line">        System.out.println(new Calculate().calculate(str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int calculate(String s) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; ops &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">        ops.push(1);</span><br><span class="line">        int sign &#x3D; 1;</span><br><span class="line"></span><br><span class="line">        int ret &#x3D; 0;</span><br><span class="line">        int n &#x3D; s.length();</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        while (i &lt; n) &#123;</span><br><span class="line">        if (s.charAt(i) &#x3D;&#x3D; &#39; &#39;) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; else if (s.charAt(i) &#x3D;&#x3D; &#39;+&#39;) &#123;</span><br><span class="line">            sign &#x3D; ops.peek();</span><br><span class="line">            i++;</span><br><span class="line">        &#125; else if (s.charAt(i) &#x3D;&#x3D; &#39;-&#39;) &#123;</span><br><span class="line">            sign &#x3D; -ops.peek();</span><br><span class="line">            i++;</span><br><span class="line">        &#125; else if (s.charAt(i) &#x3D;&#x3D; &#39;(&#39;) &#123;</span><br><span class="line">            ops.push(sign);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; else if (s.charAt(i) &#x3D;&#x3D; &#39;)&#39;) &#123;</span><br><span class="line">            ops.pop();</span><br><span class="line">            i++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            long num &#x3D; 0;</span><br><span class="line">            while (i &lt; n &amp;&amp; Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">                num &#x3D; num * 10 + s.charAt(i) - &#39;0&#39;;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret +&#x3D; sign * num;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-98-验证二叉搜索树"><a href="#LeetCode-98-验证二叉搜索树" class="headerlink" title="(LeetCode-98)验证二叉搜索树"></a>(LeetCode-98)验证二叉搜索树</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 小于 当前节点的数。</li>
<li>节点的右子树只包含 大于 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="/images/Leetcode/Leetcode_172.png" alt="Leetcode_172"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/images/Leetcode/Leetcode_173.png" alt="Leetcode_173"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [5,1,4,null,null,3,6]</span><br><span class="line">输出：false</span><br><span class="line">解释：根节点的值是 5 ，但是右子节点的值是 4 。</span><br></pre></td></tr></table></figure>

<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><h4 id="方法二：中序遍历"><a href="#方法二：中序遍历" class="headerlink" title="方法二：中序遍历"></a>方法二：中序遍历</h4><p>思路和算法</p>
<p>基于方法一中提及的性质，我们可以进一步知道二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是，下面的代码我们使用栈来模拟中序遍历的过程。</p>
<p>可能有读者不知道中序遍历是什么，我们这里简单提及。中序遍历是二叉树的一种遍历方式，它先遍历左子树，再遍历根节点，最后遍历右子树。而我们二叉搜索树保证了左子树的节点的值均小于根节点的值，根节点的值均小于右子树的值，因此中序遍历以后得到的序列一定是升序序列。</p>
<p><img src="/images/Leetcode/Leetcode_174.png" alt="Leetcode_174"></p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class IsValidBST &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TreeNode node6 &#x3D; new TreeNode(6);</span><br><span class="line">        TreeNode node3 &#x3D; new TreeNode(3);</span><br><span class="line">        TreeNode node4 &#x3D; new TreeNode(4, node3, node6);</span><br><span class="line">        TreeNode node1 &#x3D; new TreeNode(1);</span><br><span class="line">        TreeNode node5 &#x3D; new TreeNode(5, node1,node4);</span><br><span class="line"></span><br><span class="line">        System.out.println(new IsValidBST().isValidBST(node5));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      public static class TreeNode &#123;</span><br><span class="line">          int val;</span><br><span class="line">          TreeNode left;</span><br><span class="line">          TreeNode right;</span><br><span class="line">          TreeNode() &#123;&#125;</span><br><span class="line">          TreeNode(int val) &#123; this.val &#x3D; val; &#125;</span><br><span class="line">          TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">              this.val &#x3D; val;</span><br><span class="line">              this.left &#x3D; left;</span><br><span class="line">              this.right &#x3D; right;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack &#x3D; new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        double inorder &#x3D; -Double.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        while (!stack.isEmpty() || root !&#x3D; null) &#123;</span><br><span class="line">            while (root !&#x3D; null) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root &#x3D; root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; stack.pop();</span><br><span class="line">              &#x2F;&#x2F; 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span><br><span class="line">            if (root.val &lt;&#x3D; inorder) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            inorder &#x3D; root.val;</span><br><span class="line">            root &#x3D; root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        printMid( root,  stack);</span><br><span class="line">        Integer next &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        while (!stack.isEmpty())&#123;</span><br><span class="line">            Integer num &#x3D; stack.pop();</span><br><span class="line">            if(next &lt;&#x3D; num)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                next &#x3D; num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printMid(TreeNode root, Stack&lt;Integer&gt; stack) &#123;</span><br><span class="line">        if (root.left !&#x3D; null)&#123;</span><br><span class="line">            printMid( root.left, stack);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(root.val);</span><br><span class="line">        if (root.right !&#x3D; null)&#123;</span><br><span class="line">            printMid( root.right, stack);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-102-二叉树的层序遍历"><a href="#LeetCode-102-二叉树的层序遍历" class="headerlink" title="(LeetCode-102)二叉树的层序遍历"></a>(LeetCode-102)二叉树的层序遍历</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/images/Leetcode/Leetcode_175.png" alt="Leetcode_175"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><h4 id="方法一：广度优先搜索"><a href="#方法一：广度优先搜索" class="headerlink" title="方法一：广度优先搜索"></a>方法一：广度优先搜索</h4><p>思路和算法</p>
<p>我们可以用广度优先搜索解决这个问题。</p>
<p>我们可以想到最朴素的方法是用一个二元组 (node, level) 来表示状态，它表示某个节点和它所在的层数，每个新进队列的节点的 level 值都是父亲节点的 level 值加一。最后根据每个点的 level 对点进行分类，分类的时候我们可以利用哈希表，维护一个以 level 为键，对应节点值组成的数组为值，广度优先搜索结束以后按键 level 从小到大取出所有值，组成答案返回即可。</p>
<p>考虑如何优化空间开销：如何不用哈希映射，并且只用一个变量 node 表示状态，实现这个功能呢？</p>
<p>我们可以用一种巧妙的方法修改广度优先搜索：</p>
<ul>
<li>首先根元素入队</li>
<li>当队列不为空的时候<ul>
<li>求当前队列的长度 si</li>
<li>依次从队列中取 si 个元素进行拓展，然后进入下一次迭代</li>
</ul>
</li>
</ul>
<p>它和普通广度优先搜索的区别在于，普通广度优先搜索每次只取一个元素拓展，而这里每次取 si个元素。在上述过程中的第 i 次迭代就得到了二叉树的第 i 层的 si个元素。</p>
<p>为什么这么做是对的呢？我们观察这个算法，可以归纳出这样的循环不变式：第 i 次迭代前，队列中的所有元素就是第 i 层的所有元素，并且按照从左向右的顺序排列。证明它的三条性质（你也可以把它理解成数学归纳法）：</p>
<ul>
<li>初始化：i=1 的时候，队列里面只有 root，是唯一的层数为 1 的元素，因为只有一个元素，所以也显然满足「从左向右排列」；</li>
<li>保持：如果 i=k 时性质成立，即第 k 轮中出队 sk 的元素是第 k 层的所有元素，并且顺序从左到右。因为对树进行广度优先搜索的时候由低 k 层的点拓展出的点一定也只能是 k+1 层的点，并且 k+1 层的点只能由第 k 层的点拓展到，所以由这 sk 个点能拓展到下一层所有的 sk+1个点。又因为队列的先进先出（FIFO）特性，既然第 k 层的点的出队顺序是从左向右，那么第 k+1 层也一定是从左向右。至此，我们已经可以通过数学归纳法证明循环不变式的正确性。</li>
<li>终止：因为该循环不变式是正确的，所以按照这个方法迭代之后每次迭代得到的也就是当前层的层次遍历结果。至此，我们证明了算法是正确的。</li>
</ul>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class LevelOrder &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TreeNode node7 &#x3D; new TreeNode(7);</span><br><span class="line">        TreeNode node15 &#x3D; new TreeNode(15);</span><br><span class="line">        TreeNode node20 &#x3D; new TreeNode(20, node15,node7 );</span><br><span class="line">        TreeNode node9 &#x3D; new TreeNode(9);</span><br><span class="line">        TreeNode node3 &#x3D; new TreeNode(3,node9,node20 );</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lsit &#x3D; new LevelOrder().levelOrder(node3);</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F; 边界</span><br><span class="line">        if(root &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        while (!queue.isEmpty())&#123;</span><br><span class="line">            &#x2F;&#x2F; 获取每层的节点数</span><br><span class="line">            int levelNodeNum &#x3D; queue.size();</span><br><span class="line">            List&lt;Integer&gt; tempList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            for(int i &#x3D; 0; i &lt; levelNodeNum; i++)&#123;</span><br><span class="line">                TreeNode node &#x3D; queue.poll();</span><br><span class="line">                tempList.add(node.getValue());</span><br><span class="line">                if(node.getLeft() !&#x3D; null)&#123;</span><br><span class="line">                    queue.offer(node.getLeft());</span><br><span class="line">                &#125;</span><br><span class="line">                if(node.getRight() !&#x3D; null)&#123;</span><br><span class="line">                    queue.offer(node.getRight());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(tempList);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-103-二叉树的锯齿形层序遍历"><a href="#LeetCode-103-二叉树的锯齿形层序遍历" class="headerlink" title="(LeetCode-103)二叉树的锯齿形层序遍历"></a>(LeetCode-103)二叉树的锯齿形层序遍历</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/images/Leetcode/Leetcode_175.png" alt="Leetcode_175"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[3],[20,9],[15,7]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    levelPreVisit( result,  root, 0);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void levelPreVisit(List&lt;List&lt;Integer&gt;&gt; result, TreeNode root, int height)&#123;</span><br><span class="line">    if(root &#x3D;&#x3D; null) return;</span><br><span class="line">    if(height &gt;&#x3D; result.size())&#123;</span><br><span class="line">        result.add(new LinkedList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    if(height % 2 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        result.get(height).add(root.getValue());</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        result.get(height).add(0,root.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    levelPreVisit(result,  root.getLeft(),  height+ 1);</span><br><span class="line">    levelPreVisit( result,  root.getRight(),  height + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-105-从前序与中序遍历序列构造二叉树"><a href="#LeetCode-105-从前序与中序遍历序列构造二叉树" class="headerlink" title="(LeetCode-105) 从前序与中序遍历序列构造二叉树"></a>(LeetCode-105) 从前序与中序遍历序列构造二叉树</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">输出: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder &#x3D; [-1], inorder &#x3D; [-1]</span><br><span class="line">输出: [-1]</span><br></pre></td></tr></table></figure>

<h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><p>思路</p>
<p>对于任意一颗树而言，前序遍历的形式总是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</span><br></pre></td></tr></table></figure>

<p>即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</span><br></pre></td></tr></table></figure>

<p><img src="/images/Leetcode/Leetcode_176.png" alt="Leetcode_176"></p>
<p>只要我们在中序遍历中<strong>定位</strong>到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有<strong>左右括号</strong>进行定位。</p>
<p>这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p>
<p><strong>细节</strong></p>
<p>在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希表来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1) 的时间对根节点进行定位了。</p>
<h4 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h4><p>我们以树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        3</span><br><span class="line">       &#x2F; \</span><br><span class="line">      9  20</span><br><span class="line">     &#x2F;  &#x2F;  \</span><br><span class="line">    8  15   7</span><br><span class="line">   &#x2F; \</span><br><span class="line">  5  10</span><br><span class="line"> &#x2F;</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>为例，它的前序遍历和中序遍历分别为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preorder &#x3D; [3, 9, 8, 5, 4, 10, 20, 15, 7]</span><br><span class="line">inorder &#x3D; [4, 5, 8, 10, 9, 3, 15, 20, 7]</span><br></pre></td></tr></table></figure>

<p>我们用一个栈 stack 来维护「当前节点的所有还没有考虑过右儿子的祖先节点」，栈顶就是当前节点。也就是说，只有在栈中的节点才可能连接一个新的右儿子。同时，我们用一个指针 index 指向中序遍历的某个位置，初始值为 0。index 对应的节点是「当前节点不断往左走达到的最终节点」，这也是符合中序遍历的，它的作用在下面的过程中会有所体现。</p>
<p>首先我们将根节点 3 入栈，再初始化 index 所指向的节点为 4，随后对于前序遍历中的每个节点，我们依次判断它是栈顶节点的左儿子，还是栈中某个节点的右儿子。</p>
<ul>
<li><p>我们遍历 9。9 一定是栈顶节点 3 的左儿子。我们使用反证法，假设 9 是 3 的右儿子，那么 3 没有左儿子，index 应该恰好指向 3，但实际上为 4，因此产生了矛盾。所以我们将 9 作为 3 的左儿子，并将 9 入栈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack &#x3D; [3, 9]</span><br><span class="line">index -&gt; inorder[0] &#x3D; 4</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们遍历 <code>8</code>，<code>5</code> 和 <code>4</code>。同理可得它们都是上一个节点（栈顶节点）的左儿子，所以它们会依次入栈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack &#x3D; [3, 9, 8, 5, 4]</span><br><span class="line">index -&gt; inorder[0] &#x3D; 4</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们遍历 10，这时情况就不一样了。我们发现 index 恰好指向当前的栈顶节点 4，也就是说 4 没有左儿子，那么 10 必须为栈中某个节点的右儿子。那么如何找到这个节点呢？栈中的节点的顺序和它们在前序遍历中出现的顺序是一致的，而且每一个节点的右儿子都还没有被遍历过，<strong>那么这些节点的顺序和它们在中序遍历中出现的顺序一定是相反的。</strong></p>
<p>因此我们可以把 index 不断向右移动，并与栈顶节点进行比较。如果 index 对应的元素恰好等于栈顶节点，那么说明我们在中序遍历中找到了栈顶节点，所以将 index 增加 1 并弹出栈顶节点，直到 index 对应的元素不等于栈顶节点。按照这样的过程，我们弹出的最后一个节点 x 就是 10 的双亲节点，<strong>这是因为 10 出现在了 x 与 x 在栈中的下一个节点的中序遍历之间</strong>，因此 10 就是 x 的右儿子。</p>
<p>回到我们的例子，我们会依次从栈顶弹出 <code>4</code>，<code>5</code> 和 <code>8</code>，并且将 <code>index</code> 向右移动了三次。我们将 <code>10</code> 作为最后弹出的节点 <code>8</code> 的右儿子，并将 <code>10</code> 入栈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack &#x3D; [3, 9, 10]</span><br><span class="line">index -&gt; inorder[3] &#x3D; 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们遍历 20。同理，index 恰好指向当前栈顶节点 10，那么我们会依次从栈顶弹出 10，9 和 3，并且将 index 向右移动了三次。我们将 20 作为最后弹出的节点 3 的右儿子，并将 20 入栈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack &#x3D; [20]</span><br><span class="line">index -&gt; inorder[6] &#x3D; 15</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们遍历 <code>15</code>，将 <code>15</code> 作为栈顶节点 <code>20</code> 的左儿子，并将 <code>15</code> 入栈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack &#x3D; [20, 15]</span><br><span class="line">index -&gt; inorder[6] &#x3D; 15</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们遍历 7。index 恰好指向当前栈顶节点 15，那么我们会依次从栈顶弹出 15 和 20，并且将 index 向右移动了两次。我们将 7 作为最后弹出的节点 20 的右儿子，并将 7 入栈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack &#x3D; [7]</span><br><span class="line">index -&gt; inorder[8] &#x3D; 7</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>此时遍历结束，我们就构造出了正确的二叉树。</p>
<p><strong>算法</strong></p>
<p>我们归纳出上述例子中的算法流程：</p>
<ul>
<li><p>我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；</p>
</li>
<li><p>我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果 index 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 index，并将当前节点作为最后一个弹出的节点的右儿子；如果 index 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；</p>
</li>
<li><p>无论是哪一种情况，我们最后都将当前的节点入栈。</p>
</li>
</ul>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 递归</span><br><span class="line"> private Map&lt;Integer, Integer&gt; indexMap;</span><br><span class="line"></span><br><span class="line">    public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) &#123;</span><br><span class="line">        if (preorder_left &gt; preorder_right) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 前序遍历中的第一个节点就是根节点</span><br><span class="line">        int preorder_root &#x3D; preorder_left;</span><br><span class="line">        &#x2F;&#x2F; 在中序遍历中定位根节点</span><br><span class="line">        int inorder_root &#x3D; indexMap.get(preorder[preorder_root]);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 先把根节点建立出来</span><br><span class="line">        TreeNode root &#x3D; new TreeNode(preorder[preorder_root]);</span><br><span class="line">        &#x2F;&#x2F; 得到左子树中的节点数目</span><br><span class="line">        int size_left_subtree &#x3D; inorder_root - inorder_left;</span><br><span class="line">        &#x2F;&#x2F; 递归地构造左子树，并连接到根节点</span><br><span class="line">        &#x2F;&#x2F; 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span><br><span class="line">        root.left &#x3D; myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);</span><br><span class="line">        &#x2F;&#x2F; 递归地构造右子树，并连接到根节点</span><br><span class="line">        &#x2F;&#x2F; 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br><span class="line">        root.right &#x3D; myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        int n &#x3D; preorder.length;</span><br><span class="line">        &#x2F;&#x2F; 构造哈希映射，帮助我们快速定位根节点</span><br><span class="line">        indexMap &#x3D; new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            indexMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 迭代</span><br><span class="line"> public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        if (preorder &#x3D;&#x3D; null || preorder.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root &#x3D; new TreeNode(preorder[0]);</span><br><span class="line">        Deque&lt;TreeNode&gt; stack &#x3D; new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        int inorderIndex &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; preorder.length; i++) &#123;</span><br><span class="line">            int preorderVal &#x3D; preorder[i];</span><br><span class="line">            TreeNode node &#x3D; stack.peek();</span><br><span class="line">            if (node.val !&#x3D; inorder[inorderIndex]) &#123;</span><br><span class="line">                node.left &#x3D; new TreeNode(preorderVal);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                while (!stack.isEmpty() &amp;&amp; stack.peek().val &#x3D;&#x3D; inorder[inorderIndex]) &#123;</span><br><span class="line">                    node &#x3D; stack.pop();</span><br><span class="line">                    inorderIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                node.right &#x3D; new TreeNode(preorderVal);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-114-二叉树展开为链表"><a href="#LeetCode-114-二叉树展开为链表" class="headerlink" title="**(LeetCode-114) **二叉树展开为链表"></a>**(LeetCode-114) **二叉树展开为链表</h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null </li>
<li>展开后的单链表应该与二叉树 先序遍历 顺序相同。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="/images/Leetcode/Leetcode_177.png" alt="Leetcode_177"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,5,3,4,null,6]</span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><h4 id="方法三：寻找前驱节点"><a href="#方法三：寻找前驱节点" class="headerlink" title="方法三：寻找前驱节点"></a>方法三：寻找前驱节点</h4><p>注意到前序遍历访问各节点的顺序是根节点、左子树、右子树。如果一个节点的左子节点为空，则该节点不需要进行展开操作。如果一个节点的左子节点不为空，则该节点的左子树中的最后一个节点被访问之后，该节点的右子节点被访问。该节点的左子树中最后一个被访问的节点是左子树中的最右边的节点，也是该节点的前驱节点。因此，问题转化成寻找当前节点的前驱节点。</p>
<p>具体做法是，对于当前节点，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点，将当前节点的右子节点赋给前驱节点的右子节点，然后将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空。对当前节点处理结束后，继续处理链表中的下一个节点，直到所有节点都处理结束。</p>
<p>图示</p>
<p><img src="/images/Leetcode/Leetcode_178.png" alt="Leetcode_178"></p>
<p><img src="/images/Leetcode/Leetcode_179.png" alt="Leetcode_179"></p>
<p><img src="/images/Leetcode/Leetcode_180.png" alt="Leetcode_180"></p>
<p><img src="/images/Leetcode/Leetcode_181.png" alt="Leetcode_181"></p>
<p><img src="/images/Leetcode/Leetcode_182.png" alt="Leetcode_182"></p>
<p><img src="/images/Leetcode/Leetcode_183.png" alt="Leetcode_183"></p>
<p><img src="/images/Leetcode/Leetcode_184.png" alt="Leetcode_184"></p>
<p><img src="/images/Leetcode/Leetcode_185.png" alt="Leetcode_185"></p>
<h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Flatten &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TreeNode node6 &#x3D; new TreeNode(6);</span><br><span class="line">        TreeNode node4 &#x3D; new TreeNode(4);</span><br><span class="line">        TreeNode node3 &#x3D; new TreeNode(3);</span><br><span class="line">        TreeNode node5 &#x3D; new TreeNode(5, null,node6);</span><br><span class="line">        TreeNode node2 &#x3D; new TreeNode(2, node3,node4);</span><br><span class="line">        TreeNode node1 &#x3D; new TreeNode(1, node2, node5);</span><br><span class="line">        new Flatten().flatten( node1);</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void flatten(TreeNode root) &#123;</span><br><span class="line">        while(root !&#x3D; null)&#123;</span><br><span class="line">            if(root.left &#x3D;&#x3D; null)&#123;</span><br><span class="line">                root &#x3D; root.right;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                &#x2F;&#x2F; 寻找左子树最右边的节点</span><br><span class="line">                TreeNode rightmost &#x3D; root.left;</span><br><span class="line">                while (rightmost.right !&#x3D; null)&#123;</span><br><span class="line">                    rightmost &#x3D; rightmost.right;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 将原来的右子树挂到左子树的最右边节点的右指针上</span><br><span class="line">                rightmost.right &#x3D; root.right;</span><br><span class="line">                &#x2F;&#x2F; 将左子树挂到root节点的右指针上</span><br><span class="line">                root.right &#x3D; root.left;</span><br><span class="line">                root.left &#x3D; null;</span><br><span class="line">                &#x2F;&#x2F; 此时root节点的左子树已经为null， 向下寻找，看看下面的节点上是否还存在着左子树，重复上述过程</span><br><span class="line">                root &#x3D; root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-199-二叉树的右视图"><a href="#LeetCode-199-二叉树的右视图" class="headerlink" title="**(LeetCode-199) **二叉树的右视图"></a>**(LeetCode-199) **二叉树的右视图</h2><h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p><strong>示例 1:</strong></p>
<p><img src="/images/Leetcode/Leetcode_186.png" alt="Leetcode_186"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1,3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,3]</span><br><span class="line">输出: [1,3]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: []</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure>

<h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a><strong>方法1</strong></h4><p>这个题目仔细思考一下，按照从顶部到底部的顺序，返回从右侧所能看到的节点值，可以破题的点在哪里？</p>
<p>首先，可以确定的是，这个题目和树的层次有关，有几层就可以看到几个节点，也就是说，看得的节点数和树的层次数是相等，不管每层有几个节点，只能看到一个。</p>
<p>第二，看到的一定是右子树上的节点吗？虽然示例1里，看到的都是右子树上的1,3,4这三个节点，但是我们稍稍想一下就能知道，如果节点4不存在，我们看到的将是1,3,5这三个节点。</p>
<p><img src="/images/Leetcode/Leetcode_187.png" alt="Leetcode_187"></p>
<p>但是5什么时候可以看到呢？只有4不存在的时候，如果4是3的右子树，那么不管5是3的左子树，还是2的右子树，2的左子树，都是看不到5的。</p>
<p>所以我们可以先递归的搜索树的右子树，再递归搜索左子树，在搜索的过程中，对于右子树来说，遇到一个右子树的节点，就加入结果集，对左子树来说，只有结果集不存在右子树的节点，才会加入结果集。怎么做到呢？只需要看看当前层高是否和结果集的size大小相等就可以了。</p>
<p>以示例1来举例，比如处理整个树的根结点1，层高为0，结果集的size=0，把根结点加入结果集。往下递归，到了下一层，层高为1，结果集的size=1，又把右子树的根结点3加入结果集，很明显4也要加入结果集，这个时候结果集的size=3。</p>
<p>当递归处理整个树的左子树时，节点2的层高为1，结果集的size=3，节点2不能加入结果集，节点5的层高为2，结果集的size=3，节点5不能加入结果集。</p>
<p>如果节点4不存在，会发生什么情况，当整棵树的右子树遍历完成，结果集的size=2，当处理到节点5时，层高为2，结果集的size=2，应该把节点5加入结果集。</p>
<h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class RightSideView &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TreeNode node6 &#x3D; new TreeNode(6);</span><br><span class="line">        TreeNode node4 &#x3D; new TreeNode(4);</span><br><span class="line">        TreeNode node3 &#x3D; new TreeNode(3);</span><br><span class="line">        TreeNode node5 &#x3D; new TreeNode(5, null,null);</span><br><span class="line">        TreeNode node2 &#x3D; new TreeNode(2, node3,node4);</span><br><span class="line">        TreeNode node1 &#x3D; new TreeNode(1, node2, node5);</span><br><span class="line">        new RightSideView().rightSideView( node1);</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">        toRightSideView( result,  root, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    public void toRightSideView(List&lt;Integer&gt; result, TreeNode root, int height) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        if(result.size() &#x3D;&#x3D; height)&#123;</span><br><span class="line">            result.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        toRightSideView( result,  root.right,  height + 1);</span><br><span class="line">        toRightSideView( result,  root.left,  height + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-208-实现-Trie-前缀树"><a href="#LeetCode-208-实现-Trie-前缀树" class="headerlink" title="(LeetCode-208) 实现 Trie (前缀树)"></a>(LeetCode-208) 实现 Trie (前缀树)</h2><h3 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h3><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p>请你实现 Trie 类： </p>
<ul>
<li>Trie() 初始化前缀树对象。</li>
<li>void insert(String word) 向前缀树中插入字符串 word 。</li>
<li>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。</li>
<li>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LeetCode/" rel="tag"># LeetCode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/09/09/LeetCode/2022-09-11%20leetcode%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/" rel="prev" title="leetcode算法-链表">
      <i class="fa fa-chevron-left"></i> leetcode算法-链表
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/09/13/LeetCode/2022-09-14%20leetcode%E7%AE%97%E6%B3%95-%E6%A0%91/" rel="next" title="leetcode算法-树">
      leetcode算法-树 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%A0%88"><span class="nav-number">1.</span> <span class="nav-text">如何理解栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.</span> <span class="nav-text">栈如何实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">3.</span> <span class="nav-text">(LeetCode-232) 用栈实现队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE"><span class="nav-number">3.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">3.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="nav-number">4.</span> <span class="nav-text">(LeetCode-394) 字符串解码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="nav-number">4.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90"><span class="nav-number">4.2.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="nav-number">4.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="nav-number">5.</span> <span class="nav-text">**(LeetCode-739) **每日温度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="nav-number">5.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-1"><span class="nav-number">5.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">5.2.1.</span> <span class="nav-text">方法二：单调栈</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="nav-number">5.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2"><span class="nav-number">6.</span> <span class="nav-text">**(LeetCode-84) **柱状图中最大的矩形</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-3"><span class="nav-number">6.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-2"><span class="nav-number">6.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">6.2.1.</span> <span class="nav-text">方法一：单调栈</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="nav-number">6.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="nav-number">7.</span> <span class="nav-text">**(LeetCode-224) **基本计算器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-4"><span class="nav-number">7.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-3"><span class="nav-number">7.2.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="nav-number">7.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">8.</span> <span class="nav-text">(LeetCode-98)验证二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-5"><span class="nav-number">8.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-4"><span class="nav-number">8.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">8.2.1.</span> <span class="nav-text">方法二：中序遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="nav-number">8.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">9.</span> <span class="nav-text">(LeetCode-102)二叉树的层序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-6"><span class="nav-number">9.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-5"><span class="nav-number">9.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">9.2.1.</span> <span class="nav-text">方法一：广度优先搜索</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="nav-number">9.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">10.</span> <span class="nav-text">(LeetCode-103)二叉树的锯齿形层序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-7"><span class="nav-number">10.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-6"><span class="nav-number">10.2.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="nav-number">10.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">11.</span> <span class="nav-text">(LeetCode-105) 从前序与中序遍历序列构造二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-8"><span class="nav-number">11.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-7"><span class="nav-number">11.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E9%80%92%E5%BD%92"><span class="nav-number">11.2.1.</span> <span class="nav-text">方法一：递归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E8%BF%AD%E4%BB%A3"><span class="nav-number">11.2.2.</span> <span class="nav-text">方法二：迭代</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="nav-number">11.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="nav-number">12.</span> <span class="nav-text">**(LeetCode-114) **二叉树展开为链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-9"><span class="nav-number">12.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-8"><span class="nav-number">12.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E5%AF%BB%E6%89%BE%E5%89%8D%E9%A9%B1%E8%8A%82%E7%82%B9"><span class="nav-number">12.2.1.</span> <span class="nav-text">方法三：寻找前驱节点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-9"><span class="nav-number">12.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="nav-number">13.</span> <span class="nav-text">**(LeetCode-199) **二叉树的右视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-10"><span class="nav-number">13.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-9"><span class="nav-number">13.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%951"><span class="nav-number">13.2.1.</span> <span class="nav-text">方法1</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-10"><span class="nav-number">13.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-208-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="nav-number">14.</span> <span class="nav-text">(LeetCode-208) 实现 Trie (前缀树)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-11"><span class="nav-number">14.1.</span> <span class="nav-text">题目</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="QingSong"
      src="/images/avatar/avatar.png">
  <p class="site-author-name" itemprop="name">QingSong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">198</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QingSong</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
