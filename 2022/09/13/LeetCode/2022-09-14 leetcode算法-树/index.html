<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="LeetCode">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode算法-树">
<meta property="og:url" content="http://example.com/2022/09/13/LeetCode/2022-09-14%20leetcode%E7%AE%97%E6%B3%95-%E6%A0%91/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="LeetCode">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_54.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_55.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_56.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_57.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_58.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_59.png">
<meta property="og:image" content="http://example.com/images/Leetcode2/Leetcode2_01.png">
<meta property="og:image" content="http://example.com/images/Leetcode2/Leetcode2_02.png">
<meta property="og:image" content="http://example.com/images/Leetcode2/Leetcode2_03.png">
<meta property="og:image" content="http://example.com/images/Leetcode2/Leetcode2_05.png">
<meta property="og:image" content="http://example.com/images/Leetcode2/Leetcode2_06.png">
<meta property="og:image" content="http://example.com/images/Leetcode2/Leetcode2_08.png">
<meta property="og:image" content="http://example.com/images/Leetcode2/Leetcode2_09.png">
<meta property="og:image" content="http://example.com/images/Leetcode2/Leetcode2_10.png">
<meta property="og:image" content="http://example.com/2022/09/13/images/Leetcode2/Leetcode2_11.png">
<meta property="og:image" content="http://example.com/images/Leetcode2/Leetcode2_12.png">
<meta property="og:image" content="http://example.com/images/Leetcode2/Leetcode2_13.png">
<meta property="article:published_time" content="2022-09-13T03:51:25.990Z">
<meta property="article:modified_time" content="2022-09-27T07:12:27.076Z">
<meta property="article:author" content="QingSong">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/Leetcode/Leetcode_54.png">

<link rel="canonical" href="http://example.com/2022/09/13/LeetCode/2022-09-14%20leetcode%E7%AE%97%E6%B3%95-%E6%A0%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>leetcode算法-树 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">点滴积累 豁达处之</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/13/LeetCode/2022-09-14%20leetcode%E7%AE%97%E6%B3%95-%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar/avatar.png">
      <meta itemprop="name" content="QingSong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leetcode算法-树
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-13 11:51:25" itemprop="dateCreated datePublished" datetime="2022-09-13T11:51:25+08:00">2022-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-27 15:12:27" itemprop="dateModified" datetime="2022-09-27T15:12:27+08:00">2022-09-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          
            <div class="post-description">LeetCode</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p> leetcode算法</p>
<a id="more"></a> 

<h2 id="LeetCode-94-二叉树的中序遍历"><a href="#LeetCode-94-二叉树的中序遍历" class="headerlink" title="(LeetCode-94) 二叉树的中序遍历"></a>(LeetCode-94) <strong>二叉树的中序遍历</strong></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class InorderTraversal &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyTreeNode nodei &#x3D; new MyTreeNode(9);</span><br><span class="line">        MyTreeNode nodeh &#x3D; new MyTreeNode(8);</span><br><span class="line">        MyTreeNode nodeg &#x3D; new MyTreeNode(7);</span><br><span class="line">        MyTreeNode nodef &#x3D; new MyTreeNode(6);</span><br><span class="line">        MyTreeNode nodee &#x3D; new MyTreeNode(5, null, nodei);</span><br><span class="line">        MyTreeNode noded &#x3D; new MyTreeNode(4, nodeg ,nodeh);</span><br><span class="line">        MyTreeNode nodec &#x3D; new MyTreeNode(3,nodee,nodef);</span><br><span class="line">        MyTreeNode nodeb &#x3D; new MyTreeNode(2,noded,null);</span><br><span class="line">        MyTreeNode nodea &#x3D; new MyTreeNode(1, nodeb, nodec);</span><br><span class="line">        List&lt;MyTreeNode&gt; list &#x3D;  inorderTraversal(nodea);</span><br><span class="line">        for(MyTreeNode node : list )&#123;</span><br><span class="line">            System.out.println(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 递归</span><br><span class="line">&#x2F;&#x2F;    public static List&lt;MyTreeNode&gt; inorderTraversal(MyTreeNode root) &#123;</span><br><span class="line">&#x2F;&#x2F;        List&lt;MyTreeNode&gt; list &#x3D; new ArrayList&lt;MyTreeNode&gt;();</span><br><span class="line">&#x2F;&#x2F;        accessTree(root, list);</span><br><span class="line">&#x2F;&#x2F;        return list;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;    public static void accessTree(MyTreeNode root, List&lt;MyTreeNode&gt; res) &#123;</span><br><span class="line">&#x2F;&#x2F;        if(root &#x3D;&#x3D; null)&#123;</span><br><span class="line">&#x2F;&#x2F;            return ;</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">&#x2F;&#x2F;        if(root.left !&#x3D; null)&#123;</span><br><span class="line">&#x2F;&#x2F;            accessTree( root.left, res);</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">&#x2F;&#x2F;        res.add(root);</span><br><span class="line">&#x2F;&#x2F;        if(root.right !&#x3D; null)&#123;</span><br><span class="line">&#x2F;&#x2F;            accessTree( root.right, res);</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 迭代</span><br><span class="line">    public static List&lt;MyTreeNode&gt; inorderTraversal(MyTreeNode root) &#123;</span><br><span class="line">        List&lt;MyTreeNode&gt; list &#x3D; new ArrayList&lt;MyTreeNode&gt;();</span><br><span class="line">        Stack&lt;MyTreeNode&gt; stack &#x3D; new Stack&lt;MyTreeNode&gt;();</span><br><span class="line">        while (root !&#x3D; null || !stack.isEmpty())&#123;</span><br><span class="line">            while (root !&#x3D; null)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root &#x3D; root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; stack.pop();</span><br><span class="line">            list.add(root);</span><br><span class="line">            root &#x3D; root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-101-对称二叉树"><a href="#LeetCode-101-对称二叉树" class="headerlink" title="(LeetCode-101) 对称二叉树"></a>(LeetCode-101) <strong>对称二叉树</strong></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称</p>
<p><strong>示例 1：</strong></p>
<p><img src="/images/Leetcode/Leetcode_54.png" alt="Leetcode_54"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/images/Leetcode/Leetcode_55.png" alt="Leetcode_55"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[1, 1000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>进阶：</strong>你可以运用递归和迭代两种方法解决这个问题吗？</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(int val) &#123; this.val &#x3D; val; &#125;</span><br><span class="line">    TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        this.val &#x3D; val;</span><br><span class="line">        this.left &#x3D; left;</span><br><span class="line">        this.right &#x3D; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Symmetric &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;        TreeNode nodei &#x3D; new TreeNode(9);</span><br><span class="line">&#x2F;&#x2F;        TreeNode nodeh &#x3D; new TreeNode(8);</span><br><span class="line">        TreeNode nodeg &#x3D; new TreeNode(5);</span><br><span class="line">        TreeNode nodef &#x3D; new TreeNode(4);</span><br><span class="line">        TreeNode nodee &#x3D; new TreeNode(5);</span><br><span class="line">        TreeNode noded &#x3D; new TreeNode(4);</span><br><span class="line">        TreeNode nodec &#x3D; new TreeNode(2,nodef,nodeg);</span><br><span class="line">        TreeNode nodeb &#x3D; new TreeNode(2,noded,nodee);</span><br><span class="line">        TreeNode nodea &#x3D; new TreeNode(1, nodeb, nodec);</span><br><span class="line">        System.out.println(isSymmetric(nodea));</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!deepCheck(root.left, root.right)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean deepCheck(TreeNode left, TreeNode right) &#123;</span><br><span class="line">        if(left &#x3D;&#x3D; null &amp;&amp; right &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left &#x3D;&#x3D; null || right &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left.val !&#x3D; right.val)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return deepCheck(left.left, right.right) &amp;&amp; deepCheck(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-110-平衡二叉树"><a href="#LeetCode-110-平衡二叉树" class="headerlink" title="(LeetCode-110) 平衡二叉树"></a>(LeetCode-110) 平衡二叉树</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/images/Leetcode/Leetcode_56.png" alt="Leetcode_56"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/images/Leetcode/Leetcode_57.png" alt="Leetcode_57"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,3,3,null,null,4,4]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数在范围 <code>[0, 5000]</code> 内</li>
<li><code>-104 &lt;= Node.val &lt;= 104</code></li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>平衡二叉树要求的是<strong>左右子节点的高度不能超过1</strong>，所以我们可以判断树的左右两个子节点的高度只要不超过<code>1</code>就行，而树的高度怎么计算呢，其实很简单，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;计算树中节点的高度</span><br><span class="line">public int depth(TreeNode root) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; null)</span><br><span class="line">        return 0;</span><br><span class="line">    return Math.max(depth(root.left), depth(root.right)) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class BalancedTree &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TreeNode nodeg &#x3D; new TreeNode(5);</span><br><span class="line">        TreeNode nodef &#x3D; new TreeNode(4);</span><br><span class="line">        TreeNode nodee &#x3D; new TreeNode(5);</span><br><span class="line">        TreeNode noded &#x3D; new TreeNode(4);</span><br><span class="line">        TreeNode nodec &#x3D; new TreeNode(2,nodef,nodeg);</span><br><span class="line">        TreeNode nodeb &#x3D; new TreeNode(2,noded,nodee);</span><br><span class="line">        TreeNode nodea &#x3D; new TreeNode(1, nodeb, nodec);</span><br><span class="line">        System.out.println(isBalanced(nodea));</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">       if(root &#x3D;&#x3D; null)&#123;</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       return helper(root) !&#x3D; -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int helper(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int left &#x3D; helper((root.left));</span><br><span class="line">        int right &#x3D; helper((root.right));</span><br><span class="line">        if(left &#x3D;&#x3D; -1 || right &#x3D;&#x3D; -1 || Math.abs(left - right) &gt; 1)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(left , right) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-226-翻转二叉树"><a href="#LeetCode-226-翻转二叉树" class="headerlink" title="(LeetCode-226) 翻转二叉树"></a>(LeetCode-226) <strong>翻转二叉树</strong></h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/images/Leetcode/Leetcode_58.png" alt="Leetcode_58"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/images/Leetcode/Leetcode_59.png" alt="Leetcode_59"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [2,1,3]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围在 <code>[0, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class InvertTree &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TreeNode nodeg &#x3D; new TreeNode(9);</span><br><span class="line">        TreeNode nodef &#x3D; new TreeNode(6);</span><br><span class="line">        TreeNode nodee &#x3D; new TreeNode(3);</span><br><span class="line">        TreeNode noded &#x3D; new TreeNode(1);</span><br><span class="line">        TreeNode nodec &#x3D; new TreeNode(7,nodef,nodeg);</span><br><span class="line">        TreeNode nodeb &#x3D; new TreeNode(2,noded,nodee);</span><br><span class="line">        TreeNode nodea &#x3D; new TreeNode(4, nodeb, nodec);</span><br><span class="line">        nodea &#x3D; invertTree(nodea);</span><br><span class="line">        System.out.println(nodea.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode temp &#x3D; root.left ;</span><br><span class="line">        root.left &#x3D; root.right;</span><br><span class="line">        root.right &#x3D; temp;</span><br><span class="line">        invertTree( root.left);</span><br><span class="line">        invertTree( root.right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-208-实现-Trie-前缀树"><a href="#LeetCode-208-实现-Trie-前缀树" class="headerlink" title="(LeetCode-208) 实现 Trie (前缀树)"></a>(LeetCode-208) 实现 Trie (前缀树)</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p>请你实现 Trie 类：</p>
<ul>
<li>Trie() 初始化前缀树对象。</li>
<li>void insert(String word) 向前缀树中插入字符串 word 。</li>
<li>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。</li>
<li>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; 返回 True</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 False</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; 返回 True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 True</span><br></pre></td></tr></table></figure>

<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h4><p>要解决这个题目，首先要搞明白什么是Trie树。</p>
<h5 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h5><p>即字典树，也有的称为前缀树，是一种树形结构。广泛应用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。</p>
<p>Trie的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p>
<p>先看一下几个场景问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.我们输入n个单词，每次查询一个单词，需要回答出这个单词是否在之前输入的n单词中出现过。</span><br><span class="line">答：当然是用map来实现。</span><br><span class="line"></span><br><span class="line">2.我们输入n个单词，每次查询一个单词的前缀，需要回答出这个前缀是之前输入的n单词中多少个单词的前缀？</span><br><span class="line">答：还是可以用map做，把输入n个单词中的每一个单词的前缀分别存入map中，然后计数，这样的话复杂度会非常的高。若有n个单词，平均每个单词的长度为c，那么复杂度就会达到nc。</span><br></pre></td></tr></table></figure>

<p>因此我们需要更加高效的数据结构，这时候就是Trie树的用武之地了。现在我们通过例子来理解什么是Trie树。现在我们对cat、cash、apple、aply、ok这几个单词建立一颗Trie树。</p>
<p><img src="/images/Leetcode2/Leetcode2_01.png" alt="Leetcode2_01"></p>
<p>从图中可以看出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.每一个节点代表一个字符</span><br><span class="line">2.有相同前缀的单词在树中就有公共的前缀节点。</span><br><span class="line">3.整棵树的根节点是空的。</span><br><span class="line">4.每个节点结束的时候用一个特殊的标记来表示，这里我们用-1来表示结束，从根节点到-1所经过的所有的节点对应一个英文单词。</span><br><span class="line">5.查询和插入的时间复杂度为O(k)，k为字符串长度，当然如果大量字符串没有共同前缀时还是很耗内存的。</span><br></pre></td></tr></table></figure>

<p>理解了Trie树以后，代码实现就很简单了，既可以用数组实现，也可以用Map实现。</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class Trie &#123;</span><br><span class="line">    private Trie[] children;</span><br><span class="line">    private boolean isEnd;</span><br><span class="line"></span><br><span class="line">    public Trie() &#123;</span><br><span class="line">        children &#x3D; new Trie[26];</span><br><span class="line">        isEnd &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void insert(String word) &#123;</span><br><span class="line">        Trie node &#x3D; this;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; word.length(); i++) &#123;</span><br><span class="line">            char ch &#x3D; word.charAt(i);</span><br><span class="line">            int index &#x3D; ch - &#39;a&#39;;</span><br><span class="line">            if (node.children[index] &#x3D;&#x3D; null) &#123;</span><br><span class="line">                node.children[index] &#x3D; new Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node &#x3D; node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        Trie node &#x3D; searchPrefix(word);</span><br><span class="line">        return node !&#x3D; null &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean startsWith(String prefix) &#123;</span><br><span class="line">        return searchPrefix(prefix) !&#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Trie searchPrefix(String prefix) &#123;</span><br><span class="line">        Trie node &#x3D; this;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            char ch &#x3D; prefix.charAt(i);</span><br><span class="line">            int index &#x3D; ch - &#39;a&#39;;</span><br><span class="line">            if (node.children[index] &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            node &#x3D; node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-236-二叉树的最近公共祖先"><a href="#LeetCode-236-二叉树的最近公共祖先" class="headerlink" title="(LeetCode-236) 二叉树的最近公共祖先"></a>(LeetCode-236) 二叉树的最近公共祖先</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p><strong>示例 1：</strong></p>
<p><img src="/images/Leetcode2/Leetcode2_02.png" alt="Leetcode2_02"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/images/Leetcode2/Leetcode2_03.png" alt="Leetcode2_03"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a><strong>方法</strong></h4><p>思路和算法</p>
<p>我们递归遍历整棵二叉树，定义 fx 表示 x 节点的子树中是否包含 p 节点或 q 节点，如果包含为 true，否则为 false。那么符合条件的最近公共祖先 x 一定满足如下条件：</p>
<p><img src="/images/Leetcode2/Leetcode2_05.png" alt="Leetcode2_05"></p>
<p>其中 lson 和 rson 分别代表 x 节点的左孩子和右孩子。初看可能会感觉条件判断有点复杂，我们来一条条看，</p>
<ul>
<li><p>flson &amp;&amp; frson说明左子树和右子树均包含 p 节点或 q 节点，如果左子树包含的是 p 节点，那么右子树只能包含 q 节点，反之亦然，因为p 节点和 q 节点都是不同且唯一的节点，因此如果满足这个判断条件即可说明 x 就是我们要找的最近公共祖先</p>
</li>
<li><p>再来看第二条判断条件，这个判断条件即是考虑了 x 恰好是 p 节点或 q 节点且它的左子树或右子树有一个包含了另一个节点的情况，因此如果满足这个判断条件亦可说明 x 就是我们要找的最近公共祖先。</p>
</li>
</ul>
<p>你可能会疑惑这样找出来的公共祖先深度是否是最大的。其实是最大的，因为我们是自底向上从叶子节点开始更新的，所以在所有满足条件的公共祖先中一定是深度最大的祖先先被访问到，且由于 fx 本身的定义很巧妙，在找到最近公共祖先 x 以后, fx 按定义被设置为 true ，即假定了这个子树中只有一个 p 节点或 q 节点，因此其他公共祖先不会再被判断为符合条件。</p>
<p>下图展示了一个示例，搜索树中两个节点 <code>9</code> 和 <code>11</code> 的最近公共祖先。</p>
<p><img src="/images/Leetcode2/Leetcode2_06.png" alt="Leetcode2_06"></p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(int val) &#123; this.val &#x3D; val; &#125;</span><br><span class="line">    TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        this.val &#x3D; val;</span><br><span class="line">        this.left &#x3D; left;</span><br><span class="line">        this.right &#x3D; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LowestCommonAncestor &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TreeNode node7 &#x3D; new TreeNode(7);</span><br><span class="line">        TreeNode node4 &#x3D; new TreeNode(4);</span><br><span class="line">        TreeNode node0 &#x3D; new TreeNode(0);</span><br><span class="line">        TreeNode node8 &#x3D; new TreeNode(8);</span><br><span class="line">        TreeNode node6 &#x3D; new TreeNode(6);</span><br><span class="line">        TreeNode node2 &#x3D; new TreeNode(2, node7, node4);</span><br><span class="line">        TreeNode node5 &#x3D; new TreeNode(5, node6, node2);</span><br><span class="line">        TreeNode node1 &#x3D; new TreeNode(1, node0, node8);</span><br><span class="line">        TreeNode node3 &#x3D; new TreeNode(3, node5, node1);</span><br><span class="line">        TreeNode node &#x3D; new LowestCommonAncestor().lowestCommonAncestor(node3, node5, node4);</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        &#x2F;&#x2F; 找到p 或q 所在节点， 终止递归； 或者找到叶子节点也没有找到q 或 q</span><br><span class="line">        if(root &#x3D;&#x3D; null || root &#x3D;&#x3D; p || root &#x3D;&#x3D; q) return root;</span><br><span class="line">        &#x2F;&#x2F; 返回时left和right 的返回结果是p或者q 或者为null， 或者p 和q的公共祖先node</span><br><span class="line">        TreeNode left &#x3D; lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right &#x3D; lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#x2F;&#x2F; left 和 right 不为空， 说明p和q就在当前节点下， 当前节点就是我们需要的最近公共祖先</span><br><span class="line">        if(left !&#x3D; null &amp;&amp; right !&#x3D; null) return root;</span><br><span class="line">        &#x2F;&#x2F; left 和 right 有一个为空， 返回不为空的那个</span><br><span class="line">        &#x2F;&#x2F; left 和right 的都为空， 返回哪个都可以， 这里统一返回right</span><br><span class="line">        return left !&#x3D; null ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-437-路径总和-III"><a href="#LeetCode-437-路径总和-III" class="headerlink" title="(LeetCode-437)路径总和 III"></a>(LeetCode-437)路径总和 III</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p>
<p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/images/Leetcode2/Leetcode2_08.png" alt="Leetcode2_08"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], targetSum &#x3D; 8</span><br><span class="line">输出：3</span><br><span class="line">解释：和等于 8 的路径有 3 条，如图所示。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><h4 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h4><p>思路与算法</p>
<p>我们首先想到的解法是穷举所有的可能，我们访问每一个节点 node，检测以 node 为起始节点且向下延深的路径有多少种。我们递归遍历每一个节点的所有可能的路径，然后将这些路径数目加起来即为返回结果。</p>
<ul>
<li><p>我们首先定义 rootSum(p,val) 表示以节点 p 为起点向下且满足路径总和为 valval 的路径数目。我们对二叉树上每个节点 p 求出 rootSum(p,targetSum)，然后对这些路径数目求和即为返回结果。</p>
</li>
<li><p>我们对节点 p 求 rootSum(p,targetSum) 时，以当前节点 p 为目标路径的起点递归向下进行搜索。假设当前的节点 p 的值为 val，我们对左子树和右子树进行递归搜索，对节点 p 的左孩子节点 pl 求出 rootSum(pl,targetSum−val)，以及对右孩子节点 pr 求出 rootSum(pr,targetSum−val)。节点 p 的rootSum(p,targetSum) 即等于 rootSum(pl,targetSum−val) 与 rootSum(pr,targetSum−val) 之和，同时我们还需要判断一下当前节点 p 的值是否刚好等于 targetSum。</p>
</li>
<li><p>我们采用递归遍历二叉树的每个节点 p，对节点 p 求 rootSum(p,val)，然后将每个节点所有求的值进行相加求和返回。</p>
</li>
</ul>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 暴力</span><br><span class="line">public int pathSum(TreeNode root, int targetSum) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ret &#x3D; rootSum(root, targetSum);</span><br><span class="line">        ret +&#x3D; pathSum(root.left, targetSum);</span><br><span class="line">        ret +&#x3D; pathSum(root.right, targetSum);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int rootSum(TreeNode root, int targetSum) &#123;</span><br><span class="line">        int ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int val &#x3D; root.val;</span><br><span class="line">        if (val &#x3D;&#x3D; targetSum) &#123;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        ret +&#x3D; rootSum(root.left, targetSum - val);</span><br><span class="line">        ret +&#x3D; rootSum(root.right, targetSum - val);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 前缀和</span><br><span class="line"> public int pathSum(TreeNode root, int targetSum) &#123;</span><br><span class="line">        Map&lt;Long, Integer&gt; prefix &#x3D; new HashMap&lt;Long, Integer&gt;();</span><br><span class="line">        prefix.put(0L, 1);</span><br><span class="line">        return dfs(root, prefix, 0, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int dfs(TreeNode root, Map&lt;Long, Integer&gt; prefix, long curr, int targetSum) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ret &#x3D; 0;</span><br><span class="line">        curr +&#x3D; root.val;</span><br><span class="line"></span><br><span class="line">        ret &#x3D; prefix.getOrDefault(curr - targetSum, 0);</span><br><span class="line">        prefix.put(curr, prefix.getOrDefault(curr, 0) + 1);</span><br><span class="line">        ret +&#x3D; dfs(root.left, prefix, curr, targetSum);</span><br><span class="line">        ret +&#x3D; dfs(root.right, prefix, curr, targetSum);</span><br><span class="line">        prefix.put(curr, prefix.getOrDefault(curr, 0) - 1);</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-450-删除二叉搜索树中的节点"><a href="#LeetCode-450-删除二叉搜索树中的节点" class="headerlink" title="(LeetCode-450) 删除二叉搜索树中的节点"></a>(LeetCode-450) 删除二叉搜索树中的节点</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<ul>
<li>首先找到需要删除的节点；</li>
<li>如果找到了，删除它。</li>
</ul>
<p><strong>示例 1:</strong></p>
<p><img src="/images/Leetcode2/Leetcode2_09.png" alt="Leetcode2_09"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 3</span><br><span class="line">输出：[5,4,6,2,null,null,7]</span><br><span class="line">解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。</span><br><span class="line">一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。</span><br><span class="line">另一个正确答案是 [5,2,6,null,4,null,7]。</span><br></pre></td></tr></table></figure>

<p><img src="/images/Leetcode2/Leetcode2_10.png" alt="Leetcode2_10"></p>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 0</span><br><span class="line">输出: [5,3,6,2,4,null,7]</span><br><span class="line">解释: 二叉树不包含值为 0 的节点</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [], key &#x3D; 0</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure>

<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><p>思路</p>
<p>二叉搜索树有以下性质：</p>
<ul>
<li>左子树的所有节点（如果有）的值均小于当前节点的值；</li>
<li>右子树的所有节点（如果有）的值均大于当前节点的值；</li>
<li>左子树和右子树均为二叉搜索树。</li>
</ul>
<p>二叉搜索树的题目往往可以用递归来解决。此题要求删除二叉树的节点，函数 deleteNode 的输入是二叉树的根节点 root 和一个整数 key，输出是删除值为 key 的节点后的二叉树，并保持二叉树的有序性。可以按照以下情况分类讨论：</p>
<ul>
<li><p>root 为空，代表未搜索到值为 key 的节点，返回空。 </p>
</li>
<li><p>root.val&gt;key，表示值为 key 的节点可能存在于 root 的左子树中，需要递归地在 root.left 调用 deleteNode，并返回 root。</p>
</li>
<li><p>root.val&lt;key，表示值为 key 的节点可能存在于 root 的右子树中，需要递归地在 root.right 调deleteNode，并返回 root。</p>
</li>
<li><p>root.val=key，root 即为要删除的节点。此时要做的是删除 root，并将它的子树合并成一棵子树，保持有序性，并返回根节点。根据 root 的子树情况分成以下情况讨论：</p>
<ul>
<li><p>root 为叶子节点，没有子树。此时可以直接将它删除，即返回空。</p>
</li>
<li><p>root 只有左子树，没有右子树。此时可以将它的左子树作为新的子树，返回它的左子节点。</p>
</li>
<li><p>root 只有右子树，没有左子树。此时可以将它的右子树作为新的子树，返回它的右子节点。</p>
</li>
<li><p>root 有左右子树，这时可以将 root 的后继节点（比 root 大的最小节点，即它的右子树中的最小节点，记为 successor）作为新的根节点替代 root，并将 successor 从 root 的右子树中删除，使得在保持有序性的情况下合并左右子树。</p>
<p>简单证明，successor 位于 root 的右子树中，因此大于root 的所有左子节点；successor 是 root 的右子树中的最小节点，因此小于 root 的右子树中的其他节点。以上两点保持了新子树的有序性。</p>
<p>在代码实现上，我们可以先寻找 successor，再删除它。successor 是 root 的右子树中的最小节点，可以先找到 root 的右子节点，再不停地往左子节点寻找，直到找到一个不存在左子节点的节点，这个节点即为 successor。然后递归地在root.right 调用 deleteNode 来删除 successor。因为 successor 没有左子节点，因此这一步递归调用不会再次步入这一种情况。然后将 successor 更新为新的 root 并返回。</p>
</li>
</ul>
</li>
</ul>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class DeleteNode &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TreeNode node9 &#x3D; new TreeNode(38);</span><br><span class="line">        TreeNode node8 &#x3D; new TreeNode(48);</span><br><span class="line">        TreeNode node7 &#x3D; new TreeNode(70);</span><br><span class="line">        TreeNode node4 &#x3D; new TreeNode(40, node9, node8);</span><br><span class="line">        TreeNode node6 &#x3D; new TreeNode(60, node7, null);</span><br><span class="line">        TreeNode node2 &#x3D; new TreeNode(20);</span><br><span class="line">        TreeNode node3 &#x3D; new TreeNode(30, node2, node4);</span><br><span class="line">        TreeNode node5 &#x3D; new TreeNode(50, node3, node6);</span><br><span class="line">        new DeleteNode().deleteNode(node5, 30);</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode deleteNode(TreeNode root, int key) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.val &gt; key) &#123;</span><br><span class="line">            root.left &#x3D; deleteNode(root.left, key);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.val &lt; key) &#123;</span><br><span class="line">            root.right &#x3D; deleteNode(root.right, key);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.val &#x3D;&#x3D; key) &#123;</span><br><span class="line">            if (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            if (root.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            if (root.left &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode successor &#x3D; root.right;</span><br><span class="line">            while (successor.left !&#x3D; null) &#123;</span><br><span class="line">                successor &#x3D; successor.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root.right &#x3D; deleteNode(root.right, successor.val);</span><br><span class="line">            successor.right &#x3D; root.right;</span><br><span class="line">            successor.left &#x3D; root.left;</span><br><span class="line">            return successor;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-538-把二叉搜索树转换为累加树"><a href="#LeetCode-538-把二叉搜索树转换为累加树" class="headerlink" title="**(LeetCode-538) **把二叉搜索树转换为累加树"></a>**(LeetCode-538) **把二叉搜索树转换为累加树</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<ul>
<li>节点的左子树仅包含键 小于 节点键的节点。</li>
<li>节点的右子树仅包含键 大于 节点键的节点。</li>
<li>左右子树也必须是二叉搜索树。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="../../images/Leetcode2/Leetcode2_11.png" alt="Leetcode2_11"></p>
<h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>二叉搜索树的中序遍历是一个单调递增的有序序列。如果我们反序地中序遍历该二叉搜索树，即可得到一个单调递减的有序序列。</p>
<h4 id="方法一：反序中序遍历"><a href="#方法一：反序中序遍历" class="headerlink" title="方法一：反序中序遍历"></a>方法一：反序中序遍历</h4><p>思路及算法</p>
<p>本题中要求我们将每个节点的值修改为原来的节点值加上所有大于它的节点值之和。这样我们只需要反序中序遍历该二叉搜索树，记录过程中的节点值之和，并不断更新当前遍历到的节点的节点值，即可得到题目要求的累加树。</p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ConvertBST &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TreeNode node5 &#x3D; new TreeNode(5);</span><br><span class="line">        TreeNode node8 &#x3D; new TreeNode(8);</span><br><span class="line">        TreeNode node7 &#x3D; new TreeNode(7, null, node8);</span><br><span class="line">        TreeNode node3 &#x3D; new TreeNode(3);</span><br><span class="line">        TreeNode node0 &#x3D; new TreeNode(0);</span><br><span class="line">        TreeNode node6 &#x3D; new TreeNode(6, node5, node7);</span><br><span class="line">        TreeNode node2 &#x3D; new TreeNode(2, null, node3);</span><br><span class="line">        TreeNode node1 &#x3D; new TreeNode(1, node0, node2);</span><br><span class="line">        TreeNode node4 &#x3D; new TreeNode(4, node1, node6);</span><br><span class="line">        new ConvertBST().convertBST(node4);</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    public TreeNode convertBST(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        convertBST(root.right);</span><br><span class="line">        sum +&#x3D; root.val;</span><br><span class="line">        root.val &#x3D; sum;</span><br><span class="line">        convertBST(root.left);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-543-二叉树的直径"><a href="#LeetCode-543-二叉树的直径" class="headerlink" title="**(LeetCode-543) **二叉树的直径"></a>**(LeetCode-543) **二叉树的直径</h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p><strong>示例 :</strong><br>给定二叉树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \     </span><br><span class="line">4   5   </span><br></pre></td></tr></table></figure>

<p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p>
<h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a><strong>方法</strong></h4><p>通过示例，我们能够看到，一棵二叉树里两个结点路径长度中的最大值，其实就是树的左右子树中深度最大的两个子节点的路径，所以可以通过不断寻找左右子树中最深的节点来解决这个问题。</p>
<h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int max &#x3D; 0;</span><br><span class="line">   public int diameterOfBinaryTree(TreeNode root) &#123;</span><br><span class="line">       depth(root);</span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br><span class="line">   private int depth(TreeNode root) &#123;</span><br><span class="line">       if(root &#x3D;&#x3D; null) return 0;</span><br><span class="line">       int left &#x3D; depth(root.left);</span><br><span class="line">       int right &#x3D; depth(root.right);</span><br><span class="line">       max &#x3D; Math.max(max, left + right);</span><br><span class="line">       return Math.max(left, right) + 1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-124-二叉树中的最大路径和"><a href="#LeetCode-124-二叉树中的最大路径和" class="headerlink" title="**(LeetCode-124) **二叉树中的最大路径和"></a>**(LeetCode-124) **二叉树中的最大路径和</h2><h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h3><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次 。该路径 至少包含一个 节点</strong>，且不一定经过根节点。</p>
<p><strong>路径和</strong> 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 <strong>最大路径和</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/images/Leetcode2/Leetcode2_12.png" alt="Leetcode2_12"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 &#x3D; 6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/images/Leetcode2/Leetcode2_13.png" alt="Leetcode2_13"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 &#x3D; 42</span><br></pre></td></tr></table></figure>

<h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class MaxPathSum &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TreeNode node3 &#x3D; new TreeNode(-1);</span><br><span class="line">        TreeNode node5 &#x3D; new TreeNode(2, node3, null);</span><br><span class="line">        new MaxPathSum().maxPathSum(node5);</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int maxPathSum(TreeNode root) &#123;</span><br><span class="line">        deptSum( root);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     static int max &#x3D; Integer.MIN_VALUE;</span><br><span class="line">    public int deptSum(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null) return 0;</span><br><span class="line">        int left &#x3D; Math.max(deptSum(root.left), 0) ;</span><br><span class="line">        int right &#x3D; Math.max(deptSum(root.right), 0) ;</span><br><span class="line">        max &#x3D; Math.max(max, left + right + root.val);</span><br><span class="line">        return Math.max(left, right) + root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LeetCode/" rel="tag"># LeetCode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/09/13/LeetCode/2022-09-13%20leetcode%E7%AE%97%E6%B3%95-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" rel="prev" title="leetcode算法-栈与队列">
      <i class="fa fa-chevron-left"></i> leetcode算法-栈与队列
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/09/14/LeetCode/2022-09-15%20leetcode%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/" rel="next" title="leetcode算法-排序">
      leetcode算法-排序 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.</span> <span class="nav-text">(LeetCode-94) 二叉树的中序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE"><span class="nav-number">1.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">1.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.</span> <span class="nav-text">(LeetCode-101) 对称二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="nav-number">2.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="nav-number">2.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.</span> <span class="nav-text">(LeetCode-110) 平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="nav-number">3.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90"><span class="nav-number">3.2.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="nav-number">3.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">4.</span> <span class="nav-text">(LeetCode-226) 翻转二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-3"><span class="nav-number">4.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="nav-number">4.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-208-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="nav-number">5.</span> <span class="nav-text">(LeetCode-208) 实现 Trie (前缀树)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-4"><span class="nav-number">5.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-1"><span class="nav-number">5.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.1.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Trie%E6%A0%91"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">Trie树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="nav-number">5.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">6.</span> <span class="nav-text">(LeetCode-236) 二叉树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-5"><span class="nav-number">6.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-2"><span class="nav-number">6.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-1"><span class="nav-number">6.2.1.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="nav-number">6.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="nav-number">7.</span> <span class="nav-text">(LeetCode-437)路径总和 III</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-6"><span class="nav-number">7.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-3"><span class="nav-number">7.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">7.2.1.</span> <span class="nav-text">方法一：深度优先搜索</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="nav-number">7.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">8.</span> <span class="nav-text">(LeetCode-450) 删除二叉搜索树中的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-7"><span class="nav-number">8.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-4"><span class="nav-number">8.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E9%80%92%E5%BD%92"><span class="nav-number">8.2.1.</span> <span class="nav-text">方法一：递归</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="nav-number">8.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="nav-number">9.</span> <span class="nav-text">**(LeetCode-538) **把二叉搜索树转换为累加树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-8"><span class="nav-number">9.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-5"><span class="nav-number">9.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%8F%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">9.2.1.</span> <span class="nav-text">方法一：反序中序遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="nav-number">9.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="nav-number">10.</span> <span class="nav-text">**(LeetCode-543) **二叉树的直径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-9"><span class="nav-number">10.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-6"><span class="nav-number">10.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-2"><span class="nav-number">10.2.1.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-9"><span class="nav-number">10.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">11.</span> <span class="nav-text">**(LeetCode-124) **二叉树中的最大路径和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-10"><span class="nav-number">11.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-7"><span class="nav-number">11.2.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-10"><span class="nav-number">11.3.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="QingSong"
      src="/images/avatar/avatar.png">
  <p class="site-author-name" itemprop="name">QingSong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">198</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QingSong</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
