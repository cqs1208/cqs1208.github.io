<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="LeetCode">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode算法-数组">
<meta property="og:url" content="http://example.com/2022/09/08/LeetCode/2022-09-09%20leetcode%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="LeetCode">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_35.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_36.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_37.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_38.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_123.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_124.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_125.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_126.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_127.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_128.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_129.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_130.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_131.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_132.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_133.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_134.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_135.gif">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_136.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_137.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_138.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_139.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_140.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_141.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_142.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_143.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_144.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_145.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_146.png">
<meta property="og:image" content="http://example.com/images/Leetcode/Leetcode_147.png">
<meta property="og:image" content="http://example.com/2022/09/08/LeetCode/2022-09-09%20leetcode%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/images/Leetcode2/Leetcode2_14.png">
<meta property="og:image" content="http://example.com/2022/09/08/LeetCode/2022-09-09%20leetcode%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/">
<meta property="og:image" content="http://example.com/2022/09/08/LeetCode/2022-09-09%20leetcode%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/">
<meta property="article:published_time" content="2022-09-08T07:28:48.454Z">
<meta property="article:modified_time" content="2022-09-27T07:12:17.705Z">
<meta property="article:author" content="QingSong">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/Leetcode/Leetcode_35.png">

<link rel="canonical" href="http://example.com/2022/09/08/LeetCode/2022-09-09%20leetcode%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>leetcode算法-数组 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">点滴积累 豁达处之</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/08/LeetCode/2022-09-09%20leetcode%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar/avatar.png">
      <meta itemprop="name" content="QingSong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leetcode算法-数组
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-08 15:28:48" itemprop="dateCreated datePublished" datetime="2022-09-08T15:28:48+08:00">2022-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-27 15:12:17" itemprop="dateModified" datetime="2022-09-27T15:12:17+08:00">2022-09-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          
            <div class="post-description">LeetCode</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p> leetcode算法</p>
<a id="more"></a> 

<h2 id="LeetCode-1-两数之和"><a href="#LeetCode-1-两数之和" class="headerlink" title="(LeetCode-1)两数之和"></a>(LeetCode-1)两数之和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,4], target &#x3D; 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a><strong>方法1</strong></h4><p>暴力穷举，复杂度O(n2)。</p>
<p>对数组中每个元素，都去计算它和数组中其他元素的和sum是否等于目标值 target，如果是则返回结果，不是则继续循环，直到将所有元素检查一遍。</p>
<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a><strong>方法2</strong></h4><p> 这道题最优的做法时间复杂度是O(n)。用一个哈希表，存储每个数对应的下标。具体做法是：顺序扫描数组，对每一个元素，在map中找能组合给定值的另一半数字，如果找到了，直接返回2个数字的下标即可。如果找不到，就把这个数字存入map 中，等待扫到“另一半”数字的时候，再取出来返回结果。</p>
<h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class doubleSum &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int nums[] &#x3D; &#123;11,2,7,15&#125;;</span><br><span class="line">        int target &#x3D; 9;</span><br><span class="line">        System.out.println(Arrays.toString(twoSum(nums, target)));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 暴力破解</span><br><span class="line">&#x2F;&#x2F;    public static int[] twoSum(int nums[], int target)&#123;</span><br><span class="line">&#x2F;&#x2F;        for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">&#x2F;&#x2F;            int start &#x3D; nums[i];</span><br><span class="line">&#x2F;&#x2F;            for (int j &#x3D; i + 1; j &lt; nums.length; j++) &#123;</span><br><span class="line">&#x2F;&#x2F;                if (nums[j] + start &#x3D;&#x3D; target)&#123;</span><br><span class="line">&#x2F;&#x2F;                    return new int[]&#123;i,j&#125;;</span><br><span class="line">&#x2F;&#x2F;                &#125;</span><br><span class="line">&#x2F;&#x2F;            &#125;</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">&#x2F;&#x2F;        return new int[]&#123;&#125;;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 借助map</span><br><span class="line">&#x2F;&#x2F;    public static int[] twoSum(int nums[], int target)&#123;</span><br><span class="line">&#x2F;&#x2F;        Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">&#x2F;&#x2F;        for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">&#x2F;&#x2F;            map.put(nums[i], i);</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">&#x2F;&#x2F;            Integer res &#x3D; map.get(target - nums[i]);</span><br><span class="line">&#x2F;&#x2F;            if (res !&#x3D; null)&#123;</span><br><span class="line">&#x2F;&#x2F;                return new int[]&#123;i,res&#125;;</span><br><span class="line">&#x2F;&#x2F;            &#125;</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">&#x2F;&#x2F;        return new int[]&#123;&#125;;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 借助map(优化)</span><br><span class="line">    public static int[] twoSum(int nums[], int target)&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        int [] result &#x3D; new int[2];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            int anothier &#x3D; target - nums[i];</span><br><span class="line">            Integer index &#x3D; map.get(anothier);</span><br><span class="line">            if(null !&#x3D; index)&#123;</span><br><span class="line">                return new int[]&#123;i,index&#125;;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                map.put(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new int[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-88-合并两个有序数组"><a href="#LeetCode-88-合并两个有序数组" class="headerlink" title="(LeetCode-88) 合并两个有序数组"></a>(LeetCode-88) <strong>合并两个有序数组</strong></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a><strong>题目</strong></h3><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br><span class="line">解释：需要合并 [1,2,3] 和 [2,5,6] 。</span><br><span class="line">合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并 [1] 和 [] 。</span><br><span class="line">合并结果是 [1] 。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并的数组是 [] 和 [1] 。</span><br><span class="line">合并结果是 [1] 。</span><br><span class="line">注意，因为 m &#x3D; 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</span><br></pre></td></tr></table></figure>

<p>进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="方法1-1"><a href="#方法1-1" class="headerlink" title="方法1"></a>方法1</h4><p>仔细观察题目我们其实可以发现，这个两个数组本身其实就是已经有序的了，这一点我们没有利用上，所以改进的办法就是利用“双指针”，每次从两个数组头部取出比较小的数字放到结果中。</p>
<p><img src="/images/Leetcode/Leetcode_35.png" alt="Leetcode_35"></p>
<p>这种方法的时间复杂度是多少呢？因为要把两个数组各循环一遍，所以时间复杂度是O(m+n)，在处理上因为需要一个额外的空白数组来存放两个数组的值，所以空间复杂度也是O(m+n)。</p>
<h4 id="方法2-1"><a href="#方法2-1" class="headerlink" title="方法2"></a>方法2</h4><p>方法2中还需要一个长度为m+n的临时数组作为中转，能不能不要这个数组呢？因为题目中的整数数组 nums1的后面还有空位，完全可以利用上。所以改进方法就是，依然使用双指针，但是倒序处理。</p>
<p><img src="/images/Leetcode/Leetcode_36.png" alt="Leetcode_36"></p>
<p>这种情况下，时间复杂度是O(m+n)，空间复杂度则变为O(1)。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class DoubleArr &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int nums1[] &#x3D; &#123;4,5,6,0,0,0&#125;;</span><br><span class="line">        int nums2[] &#x3D; &#123;1,2,3&#125;;</span><br><span class="line">        merge(nums1,3, nums2,3);</span><br><span class="line">        System.out.println(Arrays.toString(nums1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 利用jdk的api</span><br><span class="line">    public static void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">            nums1[m + i] &#x3D; nums1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 双指针，从后往前遍历</span><br><span class="line">&#x2F;&#x2F;    public static void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">&#x2F;&#x2F;        int index1 &#x3D; m - 1;  &#x2F;&#x2F; 数组一的最大下标(不包含末尾非有效数字)</span><br><span class="line">&#x2F;&#x2F;        int index2 &#x3D; n - 1;   &#x2F;&#x2F; 数组二的最大下标</span><br><span class="line">&#x2F;&#x2F;        int resultIndex &#x3D; m + n - 1;  &#x2F;&#x2F; 数组一的最大下标(包含末尾非有效数字)</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        while (index1 &gt;&#x3D; 0 &amp;&amp; index2 &gt;&#x3D; 0)&#123;</span><br><span class="line">&#x2F;&#x2F;            int num1 &#x3D; nums1[index1];</span><br><span class="line">&#x2F;&#x2F;            int num2 &#x3D; nums2[index2];</span><br><span class="line">&#x2F;&#x2F;            if (num1 &gt; num2)&#123;</span><br><span class="line">&#x2F;&#x2F;                index1--;</span><br><span class="line">&#x2F;&#x2F;                nums1[resultIndex] &#x3D; num1;</span><br><span class="line">&#x2F;&#x2F;            &#125;else &#123;</span><br><span class="line">&#x2F;&#x2F;                nums1[resultIndex] &#x3D; num2;</span><br><span class="line">&#x2F;&#x2F;                index2--;</span><br><span class="line">&#x2F;&#x2F;            &#125;</span><br><span class="line">&#x2F;&#x2F;            resultIndex--;</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        if (index2 &gt;&#x3D; 0)&#123; &#x2F;&#x2F; 数组2 还有剩余  同步移动</span><br><span class="line">&#x2F;&#x2F;            for (int i &#x3D; 0; i &lt;&#x3D; index2; i++) &#123;</span><br><span class="line">&#x2F;&#x2F;                nums1[i] &#x3D; nums2[i];</span><br><span class="line">&#x2F;&#x2F;            &#125;</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-283-移动零"><a href="#LeetCode-283-移动零" class="headerlink" title="(LeetCode-283)移动零"></a>(LeetCode-283)移动零</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a><strong>题目</strong></h3><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<ul>
<li>必须在原数组上操作，不能拷贝额外的数组。</li>
<li>尽量减少操作次数</li>
</ul>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h4><p>依然可以用双指针的办法，两个指针i和j。i负责遍历整个数组，在遍历数组的时候，j用来记录<strong>当前</strong>所有非0元素的个数。遍历的时候每遇到一个非0元素就将其往数组左边挪，挪动到J所在的位置，注意是挪动，不是交换位置，j同时也移动一个位置。当第一次遍历完后，j指针的下标就指向了已经排完了位置的最后一个非0元素下标。</p>
<p>进行第二次遍历的时候，起始位置就从j开始到结束，将剩下的这段区域内的元素全部置为0即可。</p>
<p><img src="/images/Leetcode/Leetcode_37.png" alt="Leetcode_37"></p>
<p><img src="/images/Leetcode/Leetcode_38.png" alt="Leetcode_37"></p>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class MoveZero &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      &#x2F;&#x2F;  int nums[] &#x3D; &#123;0,1,0,3,12&#125;;</span><br><span class="line">      &#x2F;&#x2F;  int nums[] &#x3D; &#123;0,0,0,3,12&#125;;</span><br><span class="line">        int nums[] &#x3D; &#123;0,12,0,3,0&#125;;</span><br><span class="line">        moveZeroes(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 交换(一次遍历)</span><br><span class="line">&#x2F;&#x2F;    public static void moveZeroes(int[] nums) &#123;</span><br><span class="line">&#x2F;&#x2F;        int iz &#x3D; 0; &#x2F;&#x2F; 需移动的起始位置</span><br><span class="line">&#x2F;&#x2F;        int moveNum &#x3D; 0; &#x2F;&#x2F; 0的个数</span><br><span class="line">&#x2F;&#x2F;        for(int i &#x3D; 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">&#x2F;&#x2F;            if(nums[i] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">&#x2F;&#x2F;                moveNum+&#x3D;1;</span><br><span class="line">&#x2F;&#x2F;            &#125;</span><br><span class="line">&#x2F;&#x2F;            if( nums[i] !&#x3D; 0)&#123;</span><br><span class="line">&#x2F;&#x2F;               if (moveNum &gt; 0)&#123;  &#x2F;&#x2F; 移动</span><br><span class="line">&#x2F;&#x2F;                   nums[iz] &#x3D; nums[i];</span><br><span class="line">&#x2F;&#x2F;                   nums[i] &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;               &#125;</span><br><span class="line">&#x2F;&#x2F;                iz+&#x3D;1;</span><br><span class="line">&#x2F;&#x2F;            &#125;</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 整体清除(两次遍历)</span><br><span class="line">    public static void moveZeroes(int[] nums) &#123;</span><br><span class="line">        int j &#x3D; 0; &#x2F;&#x2F; 需移动的起始位置</span><br><span class="line">        for(int i &#x3D; 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            if(nums[i] !&#x3D; 0)&#123;</span><br><span class="line">                nums[j++] &#x3D; nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; j; i &lt; nums.length; i++)&#123;</span><br><span class="line">            nums[j++] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-448-找到所有数组中消失的数字"><a href="#LeetCode-448-找到所有数组中消失的数字" class="headerlink" title="(LeetCode-448)找到所有数组中消失的数字"></a>(LeetCode-448)找到所有数组中消失的数字</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,3,2,7,8,2,3,1]</span><br><span class="line">输出：[5,6]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure>

<p> 提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D;&#x3D; nums.length</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 105</span><br><span class="line">1 &lt;&#x3D; nums[i] &lt;&#x3D; n</span><br></pre></td></tr></table></figure>

<p>进阶：你能在不使用额外空间且时间复杂度为 O(n) 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class DailNum &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int nums[] &#x3D; &#123;4,3,2,7,8,2,3,1&#125;;</span><br><span class="line">        for(Integer aa : findDisappearedNumbers(nums))&#123;</span><br><span class="line">            System.out.println(aa);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        for(int num : nums)&#123;</span><br><span class="line">            int x &#x3D; (num - 1) % n;  &#x2F;&#x2F; 对n 取模来还原它本来的值</span><br><span class="line">            nums[x] +&#x3D; n;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">            if(nums[i] &lt;&#x3D; n)&#123;</span><br><span class="line">                result.add(i + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-169-多数元素"><a href="#LeetCode-169-多数元素" class="headerlink" title="(LeetCode-169) 多数元素"></a>(LeetCode-169) 多数元素</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,1,1,1,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><h4 id="方法1-2"><a href="#方法1-2" class="headerlink" title="方法1"></a><strong>方法1</strong></h4><p>很明显，这个题可以使用HashMap来解决这个问题，key表示一个元素，value表示该元素出现的次数。</p>
<p>我们用一个循环遍历数组 nums 并将数组中的每个元素加入哈希映射中。在这之后，我们遍历哈希映射中的所有键值对，返回值最大的键。</p>
<p>很明显这种方法的时间复杂度就是O(n)，空间复杂度也是O(n)，但是不符合题目进阶的要求，所以我们不考虑具体的实现。</p>
<h4 id="方法2-2"><a href="#方法2-2" class="headerlink" title="方法2"></a><strong>方法2</strong></h4><p>这个问题还可以使用Boyer-Moore 投票算法来解决。</p>
<p>这个算法是个什么意思呢？它的核心思想就是对拼消耗。</p>
<p>比如玩一个诸侯争霸的游戏，游戏的胜利条件是：最后还有人活下来的国家就是赢家。</p>
<p>假设你的人口超过总人口一半以上，而且你微操也不错，能保证每个人口出去干仗都能一对一同归于尽。那就完全可以大混战，即使最差的情况下所有人都联合起来对付你，最后肯定你赢。把其他的国家的所有人全部一对一兑子，最后能剩下的必定是自己人。</p>
<p>用个实例来看看，我们引入一个array数组。</p>
<p>为了方便理解举一个示例输入：{1,2,1,3,1,1,2,1,5}</p>
<p>从第一个数字1开始，我们想要把它和一个不是1的数字一起从数组里抵消掉，但是目前我们只扫描了一个1，所以暂时无法抵消它，把它加入到array，array变成了{1}。</p>
<p><img src="/images/Leetcode/Leetcode_123.png" alt="Leetcode_123"></p>
<p>然后继续扫描第二个数，是2，我们可以把它和一个不是2的数字抵消掉了，因为我们之前扫描到一个1，所以array变成了{}。</p>
<p><img src="/images/Leetcode/Leetcode_124.png" alt="Leetcode_124"></p>
<p>继续扫描第三个数1，无法抵消，于是array变成了{1}；接下来扫描到3,可以将3和array数组里面的1抵消,于是array变成了{}。</p>
<p><img src="/images/Leetcode/Leetcode_125.png" alt="Leetcode_125"></p>
<p>接下来扫描到1，此时array为空，所以无法抵消这个1，array变成了{1}；接下来扫描到1，此时虽然array不为空，但是array里也是1，所以还是无法抵消，把它也加入这个array,于是array变成了{1,1}（其实到这我们可以发现，array里面只可能同时存在一种数，因为只有array为空或当前扫描到的数和array里的数字相同时才把这个数字放入array）。</p>
<p><img src="/images/Leetcode/Leetcode_126.png" alt="Leetcode_126"></p>
<p>接下来扫描到2，把它和一个1抵消掉，至于抵消哪一个1，无所谓，array变成了{1}。</p>
<p>接下来扫描到1，不能抵消，array变成了{1,1}，result{1,1,5}接下来扫描到5，可以将5和一个1抵消，array变成了{1}</p>
<p>至此扫描完成了数组里的所有数，array里剩了1，所以1就是大于一半的数字。</p>
<p><img src="/images/Leetcode/Leetcode_127.png" alt="Leetcode_127"></p>
<p>再回顾一下这个过程，其实就是删除（抵消）了（1，2），（1，3），（1，5）剩下了一个1。</p>
<p>可以看到，前面提到array里只可能同时存储一种数字，所以我们用两个变量来优化上述过程，currentNum来表示当前array里存储的数，count表示array的长度，即目前暂时无法删除的元素个数。</p>
<p>依然输入为：{1,2,1,3,1,1,2,1,5}，用这两个变量再重复一遍上面的过程，currentNum 初始化为数组第一个元素，count 初始化为1</p>
<p><img src="/images/Leetcode/Leetcode_128.png" alt="Leetcode_128"></p>
<p>扫描到2，它不等于currentNum，于是可以抵消掉一个currentNum， count -= 1，此时count = 0,其实可以理解为扫到的元素都抵消完了，这里可以暂时不改变currentNum的值。</p>
<p><img src="/images/Leetcode/Leetcode_129.png" alt="Leetcode_129"></p>
<p>扫描到1，它等于currentNum，于是count += 1 =&gt; count = 1</p>
<p><img src="/images/Leetcode/Leetcode_130.png" alt="Leetcode_130"></p>
<p>扫描到3，它不等于currentNum，可以抵消一个currentNum =&gt; count -= 1 =&gt; count = 0，此时又抵消完了。</p>
<p><img src="/images/Leetcode/Leetcode_131.png" alt="Leetcode_131"></p>
<p>扫描到1，它等于currentNum，于是count += 1 =&gt; count = 1</p>
<p>扫描到1，他等于currentNum，无法抵消 =&gt; count += 1 =&gt; count = 2 (扫描完前六个数，剩两个1无法抵消)</p>
<p><img src="/images/Leetcode/Leetcode_132.png" alt="Leetcode_132"></p>
<p>扫描到2，它不等于currentNum，可以抵消一个currentNum =&gt; count -= 1 =&gt; count = 1,此时还剩1个1没有被抵消</p>
<p>扫描到1，它等于currentNum，无法抵消 =&gt; count += 1 =&gt; count = 2</p>
<p>扫描到5，它不等于currentNum，可以抵消一个currentNum =&gt; count -= 1 =&gt; count = 1至此扫描完成，还剩1个1没有被抵消掉，它就是我们要找的数。</p>
<p><img src="/images/Leetcode/Leetcode_133.png" alt="Leetcode_133"></p>
<h2 id="LeetCode-11-盛最多水的容器"><a href="#LeetCode-11-盛最多水的容器" class="headerlink" title="(LeetCode-11) 盛最多水的容器"></a>(LeetCode-11) 盛最多水的容器</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p>
<p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p>说明：你不能倾斜容器。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/images/Leetcode/Leetcode_134.png" alt="Leetcode_134"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height &#x3D; [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><h4 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h4><p>我们先从题目中的示例开始，一步一步地解释双指针算法的过程。稍后再给出算法正确性的证明。</p>
<p>题目中的示例为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 8, 6, 2, 5, 4, 8, 3, 7]</span><br><span class="line"> ^                       ^</span><br></pre></td></tr></table></figure>

<p>在初始时，左右指针分别指向数组的左右两端，它们可以容纳的水量为 \min(1, 7) * 8 = 8min(1,7)∗8=8。</p>
<p>此时我们需要移动一个指针。移动哪一个呢？直觉告诉我们，应该移动对应数字较小的那个指针（即此时的左指针）。这是因为，由于容纳的水量是由</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个指针指向的数字中较小值∗指针之间的距离</span><br></pre></td></tr></table></figure>

<p>决定的。如果我们移动数字较大的那个指针，那么前者「两个指针指向的数字中较小值」不会增加，后者「指针之间的距离」会减小，那么这个乘积会减小。因此，我们移动数字较大的那个指针是不合理的。因此，我们移动 数字较小的那个指针。</p>
<p>所以，我们将左指针向右移动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 8, 6, 2, 5, 4, 8, 3, 7]</span><br><span class="line">    ^                    ^</span><br></pre></td></tr></table></figure>

<p>此时可以容纳的水量为 \min(8, 7) * 7 = 49min(8,7)∗7=49。由于右指针对应的数字较小，我们移动右指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 8, 6, 2, 5, 4, 8, 3, 7]</span><br><span class="line">    ^                 ^</span><br></pre></td></tr></table></figure>

<p>此时可以容纳的水量为 min(8, 3) * 6 = 18min(8,3)∗6=18。由于右指针对应的数字较小，我们移动右指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 8, 6, 2, 5, 4, 8, 3, 7]</span><br><span class="line">    ^              ^</span><br></pre></td></tr></table></figure>

<p>此时可以容纳的水量为 min(8, 8) * 5 = 40min(8,8)∗5=40。两指针对应的数字相同，我们可以任意移动一个，例如左指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 8, 6, 2, 5, 4, 8, 3, 7]</span><br><span class="line">       ^           ^</span><br></pre></td></tr></table></figure>

<p>此时可以容纳的水量为 min(6, 8) * 4 = 24min(6,8)∗4=24。由于左指针对应的数字较小，我们移动左指针，并且可以发现，在这之后左指针对应的数字总是较小，因此我们会一直移动左指针，直到两个指针重合。在这期间，对应的可以容纳的水量为：min(2, 8) * 3 = 6min(2,8)∗3=6，min(5, 8) * 2 = 10min(5,8)∗2=10，min(4, 8) * 1 = 4min(4,8)∗1=4。</p>
<p>在我们移动指针的过程中，计算到的最多可以容纳的数量为 4949，即为最终的答案。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class MaxArea &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums &#x3D; &#123;1,8,6,2,5,4,8,3,7&#125;;</span><br><span class="line">        System.out.println(maxArea(nums));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int maxArea(int[] height) &#123;</span><br><span class="line">        int i &#x3D; 0, j &#x3D; height.length - 1;</span><br><span class="line">        int masWater &#x3D; 0;</span><br><span class="line">        while(i &lt; j)&#123;</span><br><span class="line">            if(height[i] &lt; height[j])&#123;</span><br><span class="line">                masWater &#x3D; Math.max(masWater, (j - i ) * height[i++]);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                masWater &#x3D; Math.max(masWater, (j - i ) * height[j--]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return masWater;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-15-三数之和"><a href="#LeetCode-15-三数之和" class="headerlink" title="(LeetCode-15) 三数之和"></a>(LeetCode-15) 三数之和</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</p>
<p>你返回所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure>

<h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>解题思路：</p>
<ul>
<li>暴力法搜索为 O(N^3)时间复杂度，可通过双指针动态消去无效解来优化效率。</li>
<li>双指针法铺垫： 先将给定 nums 排序，复杂度为 O(NlogN)。<br>双指针法思路： 固定 3 个指针中最左（最小）数字的指针 k，双指针 i，j 分设在数组索引 (k, len(nums))两端，通过双指针交替向中间移动，记录对于每个固定指针 k 的所有满足 nums[k] + nums[i] + nums[j] == 0 的 i,j 组合：<ul>
<li>当 nums[k] &gt; 0 时直接break跳出：因为 nums[j] &gt;= nums[i] &gt;= nums[k] &gt; 0，即 33 个数字都大于 00 ，在此固定指针 k 之后不可能再找到结果了。</li>
<li>当 k &gt; 0且nums[k] == nums[k - 1]时即跳过此元素nums[k]：因为已经将 nums[k - 1] 的所有组合加入到结果中，本次双指针搜索只会得到重复组合。</li>
<li>i，j 分设在数组索引 (k, len(nums))两端，当i &lt; j时循环计算s = nums[k] + nums[i] + nums[j]，并按照以下规则执行双指针移动：<br>当s &lt; 0时，i += 1并跳过所有重复的nums[i]；<br>当s &gt; 0时，j -= 1并跳过所有重复的nums[j]；<br>当s == 0时，记录组合[k, i, j]至res，执行i += 1和j -= 1并跳过所有重复的nums[i]和nums[j]，防止记录到重复组合。</li>
</ul>
</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class ThreeSum &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums &#x3D; &#123;-1,0,1,2,-1,-4&#125;;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list &#x3D; threeSum(nums);</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for(int k &#x3D; 0; k &lt; nums.length - 2; k++)&#123;</span><br><span class="line">            if(nums[k] &gt; 0) break;</span><br><span class="line">            if(k &gt; 0 &amp;&amp; nums[k] &#x3D;&#x3D; nums[k - 1]) continue;</span><br><span class="line">            int i &#x3D; k + 1, j &#x3D; nums.length - 1;</span><br><span class="line">            while(i &lt; j)&#123;</span><br><span class="line">                int sum &#x3D; nums[k] + nums[i] + nums[j];</span><br><span class="line">                if(sum &lt; 0)&#123;</span><br><span class="line">                    while(i &lt; j &amp;&amp; nums[i] &#x3D;&#x3D; nums[++i]); &#x2F;&#x2F; 数字重复，则结果还是小于0，继续查找下一个</span><br><span class="line">                &#125; else if (sum &gt; 0) &#123;</span><br><span class="line">                    while(i &lt; j &amp;&amp; nums[j] &#x3D;&#x3D; nums[--j]);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    res.add(new ArrayList&lt;Integer&gt;(Arrays.asList(nums[k], nums[i], nums[j])));</span><br><span class="line">                    while(i &lt; j &amp;&amp; nums[i] &#x3D;&#x3D; nums[++i]);</span><br><span class="line">                    while(i &lt; j &amp;&amp; nums[j] &#x3D;&#x3D; nums[--j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-31-下一个排列"><a href="#LeetCode-31-下一个排列" class="headerlink" title="(LeetCode-31)下一个排列"></a>(LeetCode-31)下一个排列</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><p>整数数组的一个 <strong>排列</strong>  就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> </li>
</ul>
<p>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li>例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。</li>
<li>类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。</li>
<li>而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p>
<p>必须 <strong>原地</strong> 修改，只允许使用额外常数空间。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,1]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,5]</span><br><span class="line">输出：[1,5,1]</span><br></pre></td></tr></table></figure>

<h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><h4 id="方法一：两遍扫描"><a href="#方法一：两遍扫描" class="headerlink" title="方法一：两遍扫描"></a>方法一：两遍扫描</h4><p>思路及解法</p>
<p>注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。具体地：</p>
<ul>
<li>我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。</li>
<li>同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。</li>
</ul>
<p>以排列 [4,5,2,6,3,1][4,5,2,6,3,1] 为例：</p>
<ul>
<li>我们能找到的符合条件的一对「较小数」与「较大数」的组合为 2 与 3，满足「较小数」尽量靠右，而「较大数」尽可能小。</li>
<li>当我们完成交换后排列变为 [4,5,3,6,2,1][4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6][4,5,3,1,2,6]。</li>
</ul>
<p>具体地，我们这样描述该算法，对于长度为 n 的排列 <em>a</em>：</p>
<ul>
<li>首先从后向前查找第一个顺序对 (i,i+1)，满足 a[i] &lt; a[i+1]。这样「较小数」即为 a[i]。此时 [i+1,n) 必然是下降序列。</li>
</ul>
<p>如果找到了顺序对，那么在区间[i+1,n) 中从后向前查找第一个元素 jj 满足 a[i] &lt; a[j]。这样「较大数」即为 a[j]。</p>
<p>交换 a[i] 与 a[j，此时可以证明区间 [i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n)使其变为升序，而无需对该区间进行排序。</p>
<p><img src="/images/Leetcode/Leetcode_135.gif" alt="Leetcode_135"></p>
<p><strong>注意</strong></p>
<p>如果在步骤 1 找不到顺序对，说明当前序列已经是一个降序序列，即最大的序列，我们直接跳过步骤 2 执行步骤 3，即可得到最小的升序序列。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class NextPermutation &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums &#x3D; &#123;1,2&#125;;</span><br><span class="line">        nextPermutation(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void nextPermutation(int[] nums) &#123;</span><br><span class="line">        int numCount &#x3D; nums.length;</span><br><span class="line">        int start &#x3D; numCount - 2;</span><br><span class="line">        while (start &gt;&#x3D; 0 &amp;&amp; nums[start] &gt;&#x3D; nums[start + 1]) &#123;  &#x2F;&#x2F; 寻找 较小数</span><br><span class="line">            start &#x3D; start -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(start &gt;&#x3D; 0)&#123;</span><br><span class="line">            int end &#x3D; nums.length - 1;</span><br><span class="line">            while (end &gt;&#x3D; 0 &amp;&amp; nums[start] &gt;&#x3D; nums[end])&#123;  &#x2F;&#x2F; 寻找较大值</span><br><span class="line">                end &#x3D; end - 1;</span><br><span class="line">            &#125;</span><br><span class="line">            swap( nums, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse( nums,  start + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    public static  void reverse(int[] nums, int start) &#123;</span><br><span class="line">       int left &#x3D; start, right &#x3D; nums.length - 1;</span><br><span class="line">       while(left &lt; right)&#123;</span><br><span class="line">           swap(nums, left, right);</span><br><span class="line">           left++;</span><br><span class="line">           right--;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static  void swap(int[] nums, int i, int j) &#123;</span><br><span class="line">        int temp &#x3D; nums[i];</span><br><span class="line">        nums[i] &#x3D; nums[j];</span><br><span class="line">        nums[j] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-48-旋转图像"><a href="#LeetCode-48-旋转图像" class="headerlink" title="**(LeetCode-48) **旋转图像"></a>**(LeetCode-48) **旋转图像</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/images/Leetcode/Leetcode_136.png" alt="Leetcode_136"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/images/Leetcode/Leetcode_137.png" alt="Leetcode_137"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure>

<h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><h4 id="方法：用翻转代替旋转"><a href="#方法：用翻转代替旋转" class="headerlink" title="方法：用翻转代替旋转"></a>方法：用翻转代替旋转</h4><p>我们以题目中的示例</p>
<p><img src="/images/Leetcode/Leetcode_138.png" alt="Leetcode_138"></p>
<p>作为例子，先将其通过水平轴翻转得到：</p>
<p><img src="/images/Leetcode/Leetcode_139.png" alt="Leetcode_139"></p>
<p>再根据主对角线翻转得到：</p>
<p><img src="/images/Leetcode/Leetcode_140.png" alt="Leetcode_140"></p>
<p>就得到了答案。这是为什么呢？对于水平轴翻转而言，我们只需要枚举矩阵上半部分的元素，和下半部分的元素进行交换，即</p>
<p><img src="/images/Leetcode/Leetcode_141.png" alt="Leetcode_141"></p>
<p>对于主对角线翻转而言，我们只需要枚举对角线左侧的元素，和右侧的元素进行交换，即</p>
<p><img src="/images/Leetcode/Leetcode_142.png" alt="Leetcode_142"></p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Rotate &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[][] matrix &#x3D; &#123;&#123;5,1,9,11&#125;,&#123;2,4,8,10&#125;,&#123;13,3,6,7&#125;,&#123;15,14,12,16&#125;&#125;;</span><br><span class="line">        rotate( matrix);</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void rotate(int[][] matrix) &#123;</span><br><span class="line">        int n &#x3D; matrix.length;</span><br><span class="line">        &#x2F;&#x2F; 水平翻转</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n &#x2F; 2; i++)&#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt; n; j++)&#123;</span><br><span class="line">                int temp &#x3D; matrix[i][j];</span><br><span class="line">                matrix[i][j] &#x3D; matrix[n - i - 1][j];</span><br><span class="line">                matrix[n - i - 1][j] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 主对角线翻转</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n ; i++)&#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt;&#x3D; i; j++)&#123;</span><br><span class="line">                int temp &#x3D; matrix[i][j];</span><br><span class="line">                matrix[i][j] &#x3D; matrix[j][i];</span><br><span class="line">                matrix[j][i] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-54-螺旋矩阵"><a href="#LeetCode-54-螺旋矩阵" class="headerlink" title="**(LeetCode-54) **螺旋矩阵"></a>**(LeetCode-54) **螺旋矩阵</h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/images/Leetcode/Leetcode_143.png" alt="Leetcode_143"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/images/Leetcode/Leetcode_144.png" alt="Leetcode_144"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><h4 id="方法二：按层模拟"><a href="#方法二：按层模拟" class="headerlink" title="方法二：按层模拟"></a>方法二：按层模拟</h4><p>可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。</p>
<p>定义矩阵的第 kk 层是到最近边界距离为 kk 的所有顶点。例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2 层，剩下的元素都是第 3 层。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[1, 1, 1, 1, 1, 1, 1],</span><br><span class="line"> [1, 2, 2, 2, 2, 2, 1],</span><br><span class="line"> [1, 2, 3, 3, 3, 2, 1],</span><br><span class="line"> [1, 2, 2, 2, 2, 2, 1],</span><br><span class="line"> [1, 1, 1, 1, 1, 1, 1]]</span><br></pre></td></tr></table></figure>

<p>对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于(top,left)，右下角位于 (bottom,right)，按照如下顺序遍历当前层的元素。</p>
<ul>
<li>从左到右遍历上侧元素，依次为(top,left) 到(top,right)。</li>
<li>从上到下遍历右侧元素，依次为 (top+1,right) 到 (bottom,right)。</li>
<li>如果left&lt;right 且 top&lt;bottom，则从右到左遍历下侧元素，依次为(bottom,right−1) 到(bottom,left+1)，以及从下到上遍历左侧元素，依次为 (bottom,left) 到(top+1,left)。</li>
</ul>
<p>遍历完当前层的元素之后，将 left 和 top 分别增加 11，将 right 和bottom 分别减少 11，进入下一层继续遍历，直到遍历完所有元素为止。</p>
<p><img src="/images/Leetcode/Leetcode_145.png" alt="Leetcode_145"></p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class SpiralOrder &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       &#x2F;&#x2F; int[][] matrix &#x3D; &#123;&#123;1, 2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;;</span><br><span class="line">        int[][] matrix &#x3D; &#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;;</span><br><span class="line">        &#x2F;&#x2F;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">        List&lt;Integer&gt; list &#x3D; spiralOrder( matrix);</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;</span><br><span class="line">        List&lt;Integer&gt; order &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#x2F;&#x2F; 边界判断</span><br><span class="line">        if (matrix &#x3D;&#x3D; null || matrix.length &#x3D;&#x3D; 0 || matrix[0].length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return order;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 行 列</span><br><span class="line">        int rows &#x3D; matrix.length, columns &#x3D; matrix[0].length;</span><br><span class="line">        &#x2F;&#x2F; 边界值</span><br><span class="line">        int left &#x3D; 0, right &#x3D; columns - 1, top &#x3D; 0, bottom &#x3D; rows - 1;</span><br><span class="line">        &#x2F;&#x2F; 遍历 边界值为截止条件</span><br><span class="line">        while (left &lt;&#x3D; right &amp;&amp; top &lt;&#x3D; bottom) &#123;</span><br><span class="line">            &#x2F;&#x2F; 左  -&gt;  右</span><br><span class="line">            for (int column &#x3D; left; column &lt;&#x3D; right; column++) &#123;</span><br><span class="line">                order.add(matrix[top][column]);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 上 -- &gt;  下</span><br><span class="line">            for (int row &#x3D; top + 1; row &lt;&#x3D; bottom; row++) &#123;</span><br><span class="line">                order.add(matrix[row][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 如果左等于又，或上等于下 则说明为单列或单行，则无需反向操作</span><br><span class="line">            if (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">                &#x2F;&#x2F; 右  -&gt; 左</span><br><span class="line">                for (int column &#x3D; right - 1; column &gt; left; column--) &#123;</span><br><span class="line">                    order.add(matrix[bottom][column]);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 下 -- &gt;  上</span><br><span class="line">                for (int row &#x3D; bottom; row &gt; top; row--) &#123;</span><br><span class="line">                    order.add(matrix[row][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 当前层遍历完， 缩小边界值</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        return order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-55-跳跃游戏"><a href="#LeetCode-55-跳跃游戏" class="headerlink" title="**(LeetCode-55) **跳跃游戏"></a>**(LeetCode-55) **跳跃游戏</h2><h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h3><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure>

<h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><h4 id="方法1-3"><a href="#方法1-3" class="headerlink" title="方法1"></a><strong>方法1</strong></h4><p>这个问题，一定要看清楚题目中的“最大长度”，也就是说，如果某个元素的值为3，能够跳跃的长度有1,2,3这三种选择，并不是只能跳跃3步。</p>
<p>由此我们可以推出，如果数组中的元素没有为0的，比如全部都是1或者是大于1的数，那就一定可以到达数组的末尾。如果数组中的元素存在0，则必须在0值之前找到一个值，能够避开这个0，否则的话是没法到达数组的末尾。</p>
<p>于是，这个题目就可以这样处理了：从后往前遍历，如果遇到nums[i] = 0，就找i前面的元素j，使得nums[j] &gt; i - j。如果找不到，则不可能跳跃到num[i+1]，只会落在nums[i] = 0上，返回false。</p>
<p>虽然在具体的代码实现上会有两个循环，但是实际值遍历了数组一次，所以时间复杂度就是O(n)。</p>
<h4 id="方法2-3"><a href="#方法2-3" class="headerlink" title="方法2"></a><strong>方法2</strong></h4><p>这个问题，还可以用动态规划来求解，这是个非常明显的“多阶段决策最优解”类型的问题，每达到一个数组的元素，都是一个决策，这个决策的最优解就是我们当前阶段我们能够跳跃的最大值是多少。</p>
<p>很明显，按照我们求解动态规划问题的步骤和思想，首先设定一个dp数组，dp[i]表示在下标i处能够跳跃的最大值。</p>
<p>对于dp[i]，它等于dp[i-1]跳一格到达i处后剩余的步数和nums[i]的两者中的最大值。因此状态转移方程为：dp[i]=max(dp[i-1]-1,nums[i])</p>
<p>初始化条件就是dp[0]=nums[0]。</p>
<p>在每次循环开始，我们判断dp[i-1]是否等于0，若是，则不可能到达下标i处，因此直接返回false。循环结束后返回true。</p>
<p><img src="/images/Leetcode/Leetcode_146.png" alt="Leetcode_146"></p>
<p>不过仔细分析上述过程可以发现，dp[i]只和dp[i-1]有关，因此可以用一个变量来取代数组。</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class CanJump &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       int[] nums &#x3D; &#123;3,2,1,0,4&#125;;</span><br><span class="line">       &#x2F;&#x2F; int[] nums &#x3D; &#123;2,3,1,1,4&#125;;</span><br><span class="line">        System.out.println(canJump( nums));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 动态规划</span><br><span class="line">    public static boolean canJump(int[] nums) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        int maxStep &#x3D; nums[0];</span><br><span class="line">        for(int i &#x3D; 1; i &lt; n; i++)&#123;</span><br><span class="line">            if(maxStep &#x3D;&#x3D; 0) return false;</span><br><span class="line">            maxStep &#x3D; Math.max(nums[i], maxStep - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 遍历查找为0的是否可以跳过</span><br><span class="line">&#x2F;&#x2F;    public static boolean canJump(int[] nums) &#123;</span><br><span class="line">&#x2F;&#x2F;        if(nums &#x3D;&#x3D; null || nums.length &lt; 2)&#123;</span><br><span class="line">&#x2F;&#x2F;            return true;</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">&#x2F;&#x2F;        for(int i &#x3D; nums.length - 2; i &gt;&#x3D; 0; i--)&#123;</span><br><span class="line">&#x2F;&#x2F;            if(nums[i] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">&#x2F;&#x2F;                if(!checkJump(nums, i))&#123;</span><br><span class="line">&#x2F;&#x2F;                    return false;</span><br><span class="line">&#x2F;&#x2F;                &#125;</span><br><span class="line">&#x2F;&#x2F;            &#125;</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">&#x2F;&#x2F;        return true;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;    &#x2F;&#x2F; 是否可以调过</span><br><span class="line">&#x2F;&#x2F;    private static boolean checkJump(int[] nums, int i) &#123;</span><br><span class="line">&#x2F;&#x2F;        int index &#x3D; i - 1 ;</span><br><span class="line">&#x2F;&#x2F;        while(index &gt;&#x3D; 0 )&#123;</span><br><span class="line">&#x2F;&#x2F;            if(nums[index] &gt; i - index )&#123;</span><br><span class="line">&#x2F;&#x2F;                return true;</span><br><span class="line">&#x2F;&#x2F;            &#125;</span><br><span class="line">&#x2F;&#x2F;            index--;</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">&#x2F;&#x2F;        return false;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-215-数组中的第K个最大元素"><a href="#LeetCode-215-数组中的第K个最大元素" class="headerlink" title="**(LeetCode-215)**数组中的第K个最大元素"></a>**(LeetCode-215)**数组中的第K个最大元素</h2><h3 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h3><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4], k &#x3D; 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6], k &#x3D; 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<h3 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h3><h4 id="方法一：基于快速排序的选择方法"><a href="#方法一：基于快速排序的选择方法" class="headerlink" title="方法一：基于快速排序的选择方法"></a>方法一：基于快速排序的选择方法</h4><p>思路和算法</p>
<p>我们可以用快速排序来解决这个问题，先对原数组排序，再返回倒数第 kk 个位置，这样平均时间复杂度是O(nlogn)，但其实我们可以做的更快。</p>
<p>首先我们来回顾一下快速排序，这是一个典型的分治算法。我们对数组a[l⋯r] 做快速排序的过程是（参考《算法导论》）：</p>
<ul>
<li><strong>分解</strong>： 将数组 a[l⋯r] 「划分」成两个子数组 a[l⋯q−1]、a[q+1⋯r]，使得 a[l⋯q−1] 中的每个元素小于等于 a[q]，且 a[q] 小于等于 a[q+1⋯r] 中的每个元素。其中，计算下标 q 也是「划分」过程的一部分。</li>
<li><strong>解决</strong>： 通过递归调用快速排序，对子数组 a[l⋯q−1] 和 a[q+1⋯r] 进行排序。</li>
<li><strong>合并</strong>： 因为子数组都是原址排序的，所以不需要进行合并操作，a[l⋯r] 已经有序。</li>
<li>上文中提到的 「划分」 过程是：从子数组 a[l⋯r] 中选择任意一个元素 x 作为主元，调整子数组的元素使得左边的元素都小于等于它，右边的元素都大于等于它， xx 的最终位置就是 q。</li>
</ul>
<p>由此可以发现每次经过「划分」操作后，我们一定可以确定一个元素的最终位置，即 x 的最终位置为 q，并且保证 a[l⋯q−1] 中的每个元素小于等于a[q]，且 a[q] 小于等于 a[q+1⋯r] 中的每个元素。所以<strong>只要某次划分的 q 为倒数第 k 个下标的时候，我们就已经找到了答案</strong>。 我们只关心这一点，至于 a[l⋯q−1] 和 a[q+1⋯r] 是否是有序的，我们不关心。</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">public class QuickSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums &#x3D; &#123;3,2,1,5,6,4&#125;;</span><br><span class="line">        int temp &#x3D; findKthLargest( nums, 2);</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public static int findKthLargest(int[] nums, int k)&#123;</span><br><span class="line">         int baseNum &#x3D; nums[0];</span><br><span class="line">         int start &#x3D; 0;</span><br><span class="line">         int end &#x3D; nums.length - 1;</span><br><span class="line">         &#x2F;&#x2F; 转化一下， 第k个元素的下标是nums.length  - k</span><br><span class="line">         int target &#x3D; nums.length  - k;</span><br><span class="line">         while(true)&#123;</span><br><span class="line">             int temp &#x3D; partition( nums,  start,  end);</span><br><span class="line">             if(temp &#x3D;&#x3D; target)&#123;</span><br><span class="line">                 return nums[temp];</span><br><span class="line">             &#125;else if(temp &lt; target)&#123;</span><br><span class="line">                 start &#x3D; temp + 1;</span><br><span class="line">             &#125;else&#123;</span><br><span class="line">                 end &#x3D; temp - 1;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;    public static int partition(int[] nums, int start, int end)&#123;</span><br><span class="line">&#x2F;&#x2F;        int i &#x3D; start;</span><br><span class="line">&#x2F;&#x2F;        int j &#x3D; end;</span><br><span class="line">&#x2F;&#x2F;        if(i &#x3D;&#x3D; j) return i;</span><br><span class="line">&#x2F;&#x2F;        int baseNum &#x3D; nums[i];</span><br><span class="line">&#x2F;&#x2F;        if(i &lt; j)&#123;</span><br><span class="line">&#x2F;&#x2F;            &#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;            while (i &lt; j)&#123;</span><br><span class="line">&#x2F;&#x2F;                while (i &lt; j &amp;&amp; baseNum &lt; nums[j]) &#123;</span><br><span class="line">&#x2F;&#x2F;                    j--;</span><br><span class="line">&#x2F;&#x2F;                &#125;</span><br><span class="line">&#x2F;&#x2F;                if(i &lt; j) &#123;</span><br><span class="line">&#x2F;&#x2F;                    nums[i] &#x3D; nums[j];</span><br><span class="line">&#x2F;&#x2F;                    i++;</span><br><span class="line">&#x2F;&#x2F;                &#125;</span><br><span class="line">&#x2F;&#x2F;                while (i &lt; j &amp;&amp; baseNum &gt; nums[i])&#123;</span><br><span class="line">&#x2F;&#x2F;                    i++;</span><br><span class="line">&#x2F;&#x2F;                &#125;</span><br><span class="line">&#x2F;&#x2F;                if(i &lt; j) &#123;</span><br><span class="line">&#x2F;&#x2F;                    nums[j] &#x3D; nums[i];</span><br><span class="line">&#x2F;&#x2F;                    j--;</span><br><span class="line">&#x2F;&#x2F;                &#125;</span><br><span class="line">&#x2F;&#x2F;            &#125;</span><br><span class="line">&#x2F;&#x2F;            nums[i] &#x3D; baseNum;</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">&#x2F;&#x2F;        int result &#x3D; i;</span><br><span class="line">&#x2F;&#x2F;        return result ;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 快速排序分区方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int partition(int[] array, int start, int end) &#123;</span><br><span class="line">        &#x2F;*只有一个元素时，无需再分区*&#x2F;</span><br><span class="line">        if(start &#x3D;&#x3D; end) return start;</span><br><span class="line">        &#x2F;*随机选取一个基准数*&#x2F;</span><br><span class="line">        int pivot &#x3D; start;</span><br><span class="line">        &#x2F;*zoneIndex是分区指示器，初始值为分区头元素下标减一*&#x2F;</span><br><span class="line">        int zoneIndex &#x3D; start - 1;</span><br><span class="line">        &#x2F;*将基准数和分区尾元素交换位置*&#x2F;</span><br><span class="line">        swap(array, pivot, end);</span><br><span class="line">        for (int i &#x3D; start; i &lt;&#x3D; end; i++)&#123;</span><br><span class="line">            &#x2F;*当前元素小于等于基准数*&#x2F;</span><br><span class="line">            if (array[i] &lt;&#x3D; array[end]) &#123;</span><br><span class="line">                &#x2F;*首先分区指示器累加*&#x2F;</span><br><span class="line">                zoneIndex++;</span><br><span class="line">                &#x2F;*当前元素在分区指示器的右边时，交换当前元素和分区指示器元素*&#x2F;</span><br><span class="line">                if (i &gt; zoneIndex)</span><br><span class="line">                    swap(array, i, zoneIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return zoneIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 交换数组内两个元素</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void swap(int[] array, int i, int j) &#123;</span><br><span class="line">        int temp &#x3D; array[i];</span><br><span class="line">        array[i] &#x3D; array[j];</span><br><span class="line">        array[j] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-347-前-K-个高频元素"><a href="#LeetCode-347-前-K-个高频元素" class="headerlink" title="(LeetCode-347) 前 K 个高频元素"></a><strong>(LeetCode-347) 前 K 个高频元素</strong></h2><h3 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure>

<h3 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h3><h4 id="方法一：堆"><a href="#方法一：堆" class="headerlink" title="方法一：堆"></a>方法一：堆</h4><p>思路与算法</p>
<p>首先遍历整个数组，并使用哈希表记录每个数字出现的次数，并形成一个「出现次数数组」。找出原数组的前 kk 个高频元素，就相当于找出「出现次数数组」的前 kk 大的值。</p>
<p>最简单的做法是给「出现次数数组」排序。但由于可能有O(N) 个不同的出现次数（其中 N 为原数组长度），故总的算法复杂度会达到 O(NlogN)，不满足题目的要求。</p>
<p>在这里，我们可以利用堆的思想：建立一个小顶堆，然后遍历「出现次数数组」：</p>
<ul>
<li>如果堆的元素个数小于 k，就可以直接插入堆中。</li>
<li>如果堆的元素个数等于 k，则检查堆顶与当前出现次数的大小。如果堆顶更大，说明至少有 k 个数字的出现次数比当前值大，故舍弃当前值；否则，就弹出堆顶，并将当前值插入堆中。</li>
</ul>
<p>遍历完成后，堆中的元素就代表了「出现次数数组」中前 <em>k</em> 大的值。</p>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class TopKFrequent &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums &#x3D; &#123;1,1,1,2,2,2,2,4,4,4,4,4,5,5,5,5,5,5,6,6,6,6,6,6,6,3&#125;;</span><br><span class="line">        int[] result &#x3D; topKFrequent( nums,  2);</span><br><span class="line">        System.out.println(Arrays.toString(result));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int[] topKFrequent(int[] nums, int k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; occurrences &#x3D; new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数</span><br><span class="line">        PriorityQueue&lt;int[]&gt; queue &#x3D; new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">            public int compare(int[] m, int[] n) &#123;</span><br><span class="line">                return m[1] - n[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        for (Map.Entry&lt;Integer, Integer&gt; entry : occurrences.entrySet()) &#123;</span><br><span class="line">            int num &#x3D; entry.getKey(), count &#x3D; entry.getValue();</span><br><span class="line">            if (queue.size() &#x3D;&#x3D; k) &#123;</span><br><span class="line">                if (queue.peek()[1] &lt; count) &#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    queue.offer(new int[]&#123;num, count&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                queue.offer(new int[]&#123;num, count&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] ret &#x3D; new int[k];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; k; ++i) &#123;</span><br><span class="line">            ret[i] &#x3D; queue.poll()[0];</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-4-寻找两个正序数组的中位数"><a href="#LeetCode-4-寻找两个正序数组的中位数" class="headerlink" title="**(LeetCode-4) **寻找两个正序数组的中位数"></a>**(LeetCode-4) **寻找两个正序数组的中位数</h2><h3 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h3><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p>
<p>算法的时间复杂度应该为 O(log (m+n)) 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 &#x3D; [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5</span><br></pre></td></tr></table></figure>

<h3 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h3><h4 id="方法一：二分查找"><a href="#方法一：二分查找" class="headerlink" title="方法一：二分查找"></a>方法一：二分查找</h4><p>给定两个有序数组，要求找到两个有序数组的中位数，最直观的思路有以下两种：</p>
<ul>
<li>使用归并的方式，合并两个有序数组，得到一个大的有序数组。大的有序数组的中间位置的元素，即为中位数。</li>
<li>不需要合并两个有序数组，只要找到中位数的位置即可。由于两个数组的长度已知，因此中位数对应的两个数组的下标之和也是已知的。维护两个指针，初始时分别指向两个数组的下标 0 的位置，每次将指向较小值的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到到达中位数的位置。</li>
</ul>
<p>假设两个有序数组的长度分别为 m 和 <em>n</em>，上述两种思路的复杂度如何？</p>
<p>第一种思路的时间复杂度是 O(m+n)，空间复杂度是 O(m+n)。第二种思路虽然可以将空间复杂度降到 O(1)，但是时间复杂度仍是 O(m+n)。</p>
<p>如何把时间复杂度降低到 O(log(m+n)) 呢？如果对时间复杂度的要求有 log，通常都需要用到二分查找，这道题也可以通过二分查找实现。</p>
<p>根据中位数的定义，当 m+n 是奇数时，中位数是两个有序数组中的第(m+n)/2 个元素，当m+n 是偶数时，中位数是两个有序数组中的第(m+n)/2 个元素和第(m+n)/2+1 个元素的平均值。因此，这道题可以转化成寻找两个有序数组中的第 k 小的数，其中 k 为(m+n)/2 或(m+n)/2+1。</p>
<p>假设两个有序数组分别是 A 和 B。要找到第 k 个元素，我们可以比较 A[k/2−1] 和 B[k/2−1]，其中 / 表示整数除法。由于 A[k/2−1] 和 B[k/2−1] 的前面分别有 A[0..k/2−2] 和 B[0..k/2−2]，即 k/2−1 个元素，对于A[k/2−1] 和 B[k/2−1] 中的较小值，最多只会有 (k/2−1)+(k/2−1)≤k−2 个元素比它小，那么它就不能是第 kk 小的数了。</p>
<p>因此我们可以归纳出三种情况：</p>
<ul>
<li>如果 [k/2-1] &lt; B[k/2−1]，则比 A[k/2−1] 小的数最多只有 A 的前 k/2−1 个数和 B 的前 k/2−1 个数，即比 A[k/2−1] 小的数最多只有k−2 个，因此 A[k/2−1] 不可能是第 kk 个数，A[0] 到 A[k/2−1] 也都不可能是第 k 个数，可以全部排除。</li>
<li>如果 A[k/2−1] &gt; B[k/2−1]，则可以排除 B[0] 到 B[k/2−1]。</li>
<li>如果 A[k/2−1] = B[k/2−1]，则可以归入第一种情况处理。</li>
</ul>
<p><img src="/images/Leetcode/Leetcode_147.png" alt="Leetcode_147"></p>
<p>可以看到，比较 A[k/2−1] 和 B[k/2−1] 之后，可以排除 k/2 个不可能是第 k 小的数，查找范围缩小了一半。同时，我们将在排除后的新数组上继续进行二分查找，并且根据我们排除数的个数，减少 k 的值，这是因为我们排除的数都不大于第 k 小的数。</p>
<p>有以下三种情况需要特殊处理：</p>
<ul>
<li>如果 A[k/2−1] 或者 B[k/2−1] 越界，那么我们可以选取对应数组中的最后一个元素。在这种情况下，我们必须根据排除数的个数减少 k 的值，而不能直接将 k 减去k/2。</li>
<li>如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第 k 小的元素。</li>
<li>如果 k=1，我们只要返回两个数组首元素的最小值即可。</li>
</ul>
<p>用一个例子说明上述算法。假设两个有序数组如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: 1 3 4 9</span><br><span class="line">B: 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<p>两个有序数组的长度分别是 4 和 9，长度之和是 13，中位数是两个有序数组中的第 7 个元素，因此需要找到第 k=7 个元素。</p>
<p>比较两个有序数组中下标为 k/2−1=2 的数，即A[2] 和B[2]，如下面所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A: 1 3 4 9</span><br><span class="line">       ↑</span><br><span class="line">B: 1 2 3 4 5 6 7 8 9</span><br><span class="line">       ↑</span><br></pre></td></tr></table></figure>

<p>由于A[2]&gt;B[2]，因此排除 B[0] 到 B[2]，即数组 B 的下标偏移（offset）变为 3，同时更新 k 的值：k=k−k/2=4。</p>
<p>下一步寻找，比较两个有序数组中下标为 k/2−1=1 的数，即 A[1] 和 B[4]，如下面所示，其中方括号部分表示已经被排除的数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A: 1 3 4 9</span><br><span class="line">     ↑</span><br><span class="line">B: [1 2 3] 4 5 6 7 8 9</span><br><span class="line">             ↑</span><br></pre></td></tr></table></figure>

<p>由于 A[1]&lt;B[4]，因此排除A[0] 到 A[1]，即数组 A 的下标偏移变为 2，同时更新 k 的值：k=k−k/2=2。</p>
<p>下一步寻找，比较两个有序数组中下标为k/2−1=0 的数，即比较A[2] 和 B[3]，如下面所示，其中方括号部分表示已经被排除的数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A: [1 3] 4 9</span><br><span class="line">         ↑</span><br><span class="line">B: [1 2 3] 4 5 6 7 8 9</span><br><span class="line">           ↑</span><br></pre></td></tr></table></figure>

<p>由于A[2]=B[3]，根据之前的规则，排除A 中的元素，因此排除 A[2]，即数组 A 的下标偏移变为 3，同时更新 k 的值： k=k−k/2=1。</p>
<p>由于 k 的值变成 1，因此比较两个有序数组中的未排除下标范围内的第一个数，其中较小的数即为第 k 个数，由于 A[3]&gt;B[3]，因此第 kk 个数是 B[3]=4。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A: [1 3 4] 9</span><br><span class="line">           ↑</span><br><span class="line">B: [1 2 3] 4 5 6 7 8 9</span><br><span class="line">           ↑</span><br></pre></td></tr></table></figure>

<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class FindMedianSortedArrays &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums1 &#x3D; &#123;1,2,3&#125;;</span><br><span class="line">        int[] nums2 &#x3D; &#123;4,5,6,7,8,9,10,11,12,13,14,17&#125;;</span><br><span class="line">        System.out.println(findMedianSortedArrays( nums1,  nums2));</span><br><span class="line">    &#125;</span><br><span class="line">    public static double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        int length1 &#x3D; nums1.length, length2 &#x3D; nums2.length;</span><br><span class="line">        int totalLength &#x3D; length1 + length2;</span><br><span class="line">        if (totalLength % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            int midIndex &#x3D; totalLength &#x2F; 2;</span><br><span class="line">            double median &#x3D; getKthElement(nums1, nums2, midIndex + 1);</span><br><span class="line">            return median;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int midIndex1 &#x3D; totalLength &#x2F; 2 - 1, midIndex2 &#x3D; totalLength &#x2F; 2;</span><br><span class="line">            double median &#x3D; (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) &#x2F; 2.0;</span><br><span class="line">            return median;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static double getKthElement(int[] nums1, int[] nums2, int k) &#123;</span><br><span class="line">        &#x2F;* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 &#x3D; nums1[k&#x2F;2-1] 和 pivot2 &#x3D; nums2[k&#x2F;2-1] 进行比较</span><br><span class="line">         * 这里的 &quot;&#x2F;&quot; 表示整除</span><br><span class="line">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k&#x2F;2-2] 共计 k&#x2F;2-1 个</span><br><span class="line">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k&#x2F;2-2] 共计 k&#x2F;2-1 个</span><br><span class="line">         * 取 pivot &#x3D; min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k&#x2F;2-1) + (k&#x2F;2-1) &lt;&#x3D; k-2 个</span><br><span class="line">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span><br><span class="line">         * 如果 pivot &#x3D; pivot1，那么 nums1[0 .. k&#x2F;2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span><br><span class="line">         * 如果 pivot &#x3D; pivot2，那么 nums2[0 .. k&#x2F;2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span><br><span class="line">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span><br><span class="line">         *&#x2F;</span><br><span class="line">        int length1 &#x3D; nums1.length, length2 &#x3D; nums2.length;</span><br><span class="line">        int index1 &#x3D; 0, index2 &#x3D; 0;</span><br><span class="line">        int kthElement &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            &#x2F;&#x2F; 边界情况</span><br><span class="line">            if (index1 &#x3D;&#x3D; length1) &#123;</span><br><span class="line">                return nums2[index2 + k - 1];</span><br><span class="line">            &#125;</span><br><span class="line">            if (index2 &#x3D;&#x3D; length2) &#123;</span><br><span class="line">                return nums1[index1 + k - 1];</span><br><span class="line">            &#125;</span><br><span class="line">            if (k &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                return Math.min(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 正常情况</span><br><span class="line">            int half &#x3D; k &#x2F; 2;</span><br><span class="line">            int newIndex1 &#x3D; Math.min(index1 + half, length1) - 1;</span><br><span class="line">            int newIndex2 &#x3D; Math.min(index2 + half, length2) - 1;</span><br><span class="line">            int pivot1 &#x3D; nums1[newIndex1], pivot2 &#x3D; nums2[newIndex2];</span><br><span class="line">            if (pivot1 &lt;&#x3D; pivot2) &#123;</span><br><span class="line">                k -&#x3D; (newIndex1 - index1 + 1);</span><br><span class="line">                index1 &#x3D; newIndex1 + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                k -&#x3D; (newIndex2 - index2 + 1);</span><br><span class="line">                index2 &#x3D; newIndex2 + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-33-搜索旋转排序数组"><a href="#LeetCode-33-搜索旋转排序数组" class="headerlink" title="(LeetCode-33)搜索旋转排序数组"></a>(LeetCode-33)搜索旋转排序数组</h2><h3 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h3><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1], target &#x3D; 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<h3 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h3><h4 id="方法一：二分查找-1"><a href="#方法一：二分查找-1" class="headerlink" title="方法一：二分查找"></a>方法一：二分查找</h4><p>思路和算法</p>
<p>对于有序数组，可以使用二分查找的方法查找元素。</p>
<p>但是这道题中，数组本身不是有序的，进行旋转后只保证了数组的局部是有序的，这还能进行二分查找吗？答案是可以的。</p>
<p>可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，我们从 6 这个位置分开以后数组变成了 [4, 5, 6] 和 [7, 0, 1, 2] 两个部分，其中左边 [4, 5, 6] 这个部分的数组是有序的，其他也是如此。</p>
<p>这启示我们可以在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r] 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分：</p>
<ul>
<li>如果 [l, mid - 1] 是有序数组，且 target 的大小满足 [nums[l],nums[mid])，则我们应该将搜索范围缩小至 [l, mid - 1]，否则在 [mid + 1, r] 中寻找。</li>
<li>如果 [mid, r] 是有序数组，且 target 的大小满足 (nums[mid+1],nums[r]]，则我们应该将搜索范围缩小至 [mid + 1, r]，否则在 [l, mid - 1] 中寻找。</li>
</ul>
<p><img src="images/Leetcode2/Leetcode2_14.png" alt="Leetcode2_14"></p>
<p>需要注意的是，二分的写法有很多种，所以在判断 <code>target</code> 大小与有序部分的关系的时候可能会出现细节上的差别。</p>
<h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class MidSearch &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;int[] nums &#x3D; &#123;4,5,6,7,0,1,2&#125;;</span><br><span class="line">        int[] nums &#x3D; &#123;3, 1&#125;;</span><br><span class="line">       &#x2F;&#x2F; int[] nums &#x3D; &#123;4,5,6,7,0,1,2&#125;;</span><br><span class="line">        &#x2F;&#x2F;int[] nums &#x3D; &#123;1&#125;;</span><br><span class="line">        int a &#x3D; new MidSearch().search(nums, 1);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        if (n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return nums[0] &#x3D;&#x3D; target ? 0 : -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return search1( nums, 0, nums.length - 1,  target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int search1(int[] nums, int start, int end, int target) &#123;</span><br><span class="line">        while (start &lt;&#x3D; end)&#123;</span><br><span class="line">            int mid &#x3D;  (end + start) &#x2F; 2;</span><br><span class="line">            if(nums[mid] &#x3D;&#x3D; target)&#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;</span><br><span class="line">            if(nums[start] &lt;&#x3D; nums[mid])&#123;</span><br><span class="line">                &#x2F;&#x2F; 判断是否在范围内</span><br><span class="line">                if(nums[start] &lt;&#x3D; target &amp;&amp; target &lt; nums[mid])&#123;</span><br><span class="line">                    end &#x3D; mid -1;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    start &#x3D; mid + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                if(nums[mid] &lt; target &amp;&amp; target &lt;&#x3D; nums[end])&#123;</span><br><span class="line">                    start &#x3D; mid + 1;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    end &#x3D; mid -1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-34-在排序数组中查找元素的第一个和最后一个位置"><a href="#LeetCode-34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="(LeetCode- 34) 在排序数组中查找元素的第一个和最后一个位置"></a><strong>(LeetCode- 34) 在排序数组中查找元素的第一个和最后一个位置</strong></h2><h3 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h3><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [], target &#x3D; 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>

<h3 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h3><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a><strong>方法</strong></h4><p>由于数组已经排序，我们可以利用二分法来加速查找的过程。</p>
<h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class SearchRange &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums &#x3D; &#123;5,7,7,8,8,10&#125;;</span><br><span class="line">        int[]  result &#x3D; new SearchRange().searchRange( nums,  8);</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int[] searchRange(int[] nums, int target) &#123;</span><br><span class="line">        int left &#x3D;  searchLeft( nums,  0,  nums.length - 1,  target);</span><br><span class="line">        int right &#x3D;  searchRight( nums,  0,  nums.length - 1,  target);</span><br><span class="line">        int[] result &#x3D; &#123;left, right&#125;;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int searchLeft(int[] nums, int start, int end, int target) &#123;</span><br><span class="line">        int idx &#x3D; -1;</span><br><span class="line">        while (start &lt;&#x3D; end)&#123;</span><br><span class="line">            int mid &#x3D; ( start + end ) &#x2F; 2 ;</span><br><span class="line">            if(nums[mid] &gt;&#x3D; target)&#123;</span><br><span class="line">                end &#x3D; mid - 1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                start &#x3D; mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            if( nums[mid] &#x3D;&#x3D; target)&#123;</span><br><span class="line">                idx &#x3D; mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return idx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int searchRight(int[] nums, int start, int end, int target) &#123;</span><br><span class="line">        int idx &#x3D; -1;</span><br><span class="line">        while (start &lt;&#x3D; end)&#123;</span><br><span class="line">            int mid &#x3D; ( start + end ) &#x2F; 2 ;</span><br><span class="line">            if(nums[mid] &gt; target)&#123;</span><br><span class="line">                end &#x3D; mid - 1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                start &#x3D; mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            if( nums[mid] &#x3D;&#x3D; target)&#123;</span><br><span class="line">                idx &#x3D; mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-153-寻找旋转排序数组中的最小值"><a href="#LeetCode-153-寻找旋转排序数组中的最小值" class="headerlink" title="(LeetCode- 153) 寻找旋转排序数组中的最小值"></a><strong>(LeetCode- 153) 寻找旋转排序数组中的最小值</strong></h2><h3 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h3><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：</p>
<ul>
<li>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]</li>
<li>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]</li>
</ul>
<p><strong>注意</strong>，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p>
<p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<h3 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class FindMin &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public int findMin(int[] nums) &#123;</span><br><span class="line">        if(nums.length &#x3D;&#x3D; 1)&#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        int start &#x3D; 0;</span><br><span class="line">        int end &#x3D; n - 1;</span><br><span class="line">        while (start &lt;&#x3D; end)&#123;</span><br><span class="line">            if(start + 1 &#x3D;&#x3D; end)&#123;</span><br><span class="line">                return Math.min(nums[start], nums[end]);</span><br><span class="line">            &#125;</span><br><span class="line">            int mid &#x3D; ( start + end ) &#x2F; 2;</span><br><span class="line">            if(nums[start] &lt;&#x3D; nums[mid] &amp;&amp; nums[mid] &lt;&#x3D; nums[end])&#123;</span><br><span class="line">                return nums[start];</span><br><span class="line">                &#x2F;&#x2F;在左边</span><br><span class="line">            &#125;else if( nums[start] &gt;&#x3D; nums[mid] &amp;&amp; nums[mid] &lt; nums[end] )&#123;</span><br><span class="line">                end &#x3D; mid ;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                start &#x3D; mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-240-搜索二维矩阵-II"><a href="#LeetCode-240-搜索二维矩阵-II" class="headerlink" title="(LeetCode- 240) 搜索二维矩阵 II"></a><strong>(LeetCode- 240) 搜索二维矩阵 II</strong></h2><h3 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h3><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="./" alt="Leetcode2_15"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 5</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="./" alt="Leetcode2_16"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 20</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m &#x3D;&#x3D; matrix.length</span><br><span class="line">n &#x3D;&#x3D; matrix[i].length</span><br><span class="line">1 &lt;&#x3D; n, m &lt;&#x3D; 300</span><br><span class="line">-109 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 109</span><br><span class="line">每行的所有元素从左到右升序排列</span><br><span class="line">每列的所有元素从上到下升序排列</span><br><span class="line">-109 &lt;&#x3D; target &lt;&#x3D; 109</span><br></pre></td></tr></table></figure>

<h3 id="分析-16"><a href="#分析-16" class="headerlink" title="分析"></a>分析</h3><h4 id="方法三：Z-字形查找"><a href="#方法三：Z-字形查找" class="headerlink" title="方法三：Z 字形查找"></a>方法三：Z 字形查找</h4><p>思路与算法</p>
<p>我们可以从矩阵matrix 的右上角 (0,n−1) 进行搜索。在每一步的搜索过程中，如果我们位于位置(x,y)，那么我们希望在以 matrix 的左下角为左下角、以(x,y) 为右上角的矩阵中进行搜索，即行的范围为 [x, m - 1][x,m−1]，列的范围为 [0, y][0,y]：</p>
<ul>
<li>如果 [x,y]=target，说明搜索完成；</li>
<li>如果 [x,y]&gt;target，由于每一列的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于第 y 列的元素都是严格大于 target 的，因此我们可以将它们全部忽略，即将 y 减少 1；</li>
<li>如果 [x,y]&lt;target，由于每一行的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于第 x 行的元素都是严格小于 target 的，因此我们可以将它们全部忽略，即将 x 增加 1。</li>
</ul>
<p>在搜索的过程中，如果我们超出了矩阵的边界，那么说明矩阵中不存在 target。</p>
<h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class SearchMatrix &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[][] matrix &#x3D; &#123;&#123;1,4,7,11,15&#125;, &#123;2,5,8,12,19&#125;,&#123;3,6,9,16,22&#125;, &#123;10,13,14,17,24&#125;,&#123;18,21,23,26,30&#125; &#125;;</span><br><span class="line">        boolean  falew &#x3D; new SearchMatrix().searchMatrix( matrix,  29);</span><br><span class="line">        System.out.println(matrix.length);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean searchMatrix(int[][] matrix, int target) &#123;</span><br><span class="line">        if(matrix &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 矩阵行和列下标的最大值</span><br><span class="line">        int cols &#x3D; matrix[0].length-1;</span><br><span class="line">        int rows &#x3D; matrix.length-1;</span><br><span class="line">        if(target &gt; matrix[rows][cols]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int currentCol &#x3D; cols;</span><br><span class="line">        int currentRow &#x3D; 0;</span><br><span class="line">        while (currentCol &gt;&#x3D; 0 &amp;&amp; currentRow &lt;&#x3D; rows)&#123;</span><br><span class="line">            if(target &#x3D;&#x3D; matrix[currentRow][currentCol])&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else if(target &lt; matrix[currentRow][currentCol])&#123;</span><br><span class="line">                currentCol--;</span><br><span class="line">            &#125;else if(target &gt; matrix[currentRow][currentCol])&#123;</span><br><span class="line">                currentRow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LeetCode/" rel="tag"># LeetCode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/09/08/LeetCode/2022-09-10%20leetcode%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/" rel="prev" title="leetcode算法-递归">
      <i class="fa fa-chevron-left"></i> leetcode算法-递归
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/09/08/LeetCode/2022-09-08%20%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%88%86%E6%9E%90/" rel="next" title="leetcode算法">
      leetcode算法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">1.</span> <span class="nav-text">(LeetCode-1)两数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE"><span class="nav-number">1.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90"><span class="nav-number">1.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%951"><span class="nav-number">1.2.1.</span> <span class="nav-text">方法1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%952"><span class="nav-number">1.2.2.</span> <span class="nav-text">方法2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="nav-number">1.3.</span> <span class="nav-text">代码示例：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">2.</span> <span class="nav-text">(LeetCode-88) 合并两个有序数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="nav-number">2.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-1"><span class="nav-number">2.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%951-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">方法1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%952-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">方法2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="nav-number">3.</span> <span class="nav-text">(LeetCode-283)移动零</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="nav-number">3.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-2"><span class="nav-number">3.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.1.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">3.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">4.</span> <span class="nav-text">(LeetCode-448)找到所有数组中消失的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-3"><span class="nav-number">4.1.</span> <span class="nav-text">题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="nav-number">5.</span> <span class="nav-text">(LeetCode-169) 多数元素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-4"><span class="nav-number">5.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-3"><span class="nav-number">5.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%951-2"><span class="nav-number">5.2.1.</span> <span class="nav-text">方法1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%952-2"><span class="nav-number">5.2.2.</span> <span class="nav-text">方法2</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">6.</span> <span class="nav-text">(LeetCode-11) 盛最多水的容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-5"><span class="nav-number">6.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-4"><span class="nav-number">6.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">6.2.1.</span> <span class="nav-text">方法一：双指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">6.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">7.</span> <span class="nav-text">(LeetCode-15) 三数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-6"><span class="nav-number">7.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-5"><span class="nav-number">7.2.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="nav-number">7.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="nav-number">8.</span> <span class="nav-text">(LeetCode-31)下一个排列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-7"><span class="nav-number">8.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-6"><span class="nav-number">8.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%B8%A4%E9%81%8D%E6%89%AB%E6%8F%8F"><span class="nav-number">8.2.1.</span> <span class="nav-text">方法一：两遍扫描</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="nav-number">8.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="nav-number">9.</span> <span class="nav-text">**(LeetCode-48) **旋转图像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-8"><span class="nav-number">9.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-7"><span class="nav-number">9.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A%E7%94%A8%E7%BF%BB%E8%BD%AC%E4%BB%A3%E6%9B%BF%E6%97%8B%E8%BD%AC"><span class="nav-number">9.2.1.</span> <span class="nav-text">方法：用翻转代替旋转</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="nav-number">9.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="nav-number">10.</span> <span class="nav-text">**(LeetCode-54) **螺旋矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-9"><span class="nav-number">10.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-8"><span class="nav-number">10.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E6%8C%89%E5%B1%82%E6%A8%A1%E6%8B%9F"><span class="nav-number">10.2.1.</span> <span class="nav-text">方法二：按层模拟</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="nav-number">10.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="nav-number">11.</span> <span class="nav-text">**(LeetCode-55) **跳跃游戏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-10"><span class="nav-number">11.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-9"><span class="nav-number">11.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%951-3"><span class="nav-number">11.2.1.</span> <span class="nav-text">方法1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%952-3"><span class="nav-number">11.2.2.</span> <span class="nav-text">方法2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="nav-number">11.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="nav-number">12.</span> <span class="nav-text">**(LeetCode-215)**数组中的第K个最大元素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-11"><span class="nav-number">12.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-10"><span class="nav-number">12.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E9%80%89%E6%8B%A9%E6%96%B9%E6%B3%95"><span class="nav-number">12.2.1.</span> <span class="nav-text">方法一：基于快速排序的选择方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="nav-number">12.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="nav-number">13.</span> <span class="nav-text">(LeetCode-347) 前 K 个高频元素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-12"><span class="nav-number">13.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-11"><span class="nav-number">13.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%A0%86"><span class="nav-number">13.2.1.</span> <span class="nav-text">方法一：堆</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="nav-number">13.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">14.</span> <span class="nav-text">**(LeetCode-4) **寻找两个正序数组的中位数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-13"><span class="nav-number">14.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-12"><span class="nav-number">14.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">14.2.1.</span> <span class="nav-text">方法一：二分查找</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="nav-number">14.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">15.</span> <span class="nav-text">(LeetCode-33)搜索旋转排序数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-14"><span class="nav-number">15.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-13"><span class="nav-number">15.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-1"><span class="nav-number">15.2.1.</span> <span class="nav-text">方法一：二分查找</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-9"><span class="nav-number">15.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="nav-number">16.</span> <span class="nav-text">(LeetCode- 34) 在排序数组中查找元素的第一个和最后一个位置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-15"><span class="nav-number">16.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-14"><span class="nav-number">16.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-1"><span class="nav-number">16.2.1.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-10"><span class="nav-number">16.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-number">17.</span> <span class="nav-text">(LeetCode- 153) 寻找旋转排序数组中的最小值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-16"><span class="nav-number">17.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-15"><span class="nav-number">17.2.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-11"><span class="nav-number">17.3.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode-240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II"><span class="nav-number">18.</span> <span class="nav-text">(LeetCode- 240) 搜索二维矩阵 II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-17"><span class="nav-number">18.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-16"><span class="nav-number">18.2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9AZ-%E5%AD%97%E5%BD%A2%E6%9F%A5%E6%89%BE"><span class="nav-number">18.2.1.</span> <span class="nav-text">方法三：Z 字形查找</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-12"><span class="nav-number">18.3.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="QingSong"
      src="/images/avatar/avatar.png">
  <p class="site-author-name" itemprop="name">QingSong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">198</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QingSong</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
